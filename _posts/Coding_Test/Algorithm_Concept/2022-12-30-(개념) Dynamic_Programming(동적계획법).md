---
title:  "[개념] Dynamic_Programming(동적계획법)"
categories : Algorithm
tag : [알고리즘]
toc: true
toc_sticky: true
author_profile: false
sidebar:
  nav: "docs"
typora-root-url: ../../..
---



## Intro..

**기존 분할정복식(하향식:TopBottom)은 중복계산이 단점**

* 발전 시킨 방식이 **TopBottom:Memoization** 방식이며 중복계산을 없앰 => DP로 분류
* 다만, 하향식 방식들은 재귀 리턴 오버헤드가 아쉽다.



**반변, 동적계획법(상향식:BottomTop)은 중복계산이 없음**

* 분할해서 나누어진 부분들 문제들을 먼저 풀면서 점점 상향으로 올라가는 방식
* 추가 메모리 사용(배열에 기록 등등), 보통 for문이 제일 흔한 방법
* 다만, 필요없는 값도 계산한다는 점이 아쉽다.



그럼 언제 분할정복식을 쓰고, 언제 동적계획법을 쓰는게 좋은지 궁금증이 생긴다.

보통 `분할정복식`은 **상관관계 없을 때** 좋다고 하고, `동적계획법`은 **상관관계 있을 때** 좋다고 한다.

<br>

## 동적계획법(DP) 이용한 알고리즘들

### **피보나치의 수**

* top-bottom(MEMOIZATION) 방식 : `f[n] = fib(n-1) + fib(n-2);` 코드가 핵심이다.
* 기존 알고리즘에서 f[n] 배열을 따로 추가해서 배열에 기록을 해서 재사용을 해나가는게 핵심인 것!
* 기존 알고리즘은 다른 게시물에 있으니 참고!



### **이항계수**

* 기존엔 팩토리얼로 공식을 이용해서 풀었을 텐데, 여기선 아래 식을 활용하자.

  *   ![img](/images/2022-12-30-(개념) Dynamic_Programming(동적계획법)/DRW000019e872e8-16723248987111.gif)  

* 코드를 보는게 이해하기 훨씬 편할테니 바로 코드를 보자.

* **BottomTop 방식 코드**

  <img src="/images/2022-12-30-(개념) Dynamic_Programming(동적계획법)/image-20221229234303945.png" alt="image-20221229234303945" style="zoom:80%;" />

  * 배열에 채워지는 모습은 아래 그림을 통해 이해하자.


​						  <img src="/images/2022-12-30-(개념) Dynamic_Programming(동적계획법)/image-20221229235007320.png" alt="image-20221229235007320" style="zoom:80%;" />



  * **TopBottom 방식 코드**

<img src="/images/2022-12-30-(개념) Dynamic_Programming(동적계획법)/image-20221229234538342.png" alt="image-20221229234538342" style="zoom:80%;" />



### **격자경로**

* **너무나도 유명한 격자경로를 정리해보겠다(기본형태)**

  <img src="/images/2022-12-30-(개념) Dynamic_Programming(동적계획법)/image-20221230172551780.png" alt="image-20221230172551780" style="zoom:80%;" />

  * 참고로 식에 P(j,1)은 오타이고 P(i,1)로 봐야한다.

  * 보통 격자경로는 이런 그림의 형태를 가지며, S->T로 가는 최단경로의 개수를 구하는게 목표이다.

  * 또한, S에서 출발해서 오른쪽과 아래로만 이동을 할 수 있다.

  * 여기서 특징이 nCk로 조합을 이용해서 한번에 구할수도 있다.
    * 최대로 오른쪽과 아래로 가서 총 움직이는 수는? 12이다. 이를 n으로 보자.
    * 12번 움직이고 4번 아래로가는 서로다른 최단 경로개수? `12C4`
    * 12번 움직이고 8번 오른쪽가는 ..? `12C8`
    * `12C4=12C8` 이란것은 수학적으로 자명하기 때문에, `12C4`로 바로 값을 구할 수 있다.
    
  * 앞서 정리한 이항계수 알고리즘처럼 여기서도 유사하게 DP로 풀면 된다.
    * `P(i,j)=P(i-1,j) + P(i,j-1)`  가 핵심 알고리즘이다.
    
    * 그림을 보고 이해하자면, `(i,j)`자리에 그 왼쪽인 `(i,j-1)`자리와 그 위인 `(i-1,j)` 자리를 더해서 2, 3, 4, 5... 이런식으로 구해가고 있다는걸 이해하면 충분히 이 문제는 이해할 수 있다.
    
      

* **이번엔 기본형태의 조금 응용버전인 표시된 곳은 못지나가는 경우에 구하는 것을 보겠다.**

  <img src="/images/2022-12-30-(개념) Dynamic_Programming(동적계획법)/image-20221230174030582.png" alt="image-20221230174030582" style="zoom:80%;" />

  * 마크가 되어있는곳의 경우 **0**으로 두고, 아닌경우 기존방식 그대로 사용 시 해결할 수 있다.

  * 이유를 생각해보면, 표시된 곳은 지나갈 수 없기 때문에 경로가 아예 없는것이다.

  * 따라서 기존방식에선 `(i-1,j), (i,j-1)` 위치의 값을 더해서 구하기 때문에, 이때 표시된 곳이  
    만약 `(i-1,j)` 였을 경우 **0**으로 설정해뒀으면 더해도 `(i-1,j)` 위치의 값은 안더한거나 마찬가지이게 되는 것이다.
    
    

* **여기서 또 응용된 버전으로 표시된곳을 오히려 b(1<=b)번 이상 지나가야 하는 경우를 보겠다.**

  <img src="/images/2022-12-30-(개념) Dynamic_Programming(동적계획법)/image-20221230174758217.png" alt="image-20221230174758217" style="zoom:80%;" />

  * **이 예제는 b=2인 경우로 3차원 배열에 b=0, b=1, b=2인 경우들 최단경로 개수를 기록해 나간다.**
    * `(표시없는길 개수)/(표시1번 지난길 개수)/(표시2번 지난길 개수)` 로 볼 수 있다.
  * 구해나가는 방법은 우선 표시(mark)가 없다고 가정해서 표시있는 구역에서 기존과 동일하게 구한다.
  * 다음으로 표시가 있는지 확인 후 있다면 선언했던 3차원 배열에서 각 차원들 값을 다음 차원들로 각각 옮겨준다. 
    * 물론, b=2라서 3차원이니까 3차원 이상으로 넘어가는건 무시하고 계속 3차원에서 같이 합해준다.
  * 그림을 보면, T까지 다구한것은 아닌데 그 위의 점까지 구한 결과는 **44**라는것을 확인 할 수 있다.



### **Coin Changing Using DP – 물건을 구매하고, 거스름돈 교환**

* 이 문제는 물건을 살때 지페를 내고 거스름돈으로 동전을 돌려받는 문제인데,   
  **돌려주는 잔돈(동전)의 개수를 최소화 하는 알고리즘을 의미한다.**

  * 이 알고리즘에서 생각해야할 점이 있다.

  * 만약 동전이 `1원, 7원, 10원`이 존재하며 이때 `14원`을 거스름돈으로 돌려줘야 하는경우를 생각해보자.

    * 정말 간단히 그리디(탐욕적)방법으로 생각하면 `10x1 + 1x4 = 14` 로 총 `5개` 동전을 거슬러준다.
    * 그런데, 이는 최적의 답이 아니다. 실제로는 `7x2 = 14` 로 총 `2개`의 동전만 거슬러주면 된다.
    * 따라서 이런 경우가 있다는것을 잘 이해하고 넘어가야한다.

    <img src="/images/2022-12-30-(개념) Dynamic_Programming(동적계획법)/image-20221230180254294.png" alt="image-20221230180254294" style="zoom:80%;" />

  * 이 알고리즘을 DP로 푸는 방식을 나타낸 그림이다.

  * 아래 공식을 이해하기전 위 코드들이 사용된 구조를 이해하자.

    * `denom`은 액면가(주어진 동전 종류인 1원, 10원, 100원 등등 의미)를 나타낸 배열이다.
    * 위 그림은 `C배열`을 나타낸것이며 DP 방식을 사용해서 채워나간 배열이다.
    * C배열의 `i`는 3개인데, denom[1~3]으로 3개의 액면가가 있다고 이해할 수 있다.
    * `j`는 총 잔돈으로 거슬러 줄 가격을 의미한다.
    * 마지막으로 `내부의 요소`들은 거슬러 준 동전의 개수를 의미하는 것이다.

  * 아래 공식의 의미를 이제 이해해보자.

  * 먼저, `0, if(j=0)` 이것의 의미는?

    * j가 0이면 거슬러줄 돈이 0원이란건데, 그럼 당연히 거슬러줄 때 필요한 동전개수는 0이다.

  * `c[i-1][j], if(denom[i]>j)` 이것의 의미는?

    * 액면가(denom[i])가 j(거슬러줄 총값)보다 크다는것은 해당 액면가(denom[i])는 현재 거슬러줄 수 없다는 것이기 때문에, 이전의 값인 `c[i-1][j]` 값을 그대로 사용한다는 의미이다.

  * `min(c[i-1][j], 1+c[i][j-denom[i]]), if(denom[i]<=j)` 의 의미는?

    * 액면가가 거슬러줄 총값보다 작거나 같다는 것은 해당 액면가를 사용할 수 있다는 것이다.
    * 따라서 이전의 값과 현재 액면가를 사용한 값을 비교해서 최소값(min)을 사용한다.
    * 참고로 `1+..` 는 현재 액면가를 쓰는걸 가정해서 동전 1개를 추가한것이고,
    * `j-denom[i]` 는 현재 액면가를 더하면 정확히 j(거슬러줄 총값)값과 같게 만들어줄 위치로 이동시켜준다.
      * 이부분 이해가 안가면 그림보고 손으로 해보면 바로 이해가 될것이다.
      * 참고로 i=1인 c배열 부분들은 현재 이 조건으로 생성이 된다는걸 이해하면 완벽하다.

  * 따라서 여기서 최종 해답인 동전개수는 `c[3][12]` 의 위치인 **2개** 가 최종 답이 된다.

  

* **물론, 이렇게 구했을때 무슨 동전들을 선택한건지도 역추적으로 간단히 구할 수 있다.**

  <img src="/images/2022-12-30-(개념) Dynamic_Programming(동적계획법)/image-20221230182438724.png" alt="image-20221230182438724" style="zoom:80%;" />

  * 또다른 예제인 이 그림을 보면 역추적을 통해서 `1원 3개, 7원 1개, 15원 1개` 라고 구한 모습이다.
  * 정말 간단한 원리이다.
    * 맨 마지막 위치인 `c[3][25]`에서 위에값이 내려온건지 왼쪽의 값이 온건지 판단하면 된다.
    * 만약, 위의 값과 현재위치 값이 다르다?? 왼쪽의 값을 추적하면 된다.
      * 이때 왼쪽값 추적은 현재 위치가 (i,j)라 하면 j(거스름돈 총값)에서   
        현재 액면가(denom[i])를 빼주면 된다. => 즉,  `j-denom[i]` 로 인덱스 추적하면 된다.
      * 결론은 왼쪽값 추적할땐 해당 위치의 액면가(denom[i])인 동전 1개를 사용했다는 의미이다.
    * 그리고 위의 값과 현재위치 값이 같다?? 바로 위의 값으로 추적(이동)하면 된다.



### **연쇄 행렬곱셈(Matrix-chain Multiplication)**





### **최단거리(Floyd)**

### **LCS**

### **OBST**

<br>

## DP가 불가능한 경우는?

DP가 불가능한 경우는 무엇일지가 궁금했는데 DP에는 **최적의 원칙(the principle of optimality)** 이란게 있다.  
**최적의 원칙이 적용이 되어야 DP가 가능하다는 것이다.**



예를들어 경로의 문제를 생각해보면

* vi->vk 문제와 vi->vj 로 가는 문제에서 vi->vj가 vk를 경유할 때,
* v->vk와 vi->vk->vj에서의 vi->vk가 서로 경로가 다르면 안된다.
* 최적의 원칙이 적용이 안되는 예들 중에 하나는 최장경로의 문제가 있다.

