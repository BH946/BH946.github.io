---
title:  "[백준_필수3]알고리즘 템플릿 - cpp"
categories : [Baekjoon]
tag : [백준, 프로그래머스, 알고리즘 문제풀이]
toc: trues
toc_sticky: true
author_profile: false
sidebar:
   nav: "docs"
typora-root-url: ../../..
---





# Intro..

**사용할 알고리즘들의 템플릿들을 정리하겠다.**

**물론 약간의 알고리즘 해석만을 동반하며, 자세한 해석은 아래 링크를 달아두겠다.**

* **참고 링크 : [바킹독](https://blog.encrypted.gg/category/%EA%B0%95%EC%A2%8C/%EC%8B%A4%EC%A0%84%20%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98?page=1)**

> 공부하면서 바킹독님의 유튜브, 블로그의 도움을 많이 받았습니다!!



@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

채워나갈 순서

1. 바킹독 전부 템플릿
2. 알고리즘 기초1 수학, 알고리즘 고급트리, 알고리즘 컴퓨터그래픽스 템플릿

@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

<br><br>

## 재귀(Recursion)

**`절차지향적 사고 -> 귀납적 사고` 가 반드시 필요!!!**

**절차적으로 이해하지 마라!! 귀납적으로 그냥 이렇게 되겠구나라고 생각만 하라!! 도미노를 생각!!**

* **수학적 귀납법**
  * **1번 도미노가 쓰러진다.  
    k번 도미노가 쓰러지면 k+1번 도미노도 쓰러진다.**
    * 참(true) : **1번 도미노가 쓰러진다, k번 도미노가 쓰러지면(가정)**
    * 두 문장이 참이므로 **k+1번 도미노..** 또한 귀납적으로 참
  * **예시1) 아래 코드의 예시**
    * **func1(1)이 1을 출력한다.  
      func1(k)가 k,k-1,k-2...1을 출력하면 func1(k+1)은 k+1,k,k-1,k-2...1을 출력한다.**
  * **예시2) 하노이 탑 이동 순서(n개 원판을 기둥 1 -> 기둥 3 으로 이동)**
    * n-1개의 원판을 1->2 이동  
      n번 원판을 1->3 이동  
      n-1개의 원판을 2->3 이동  
      => 규칙이 큰 원판 위에 작은 원판을 두는것이기 때문에 반드시 n-1개 원판이 기둥 2에 있고,   
      n번 원판이 기둥 1-> 기둥 3 으로 이동하는 경우의 존재는 생각해보면 자명하다.
    * **원판이 1개일 때 원판을 내가 원하는 곳으로 옮길 수 있다.  
      원판이 k개일 때 옮길 수 있으면 원판이 k+1개일 때에도 옮길 수 있다.**
* **재귀 함수의 조건**
  * Base condition : 특정 입력에 대해서는 자기 자신을 호출하지 않고 종료되어야 함
  * 모든 입력은 Base condition으로 수렴
* **재귀에 대한 정보**
  * 함수의 인자로 어떤 것을 받고 어디까지 계산한 후 자기 자신에게 넘겨줄지 명확하게 정해야 함
    * 모든 재귀 함수는 for문으로 만들 수 있음
    * 재귀는 for문 보다 메모리/시간에서 손해를 봄(함수 호출량 때문)

  * 한 함수가 자기 자신을 여러 번 호출하게 되면 비효율적일 수 있음(계산 중복 때문)
    * 예 : 피보나치 수열 => 해결법(DP로 중복 계산 재사용을 통해서 해결)

  * 재귀함수가 자기 자신을 부를 때 스택 영역에 계속 누적이 됨
    * 100000 정도 호출했을 때 정상동작 하지 않으면 구글 검색을 통해 스택 메모리 제한을 해제할 것

<br>

**재귀로 로직 작성 순서**

* **함수의 정의**
* **base condition**
* **재귀 식**

```c++
void func1(int n) {
    if(n==0) return; // base condition
    cout << n << ' ';
    func1(n-1);
}
```

<br><br>

## 백트래킹(Backtracking)

**N과 M(1) - 대표적인 템플릿**

```c++
// N과 M(1) : 1부터 N까지 자연수 중에서 중복 없이 M개를 고른 수열
#include <bits/stdc++.h>
using namespace std;

int n,m;
int arr[10];
bool isused[10];

void func(int k) {
    if(k == m) { // base condition
        for(int i = 0 ; i<m; i++) cout << arr[i] << ' ';
        cout << '\n';
        return;
    }
    for(int i = 1; i<=n; i++) {
        if(!isused[i]) {
            arr[k] = i;
            isused[i] = true;
            func(k+1); // 재귀
            isused[i] = false; // backtracking
        }
    }
}
```

<br>

**STL next_permutation - 수열과 조합에 유용(N과 M같은 문제들)**

* 배열 범위는 `sort` 처럼 end쪽 주소는 배열 사이즈 크기의 주소

![image-20230429035204359](/images/2023-01-03-(백준_필수3)알고리즘 템플릿 - cpp/image-20230429035204359.png)

<br><br>

## 시뮬레이션(구현)

**존나 풀어라... 단, 구현인 만큼 코드 작성 전 꼭 도식화를 진행**

* **존나 풀어라 : [구현(실버급 인기 순)](https://solved.ac/search?query=%23implementation+*s&sort=solved&direction=desc&page=1)**
* **자주 나오는 로직은 그냥 외우자**
  * 예로 2차원 배열 회전 로직은 (x,y) -> (y,n+1-x)


<br><br>

## 정렬(Sort)

**STL sort 이용 - O(NlogN)**

* 응용을 예시 들면, 정렬 때 같은 수는 인접하는 성질을 이용해 중복 원소 제거도 가능
* 주의사항 : 혹시나 `string` 같은 클래스 객체 전달시 반드시 `reference` 를 사용

```c++
#include<algorithm>
#include<vector>
vector<int> inArr[10000];
for i..N, order[x]=i; ... 
등등 선언을 가정

// 비교하는 함수를 따로 커스텀!!!
bool comp(const int a, int b) { // 당연히 const 안써도 됨
	return order[a] < order[b]; // inArr값을 order배열로 비교하게끔 커스텀
} // a가 b의 앞에 와야할 때 true, 그렇지 않을 때 false

sort(inArr[i].begin(), inArr[i].end(), comp); // end()는 마지막 index + 1
sort(&inArr[i][0], &inArr[i].back()+1, comp); // back()은 마지막 index
```

<br><br>

## 다이나믹 프로그래밍(DP)

**DP란 여러 개의 하위 문제를 먼저 푼 후 그 결과를 쌓아올려 주어진 문제를 해결하는 알고리즘**

**DP를 푸는 과정 - 테이블 잡고 식 찾는 연습이 매우매우 중요**

​	**1. 테이블 정의하기**

​	**2. 점화식 찾기**

​	**3. 초기값 정하기**

<br>

**EX) 1로 만들기 [BOJ : 1463번](https://www.acmicpc.net/problem/1463)**

* **테이블 정의하기**
  * D[i]는 i를 1로 만들기 위해 필요한 연산 사용 횟수의 최솟값
* **점화식 찾기**
  * D[12]는 ??   
    3로 나누면 (D[12] = D[4] + 1)  
    2로 나누면 (D[12] = D[6] + 1)  
    1을 빼면 (D[12] = D[11] + 1)  
    => D[12] = min(D[4]+1, D[6]+1, D[11]+1)
  * D[k] = ?   
    => D[k] = min(D[k/3]+1, D[k/2]+1, D[k-1]+1)
* **초기값 정의하기**
  * D[1] = 0

```c++
int d[1000005];
int n;
int main() {
    cin >> n;
    d[1] = 0;
    for(int i = 2; i<=n; i++) {
        d[i] = d[i-1]+1;
        if(i%2 == 0) d[i] = min(d[i], d[i/2]+1);
        if(i%3 == 0) d[i] = min(d[i], d[i/3]+1);
    }
    cout << d[n];
}
```

<br><br>

## 그리디(Greedy)

**그리디란 지금 가장 최적인 답을 근시안적으로 택하는 알고리즘 = 관찰을 통해 탐색 범위를 줄이는 알고리즘**

**구현자체는 굉장히 간단해서 따로 정해진 코드 탬플릿은 X**

**단, 코테에서 추천 전략은 문제가 100% 그리디 풀이란게 확신하면 짜서 제출 및 틀리면 빠르게 손절  
100% 확신이 없으면, 일단 넘어가고 마지막에 남은 시간에 코딩 시작**

<br><br>

