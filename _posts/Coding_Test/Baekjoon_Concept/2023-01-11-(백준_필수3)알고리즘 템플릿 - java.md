---
title:  "[백준_필수3]알고리즘 템플릿 - java"
categories : [Baekjoon]
tag : [백준, 프로그래머스, 알고리즘 문제풀이]
toc: trues
toc_sticky: true
author_profile: false
sidebar:
   nav: "docs"
typora-root-url: ../../..
---



# Intro..

**사용할 알고리즘들의 템플릿들을 정리하겠다.**

**물론 약간의 알고리즘 해석만을 동반하며, 자세한 해석은 아래 링크를 달아두겠다.**

* **참고 링크 : 구글링 등등**
* 코드들만 기록할랬는데,,, 정리하다보니 해석을 좀 많이했네,,

<br><br>

# Template

**반드시 백준에 제출할 때는 클래스명 : Main**

**package는 꼭 주석 or 제거**

```java
// 포괄적인 라이브러리 선언
import java.util.*;
import java.io.*;
```

<br><br>

## Java TIP

**inner class, inner static class**

* `inner class` 는 외부 클래스로 따로 빼는걸 추천하고, 내부 클래스는 static 사용을 권장
* [참고URL](https://yuja-kong.tistory.com/entry/Java-inner-class-%EC%99%80-inner-static-class-%EC%B0%A8%EC%9D%B4)

```java
class MyClass {
    class InnerClass{} // inner class
    static class InnerStaticClass{} // inner static class
}
```

<br>

**primitive type, reference type**

* `primitive type` 스택 사용 및 값 복사(깊은 복사)
  * 대표적 예시로 기본 타입 : boolean , byte , char , short , int , long , float, double
* `reference type` 힙 사용 및 주소값 복사(얕은 복사)
  * Array, Object, String 등등
  * **단, `String`은 값이 바뀔때 새로운 메모리 주소에 값을 생성하기 때문에 "깊은 복사" 로 생각하기도 하지만 기본 동작은 "얕은 복사" 라는점을 잘 이해하자**

```java
String a = "hello"; // a : hello
String b = a; // b : &a (a주소값 가지는 중)
a = "world"; // a : world (새로운 메모리 주소에 새로 world 저장)

// 출력결과 (마치 깊은 복사를 진행한것 같은 효과)
a : world
b : hello
```

<br><br>

## 입출력 - I/O

**일반 Scanner 방식보다 빠른 방식**

* **INPUT**으로 `BufferedReader, StringTokenizer` 사용
  * `System.in` 으로 입력을 `InputStreamReader` 로 받아서 `BufferedReader` 에 담는다.
  * `br.readLine()` 를 `" "` 기준으로 잘라서 `StringTokenizer` 에 담는다. (split 처럼)
  * 만약 입력의 끝나는 부분을 알고싶다면???
    * `br.readLine()==null` 로 알 수 있으며, 테스트는 **Ctrl+D** 를 입력하면 된다.
* **OUTPUT**으로 `StringBuilder` 사용
  * `System.out.println` 도 많이쓰지만, 많은 출력땐 `StringBuilder` 를 권장

```java
import java.io.IOException;
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.util.StringTokenizer;

public class Main {
	static int[][] arr = new int[301][301];

	public static void main(String[] args) throws IOException {
        // 1. 입력!!
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		StringTokenizer stk = new StringTokenizer(br.readLine()," ");
		int n = Integer.parseInt(stk.nextToken());
		int m = Integer.parseInt(stk.nextToken());
		// 그 다음 부터 n(행)번 입력 받기 (m은 열)
		for (int i = 0; i < n; i++) {
			stk = new StringTokenizer(br.readLine(), " "); 
			for (int j = 0; j < m; j++) {
				arr[i][j] = Integer.parseInt(stk.nextToken());
			}			
		}
        
		// 2. 출력!!
		StringBuilder sb = new StringBuilder(); 
		sb.append("n : " + n + ", m : " + m).append('\n');
		
		for (int i = 0; i < n; i++) {
			for (int j = 0; j < m; j++) {
				sb.append(arr[i][j]);
			}
			sb.append('\n');
		}
		System.out.println(sb);
	}
}
```

<br><br>

## 문자열 - string

**주의사항**

* c++처럼 java도 string은 문자열을 이어붙일때 잘못 사용하면 **O(N^2) 복잡도**를 발생시킬 수 있다.
  * `s+'a'` 라는 새 문자열 객체를 만든후 `s`에 더하기 때문에 `s+'a'` 만큼 매번 추가로 길이가 필요하기 때문이다.
* **따라서 반드시 아래 방식으로 사용해야한다 - O(N)**
  * `'a'` 만 생성되어서 `s` 에 더하기 때문에 `a` 만큼 길이만 추가로 필요하기 때문에 빠르다.
  * **`StringBuilder` 를 사용해야한다.**
* **한번에 초기화하는 fill 메소드 설명**
  * 배열, 리스트 - **`Arrays.fill(), Collections.fill()`**
* `String` 변경 불가, `StringBuilder` 변경 가능
* `parseInt()` : `String` -> `int`
  * `intValue()` : `Integer` -> `int`


```java
// 1. O(N^2) 복잡도 코드
String s = "hi";
s = s+" hello"
// 2. O(N) 복잡도 코드
StringBuilder sb = new StringBuilder();
sb.append("hi").append(" hello").toString();
s.insert, delete, deleteCharAt, setCharAt, reverse, setLength 등등 다양
```

<br>

**아래 문법들은 기본적으로 암기**

```java
String s = "abcde";
s.length();
s.isEmpty();
s.charAt(2); // index 2로 문자찾기
s.indexOf("c"); // 문자로 첫번째 인덱스 찾기
s.lastIndexOf("c"); // 문자로 마지막 인덱스 찾기

s.substring(2, 4); // 2~3 문자열
s.substring(3); // 3~ 문자열
s.replace('b', 'k'); // akcde (새로운 객체 생성)

s.equlas("abcde"); // 비교(기존 ==은 주소를 비교)
s.contains("bc"); // 포함여부
s.compareTo("abcdd"); // 동일:0, s가 사전순 앞:-1, s가 사전순 뒤:1, 마지막 문자만 다르면 마지막 문자의 사전순 차이 반환(여기선 1)
s.split(" ");
s.trim(); // 앞뒤만 공백 제거
s.toLowerCase();
s.toUpperCase();

Integer.parseInt("300"); // Str -> Int
Integer.toString(300); // Int -> Str
```

<br>

**한번에 초기화하는 fill 메소드 - Arrays, Collections**

```java
int[] myArray = new int[10];
Arryas.fill(myArray, 0); // 0으로 init
List<Integer> myList = new ArrayList<>(10);
Collections.fill(myList, null); // null로 init
```

<br><br>

## Array, List(ArrayList)

**List는 인터페이스라서 ArrayList(클래스) 로 구현, Array는 우리가 잘 아는 그 배열이다.**

**Array와 List의 차이는 정적, 동적 길이란 차이가 있고 `length, size()` 를 쓰는 차이도 있다.**

* **참고로 String은 `length()`**

```java
// Array init
int arr[] = {0,1,2}; // length:3
int[] arr = new int[3]; // length:3

// ArrayList init
ArrayList<String> arrayList = new ArrayList<>(Arrays.asList("apple", "banana"));
List<Integer> list = new ArrayList<>(); 
// method
list.add(값), list.get(index), list.set(index, 값), list.remove(index), list.remove(값), list.removeAll(list2) 등등
    
// 문자열 배열을 List로 변환
String[] temp = "abcde";
List<String> list = new ArrayList<>(Arrays.asList(temp));

// List를 문자열 배열로 변환
List<String> list = new ArrayList<>();
String[] temp = list.toArray(new String[list.size()]);

// 정수 배열을 List로 변환
int[] temp = { 123, 789, 456 };
List<Integer> list = new ArrayList<>(Arrays.asList(temp));

// List를 정수 배열로 변환
List<Integer> list = new ArrayList<>();
int[] temp = list.stream().mapToInt(i->i).toArray();

// 중복없이 값을 넣고 싶을 때 (원래는 sort후 중복 무시하는 형태로 얻었었는데, 좀 귀찮았음)
if (list.indexOf(value) < 0) {	// 없으면 -1 리턴
	list.put(value);
}

// 리스트 값 하나씩 가져올 때 (int 일 경우)
for(int i = 0; i < list.size(); i++) {
	list.get(i).intValue();
}
```

<br><br>

## Collections

**Array말고 List쪽의 메소드라 볼 수 있다.**

```java
int[] arr = { 123, 789, 456 }; // array
List<Integer> list = new ArrayList<>(Arrays.asList(arr)); // array to list(arraylist)

Collections.max(list)
Collections.min(list)
Collections.sort(list) // asc
Collections.sort(list, Collections.reverseOrder()) // desc
Collections.reverse(list) // { 456, 789, 123 }

Collections.frequency(list, 123) // 123 요소 개수 반환
Collections.binarySearch(list, 123) // 이분검색(못찾을때 좀 특이)
// 없으면 123보다 큰 최초의 위치를 찾아서 -1을 곱하고 1을 빼서 반환 (-4)
```

<br><br>

## 자를 때(분할할 때)

**특정 정수를 자를 때**

```java
// remain에 자른 정수를 담음
while(value != 0) { // ex : 123 -> 12 -> 1 -> 0
    remain = value % 10; // 123%10=3 -> 12%10=2 -> 1%10 = 1
    value /= 10; // 123/10=12 -> 12/10=1 -> 1/10=0
}
```

<br>

**스트링처럼 split이나 substring을 배열에서 하려면?**

```java
str.substring(3,5); String[] arr = str.split(""); // String의 경우
Arrays.copyOfRange(원본배열, 시작, 끝); // 배열의 경우
```

<br><br>

## BFS, DFS

**BFS(넢이우선검색), DFS(깊이우선검색)은 정말 단골 문제들이다.** 

* **BFS를 우선**으로 사용하며, DFS는 DFS로만 풀리는 문제에 사용하면 된다.
* **BFS는 큐** 를 활용하고, **DFS는 스택 또는 재귀(필자는 주로 재귀)**를 활용한다.
* **주의할점은 BFS는 방문기록을 큐에 집어넣는 시점에 남겨야 한다.**

<br>

**BFS 기본형태 4방향**

```java
// BOJ 1926번 : 그림
// 입력이 좌상을 0,0 으로 좌표계 형성하게끔 들어왔다 가정
public class test { 
    static int[] dx = {0,1,0,-1}; // 행 : 우,하,좌,상
    static int[] dy = {1,0,-1,0}; // 열 : 우,하,좌,상
    static boolean[][] visited = new boolean[505][505];
    static int N;
    static int M;
    static int[][] inArr = new int[505][505];
    static int resultTemp;

    public static void bfs(int x, int y) {
        Queue<Pair> qu = new LinkedList<>(); // LinkedList 로 선언해야함
        visited[x][y] = true; // 방문 표시
        qu.add(new Pair(x,y)); // push

        while(!qu.isEmpty()) {
            int cx = qu.peek().first; // front
            int cy = qu.peek().second;
            resultTemp++;
            qu.remove(); // pop

            for (int i=0; i<4; i++){
                int nx = cx + dx[i];
                int ny = cy + dy[i];
                if(nx<0 || ny<0 || nx>N-1 || ny>M-1) continue; // 범위 내 체크
                if(visited[nx][ny]) continue; // 방문 여부 체크
                if(inArr[nx][ny] == 1) {
                    // 땅이 있는 경우(=1) 큐에 추가
                    visited[nx][ny] = true; // 방문 표시
                    qu.add(new Pair(nx,ny));
                }
            }
        }
    }

    public static void main(String[] args) throws IOException {
        // input
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer stk = new StringTokenizer(br.readLine(), " ");
        N = Integer.parseInt(stk.nextToken());
        M = Integer.parseInt(stk.nextToken());
        for (int i = 0 ; i< N ; i++){
            stk = new StringTokenizer(br.readLine(), " ");
            for(int j = 0 ; j< M; j++){
                inArr[i][j] = Integer.parseInt(stk.nextToken());
            }
        }
        // run
        int resultMax = 0;
        int resultCount = 0;
        for(int i = 0; i<N;i++){
            for(int j = 0 ; j<M;j++){
                if(visited[i][j] || inArr[i][j] == 0) continue;
                resultTemp = 0; // 넓이 변수
                bfs(i, j); // 0,0 시작
                resultMax = Math.max(resultMax, resultTemp);
                resultCount++;
            }
        }
        System.out.println(resultCount);
        System.out.println(resultMax);
    }

    static class Pair {
        int first;
        int second;

        public Pair(int first, int second) {
            this.first = first;
            this.second = second;
        }
    }
}
```

<br>

**BFS 시작점이 여러 개**

* BFS를 **동시에** 동작하듯이 해야하는 경우에 해당된다.
* 같이 시작할 시작점들을 while문 돌리기전 큐에 전부 삽입후 평소처럼 BFS를 진행한다.
* **큐의 특성상 들어온 순서대로 진행할거기 때문에 가능한 것이다.**

<br>

**BFS 거리측정 + 시작점이 두 종류**

* `BOJ 4179번 : 불!` 문제를 예시로 들겠다.
  * 위처럼 시작점 여러개를 적용을 하는 부분이 초기에 진행된다.
  * 그리고 두 종류로 BFS를 따로 동작하는 형식이다.

```java
public class Main {
    static int R, C; // Row, Column
    static char[][] inArr = new char[1005][1005];
    static int[][] dist1 = new int[1005][1005]; // J
    static int[][] dist2 = new int[1005][1005]; // F
    static int[] dx = {0,1, 0, -1};
    static int[] dy = {1,0, -1, 0};

    public static void bfs() {
        // init dist1, dist2
        for(int i=0;i<1005;i++){
            Arrays.fill(dist1[i], -1);
            Arrays.fill(dist2[i], -1);
        }
        // J(지훈), F(불) 위치 찾아서 각각 큐에 push
        Queue<Pair> qu1 = new LinkedList<>(); // LinkedList 로 선언해야함(J)
        Queue<Pair> qu2 = new LinkedList<>(); // LinkedList 로 선언해야함(F)
        for(int i = 0; i<R;i++){
            for(int j = 0 ;j<C;j++){
                if(inArr[i][j] == 'J') {
                    dist1[i][j] = 0; // 지훈이 거리 기록(분)
                    qu1.add(new Pair(i,j));
                }
                if(inArr[i][j] == 'F') {
                    dist2[i][j] = 0; // 불 거리 기록(분)
                    qu2.add(new Pair(i,j));
                }
            }
        }
        // F(불) BFS
        while(!qu2.isEmpty()) {
            int cx = qu2.peek().first;
            int cy = qu2.peek().second;
            qu2.remove();

            for(int i = 0 ; i<4;i++){
                int nx = cx+dx[i];
                int ny = cy+dy[i];
                if (nx<0 || ny<0 || nx> R - 1 || ny > C - 1) continue; // 범위 내 체크
                if (inArr[nx][ny] == '#') continue; // 벽 체크
                if (dist2[nx][ny] == -1) {
                    dist2[nx][ny] = dist2[cx][cy] + 1; // 거리(분) 기록
                    qu2.add(new Pair(nx, ny));
                }
            }
        }
        // J(지훈) BFS
        // 불이 언제 어디서 퍼지는지 다 알고난 후 J(지훈)를 BFS 한다.
        // J가 범위를 벗어난 경우 탈출 성공이라 했으므로, 
        // 이때 불이 퍼지기 전에 탈출인지만 추가로 체크하면 된다.
        while(!qu1.isEmpty()){
            int cx = qu1.peek().first;
            int cy = qu1.peek().second;
            qu1.remove();

            for(int i = 0 ; i<4;i++){
                int nx = cx + dx[i];
                int ny = cy + dy[i];
                // 범위 내 체크
                if (nx<0 || ny<0 || nx>R-1 || ny>C-1){
                    // 이곳은 범위 밖(즉, 탈출)
                    // 따라서 이때 불 보다 먼저인지 체크(dist1[cx][cy] < dist2[cx][cy])
                    // dist2[cx][cy] == -1 의 의미는 F(불)이 사방에 갇혀서 못나온 경우다.
                    if (dist1[cx][cy] < dist2[cx][cy] || dist2[cx][cy] == -1) {
                        System.out.println(dist1[cx][cy]+1);
                        return;
                    }
                    continue;
                }
                if (inArr[nx][ny] == '#') continue; // 벽 체크
                if (dist1[nx][ny] == -1) {
                    dist1[nx][ny] = dist1[cx][cy] + 1; // 거리(분) 기록
                    qu1.add(new Pair(nx,ny));
                }
            }
        }
        System.out.println("IMPOSSIBLE");
    }
    public static void main(String[] args) throws IOException {
        // input
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer stk = new StringTokenizer(br.readLine(), " ");
        R = Integer.parseInt(stk.nextToken());
        C = Integer.parseInt(stk.nextToken());
        for(int i = 0 ; i<R;i++){
            stk = new StringTokenizer(br.readLine(), "");
            String inStr = stk.nextToken(); // string
            for(int j = 0 ; j<C;j++){
                inArr[i][j] = inStr.charAt(j); // char
            }
        }
        // run & output
        bfs();
    }
    static class Pair {
        int first, second;
        public Pair(int first, int second) {
            this.first = first; this.second = second;
        }
    }
}
```

<br>

**1차원에서의 BFS (즉, 4방향이 아니라)**

* dx,dy 배열을 통해서 `for(int i=0; i<4; i++)`에서 `nx, ny` 를 구하는 것이, 
* 꼭 4방향이 아니라 필요에따라 `for (auto nx : inArr[cx])` 형태로 다른 요소들의 접근으로 바뀐다던지 이런식으로도 응용한다는 것이다.

<br>

**DFS : 큐->스택 변경시 동일하게 동작하며, 아래 그래프 쪽 파트에서 재귀 방식도 참고(백트래킹에서 많이 사용)**

<br><br>

## 재귀(Recursion)

**`절차지향적 사고 -> 귀납적 사고` 가 반드시 필요!!!**

**절차적으로 이해하지 마라!! 귀납적으로 그냥 이렇게 되겠구나라고 생각만 하라!! 도미노를 생각!!**

* **수학적 귀납법**
  * **1번 도미노가 쓰러진다.  
    k번 도미노가 쓰러지면 k+1번 도미노도 쓰러진다.**
    * 참(true) : **1번 도미노가 쓰러진다, k번 도미노가 쓰러지면(가정)**
    * 두 문장이 참이므로 **k+1번 도미노..** 또한 귀납적으로 참
  * **예시1) 아래 코드의 예시**
    * **func1(1)이 1을 출력한다.  
      func1(k)가 k,k-1,k-2...1을 출력하면 func1(k+1)은 k+1,k,k-1,k-2...1을 출력한다.**
  * **예시2) 하노이 탑 이동 순서(n개 원판을 기둥 1 -> 기둥 3 으로 이동)**
    * n-1개의 원판을 1->2 이동  
      n번 원판을 1->3 이동  
      n-1개의 원판을 2->3 이동  
      => 규칙이 큰 원판 위에 작은 원판을 두는것이기 때문에 반드시 n-1개 원판이 기둥 2에 있고,   
      n번 원판이 기둥 1-> 기둥 3 으로 이동하는 경우의 존재는 생각해보면 자명하다.
    * **원판이 1개일 때 원판을 내가 원하는 곳으로 옮길 수 있다.  
      원판이 k개일 때 옮길 수 있으면 원판이 k+1개일 때에도 옮길 수 있다.**
* **재귀 함수의 조건**
  * Base condition : 특정 입력에 대해서는 자기 자신을 호출하지 않고 종료되어야 함
  * 모든 입력은 Base condition으로 수렴
* **재귀에 대한 정보**
  * 함수의 인자로 어떤 것을 받고 어디까지 계산한 후 자기 자신에게 넘겨줄지 명확하게 정해야 함
    * 모든 재귀 함수는 for문으로 만들 수 있음
    * 재귀는 for문 보다 메모리/시간에서 손해를 봄(함수 호출량 때문)

  * 한 함수가 자기 자신을 여러 번 호출하게 되면 비효율적일 수 있음(계산 중복 때문)
    * 예 : 피보나치 수열 => 해결법(DP로 중복 계산 재사용을 통해서 해결)

  * 재귀함수가 자기 자신을 부를 때 스택 영역에 계속 누적이 됨
    * 100000 정도 호출했을 때 정상동작 하지 않으면 구글 검색을 통해 스택 메모리 제한을 해제할 것

<br>

**재귀로 로직 작성 순서**

​	**1. 함수의 정의**

​	**2. base condition**

​	**3. 재귀 식**

```java
static StringBuilder sb = new StringBuilder(); // 문자열 기록
public static void func(int n){
    if(n==0) return; // base condition
    sb.append(n+" ");
    func(n-1); // 재귀
} 
public static void main(String[] args) throws IOException {
    func(5);
    System.out.println(sb); // 출력
}
```

<br><br>

## 백트래킹(Backtracking)

**`상태 공간트리` 를 그려가면서 문제를 이해하고, 재귀 형태로 풀어나가면 된다.**

**`깊이우선검색(=DFS)`을 기반으로 검색을 진행하며, 각 마디가 유망하지 않으면 그 마디의 부모 마디로 돌아가서 다시 검색을 계속하는 방식이다.**

* **참고 : `백트래킹` 은 깊이우선검색(DFS)을 기반으로 하지만, `분기한정법` 은 여러 검색 방법들을 지원하는 차이가 있다.**

<br>

**N과 M(1) - 대표적인 템플릿**

```java
// BOJ 15649
// N과 M(1) : 1부터 N까지 자연수 중에서 `중복 없이(=visited 활용)` M개를 고른 수열
// 즉, (1 2) (1 3) 은 가능하지만 (1 1)은 불가
static int N, M;
static int[] outArr = new int[10];
static boolean[] visited = new boolean[10];
static StringBuilder sb = new StringBuilder();

public static void dfs(int depth) {
    // base condition
    if(depth == M) {
        for(int i = 0 ; i<M; i++){
            sb.append(outArr[i]+" ");
        }
        sb.append('\n');
        return;
    }
    
    for(int i = 1 ; i<=N; i++){
        if(visited[i]) continue;
        visited[i] = true;
        outArr[depth] = i;
        dfs(depth+1); // recursion
        visited[i] = false; // backtracking
    }
}
```

<br>

**N과 M 시리즈 - dfs 방식 백트래킹 사고력 확장**

```java
// 참고 : 1~N 순서대로 접근했기 때문에 수열을 구하면 사전순(오름차순)으로 출력
// 그러나, 랜덤 값이 들어온 경우에 사전순 출력을 위해선 수열 구하기전에 sort작업이 필요

// `i > preValue`로 구하는 값 오름차순 (즉, 현재값 > 이전값)
for (int i = 1; i <= N; i++) {
    if (!visited[i] && i > preValue) { // 만약 비내림차순은? `i>=preValue`
        visited[i] = true;
        outArr[depth] = i;
        dfs(depth + 1, i);
        visited[i] = false; // backtracking
    }
}

// 1부터 N까지 자연수 중에서 `중복 허용(=visited 활용X)` M개를 고른 수열
for (int i = 1; i <= N; i++) {
    if (!visited[i]) {
        //visited[i] = true;
        outArr[depth] = i;
        dfs(depth + 1);
        //visited[i] = false; // backtracking
    }
}

// 애초에 입력이 1 2 3 4 가 아닌 1 1 2 3 이런식으로 중복으로 들어올 경우 처리방법 소개
// `tempNum != inArr[i]` 이 핵심
int tempNum = 0; // 이전값 기록해둬서 중복 수열 생성되지 않도록 하기 위함
for (int i = 1; i <= N; i++) {
    if (!visited[i] && tempNum != inArr[i]) {
        tempNum = inArr[i];
        visited[i] = true;
        outArr[depth] = inArr[i];
        dfs(depth + 1, inArr[i]);
        visited[i] = false;
    }
}

// 마지막으로 시간초과를 해결하는 TIP => 아래 동작만 필요한 경우들에 사용!!
for (int i = index; i < chicken.size(); i++) { // 반드시 index부터 시작해야 시간초과 안전
    p = chicken[i];
    if (visited[p.first][p.second]) continue;
    visited[p.first][p.second] = true;
    outArr[depth] = i; // 선택된 치킨집 index 기록
    dfs(depth + 1, i); 
    visited[p.first][p.second] = false; // backtracking
}
```

<br>

**부분수열의 합 - 응용(사고력 확장)**

```java
// 이 문제도 위 코드와 같은 형태로 해결할 수 있지만, 좀 더 간단하게 해결할 수도 있다.
// 위 코드의 경우 하나의 형태로만 재귀를 한것이다.
// 하지만, 이 문제를 상태 트리 그려보면 값을 더한경우 안더한경우로 나눠 볼 수 있다.
// 즉, 2개 형태로 재귀를 할 수 있고 훨씬 코드도 간결해진다.
public static void func(int depth, int sum) {
	if (depth == N) { // base condition
		if (sum == S) result++;
		return;
	}
	func(depth + 1, sum); // 안더함
	func(depth + 1, sum + inArr[depth]); // 더함
}
```

<br><br>

## Branch-and-Bound(분기한정법)

**이건 이런게 있다란 개념만 이해해두자. [분기한정법-개념](https://bh946.github.io/algorithm/(%EA%B0%9C%EB%85%90)-Branch-and-Bound(%EB%B6%84%EA%B8%B0%ED%95%9C%EC%A0%95%EB%B2%95)/)**

* **분기한정법 : Backtracking +** **다른 탐색들(DFS,BFS,우선순위큐 등)**
  * **Bound** : 마디가 유망한지 여부를 결정하기 위해서 한계치(bound) 계산
  
  * **So far the best** : 현재까지 찾은 최적의 답
  
* **최적화 문제의 SST 비교**

  * 최적화 문제의 SST 비교 최소화 문제(예: TSP)
    * 트리 깊어질수록 BOUND값이 절대 작아질 수 없음(Low Bound를 구함)


  * 최적화 문제의 SST 비교 최대화 문제(예: 0-1냅색)
    * 트리 깊어질수록 BOUND값이 절대 커질 수 없음(Upper Bound를 구함)

<br><br>

## 시뮬레이션(구현)

**존나 풀어라... 단, 구현인 만큼 코드 작성 전 꼭 도식화를 진행**

* **존나 풀어라 : [구현(실버급 인기 순)](https://solved.ac/search?query=%23implementation+*s&sort=solved&direction=desc&page=1)**
* **자주 나오는 로직은 그냥 외우자**
  * 예로 2차원 배열 회전 로직은 `B[x][y]=A[N-1-y][x]`

```java
// 90도 회전 함수 => ccw(반시계)
public static void rotate() {
    // 1. tmp에 복제
	int[][] tmp = new int[12][12];
	for (int i = 0; i < N; i++) {
		for (int j = 0; j < M; j++) {
			tmp[i][j] = inArr[i][j];
		}
	}
	// 2. 배열요소 swap
	for (int i = 0; i < N; i++) { 
		for (int j = 0; j < M; j++) {
            // CW : B[x][y]=A[y][M-1-x]
            // CCW : B[x][y]=A[N-1-y][x]
			inArr[i][j] = tmp[N-1-j][i];
		}
	}
    // 3. 배열크기 swap
    swap(N,M);
}
예제 배열:
[1, 2, 3]
[4, 5, 6]
[7, 8, 9]
CW(시계) 회전 결과:
[7, 4, 1]
[8, 5, 2]
[9, 6, 3]
CCW(반시계) 회전 결과:
[3, 6, 9]
[2, 5, 8]
[1, 4, 7]
```

<br><br>

## 정렬(Sort)

**Arrays.sort(Quick), Collections.sort(Merge) 이용**

* **응용**을 예시 들면, 정렬 때 같은 수는 인접하는 성질을 이용해 **중복 원소 제거**도 가능
  * **정렬은 아니지만 숫자를 바로 index와 매칭해서 받는 로직도 잘 기억**

```java
// 1. Arrays.sort => primitive type 배열 지원 + String까지 지원
int[] num = {5,2,8};
Arrays.sort(num); // 오름차순
Integer[] num = {5,2,8}; // Collection 때문에 Integer로 선언
Arrays.sort(num, Collections.reverseOrder()); // 내림차순

// 2. Collections.sort => ArrayList, LinkedList와 같은 Collection 타입 지원
List<Integer> num = nuw ArrayList<Integer>();
num.add(5); nums.add(2); num.add(8);
Collections.sort(num); // 오름차순
Collections.sort(num, Collections.reverseOrder()); // 내림차순

// 3. sort 커스텀 => comp 수정 (Comparator 구현)
static int[] order = {3,1,5};
static Integer[] inArr = {1,2,0};
public static void main(String[] args) {
    ObjectSort ob = new ObjectSort();
    Arrays.sort(inArr, ob);

    System.out.println(Arrays.toString(inArr));
    // 출력 : [1, 0, 2]
}
static class ObjectSort implements Comparator <Integer> {
    @Override
    public int compare(Integer a, Integer b) { // a, b는 inArr값
        return order[a] - order[b]; // 비교를 order배열로 하게끔 커스텀
    } // a가 b의 앞에 와야할 때 양수, 그렇지 않을 때 음수, 동일할 때 0
}
```

<br><br>

## 다이나믹 프로그래밍(DP)

**DP란 여러 개의 하위 문제를 먼저 푼 후 그 결과를 쌓아올려 주어진 문제를 해결하는 알고리즘**

**참고로 DP는 정말 대표하는 문제들이 많고 유형들도 가지각색이라서 많은 경험이 필요**

<br>

**DP를 푸는 과정 - 테이블 잡고 식 찾는 연습이 매우매우 중요**

​	**1. 테이블 정의하기**

​	**2. 점화식 찾기**

​	**3. 초기값 정하기**

<br>

**EX) 1로 만들기 [BOJ : 1463번](https://www.acmicpc.net/problem/1463)**

* **테이블 정의하기**
  * D[i]는 i를 1로 만들기 위해 필요한 연산 사용 횟수의 최솟값
* **점화식 찾기**
  * D[12]는 ??   
    3로 나누면 (D[12] = D[4] + 1)  
    2로 나누면 (D[12] = D[6] + 1)  
    1을 빼면 (D[12] = D[11] + 1)  
    => D[12] = min(D[4]+1, D[6]+1, D[11]+1)
  * D[k] = ?   
    => D[k] = min(D[k/3]+1, D[k/2]+1, D[k-1]+1)
* **초기값 정의하기**
  * D[1] = 0

```java
// input
BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
StringTokenizer stk = new StringTokenizer(br.readLine());
N = Integer.parseInt(stk.nextToken());
// init - dp
d[1] = 0;
// run
for(int i = 2 ; i<=N; i++){
    d[i] = d[i-1]+1;
    if(i%2==0) d[i] = Math.min(d[i], d[i/2]+1);
    if(i%3==0) d[i] = Math.min(d[i], d[i/3]+1);
}
// output
System.out.println(d[N]);
```

<br><br>

## 그리디(Greedy)

**그리디란 지금 가장 최적인 답을 근시안적으로 택하는 알고리즘 = 관찰을 통해 탐색 범위를 줄이는 알고리즘**

**구현자체는 굉장히 간단해서 따로 정해진 코드 탬플릿은 X**

**단, 코테에서 추천 전략은 문제가 100% 그리디 풀이란게 확신하면 짜서 제출 및 틀리면 빠르게 손절  
100% 확신이 없으면, 일단 넘어가고 마지막에 남은 시간에 코딩 시작**

<br><br>

## 수학(Math)

**자세한 개념은 반드시 [알고리즘 기초1 - 수학](https://bh946.github.io/baekjoon/(%EB%B0%B1%EC%A4%80_%EA%B0%95%EC%9D%981)%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EA%B8%B0%EC%B4%881-%EC%88%98%ED%95%99(%EA%B0%9C%EB%85%90)/), [바킹독 - 수학](https://blog.encrypted.gg/983) 게시물을 함께 참고**

<br>

### 1. 소수

**개선시킨 소수판정과 소인수분해는 모두 O(√n)**

**1부터 n까지의 수 중에서 소수 목록을 구하는건 에라토스테네스의 체를 사용**

* **소수 판정법(소수 1개!!)  - O(√n)**
  * 합성수 N에서 1을 제외한 가장 작은 약수는 √N 이하이다.
    * `EX) N=18 : 2<=√18, N=25 : 5<=√25, N=21 : 3<=√21`

```java
// √N 이하까지만 확인해도 소수 판별이 가능하므로 복잡도 N -> √N 개선
public static boolean isPrime(int n) {
    if(n == 1) return false;
    for(int i = 2; i*i<=n; i++) { // √N 이하까지 돈다.
        if(n%i == 0) return false;
    }
    return true;
}
```

<br>

* **소수 목록(소수 여러개!!) - 에라토스테네스의 체**
  * 소수는 자신보다 작은 수들의 배수값과 동일한게 있으면 안되는 특징을 이용
  * 예로 2의 경우?? 
    * 처음 `prime[2]`는 소수로 그대로 있고, `prime[4, 6, 8...]` 배수들은 소수가 아닌것으로 걸러지는 형태이다.

```java
// 에라토스테네스의 체
// prime배열 의미 : false면 소수, true면 소수아님 => 초기값 false로 초기화(전역배열)
int p = 2;
while(p*p <= N) {
    if(prime[p] == false) {
        for(int i = p*p; i<=N; i+=p) { // i+=p 는 p의 배수들 걸러내려고
            prime[i] = true;
        }
    }
    p++;
}
```

<br>

* **소인수분해**
  * 소인수분해 : 자연수를 소인수(약수들 중 소수)들의 곱으로 표현하는 것
    * `EX) 60 = 2 x 2 x 3 x 5`
  * 방법1) N 이하의 모든 소수를 에라토스테네스의 체로 다 찾은 다음에 그 소수들로 N을 나누어보는 방법
  * **방법2) 하지만, 이보다 더 괜찮은 방법이 존재(루트N 복잡도)**
    * i를 2,3,4,5... 올라가면서 N을 나누어 떨어질때마다 소인수 목록에 기록하는 방법

```java
// 소인수분해
for(int i = 2; i*i<=N; i++) { // √N 이하까지 돈다.
    while(N%i == 0) { // while문 (약수는 나누어 떨어져야 함)
        System.out.println(i); // 구한 소인수
        N/=i; // n이 1이 될때까지 갱신
    }
}
if(N!=1) System.out.println(N); // 마지막에 n이 1이 안될경우도 있는데, 그땐 n으로 나누면 1이 됨
```

* **참고) 팩토리얼 수에서 특정 수의 개수 구할때 유용한 특징 존재** : 10!의 경우 5의 개수를 구하기 위해 5를 10으로 나누면, 1~10 곱한 값 사이의 5가 나온 개수가 출력된다.

<br>

### 2. 최대공약수, 최소공배수(GCD, LCM)

* **최대 공약수(GCD), 최소 공배수(LCM) - 유클리드 호제법**
  * `유클리드 호제법` : 2개의 자연수 a, b에 대해서 a를 b로 나눈 나머지를 r이라고 하면(단, a> b), a와 b의 최대 공약수는 b와 r의 최대 공약수와 같다.
    * (a, b) = (b, r)
    * EX) 10 20 : (10, 20) = (20, 10) = (10, 0) = 10

```java
// 최대공약수 -> (a, b) = (b, r)
// (1) 재귀 방식
public static int gcd(int a, int b) {
    if(b==0) return a;
    return gcd(b,a%b);
}
// (2) 반복문 방식 - 정수론의 정리 이용
// 정리 : 두 정수 a(≥0)와 b(>0) 가 있을 때, a = b∙q+r (0 ≤r<b) 이면  gcd(a,b) = gcd(b,r) 이다.
public static int gcd(int a, int b) {
    int r1 = a; int r2 = b; // init
    while(r2>0) {
        int q = r1/r2; // 몫
        int r = r1-r2*q; // 나머지 r = a-b*q
        r1 = r2; r2 = r;
    }
    return r1;
}

// 최소공배수 -> A X B = GCD(A,B) X LCM(A,B)
public static int lcm(int a, int b) {
    return a / gcd(a,b) * b; // overflow 방지 위해 나누기 먼저(곱셈이라 가능)
}
```

<br>

### 3. 연립합동방정식

**아래 그림에서 조건에 만족한 학생 수를 구하기 위해 0~29 학생 수 때의 상황을 테이블로 나타냈고,  
정답은 27명임을 알 수 있으며 이런 문제를 `연립합동방정식` 이다.**

![image-20230430191943232](/images/2023-01-03-(백준_필수3)알고리즘 템플릿 - cpp/image-20230430191943232.png)

<br>

**다만, 이렇게 0~29 명 때를 전부 찾아보는게 아닌 5개만 확인하면 되는 효율적인 방법을 소개한다.**

* `N%6==3` 인 수들이 필요하고, 이는 처음 3부터 시작해서 +6인 `3,9,15,21,27`이다.
* 이 5개의 수들 중에서 `N%5==2` 를 찾기만 하면 된다.

![image-20230430192200486](/images/2023-01-03-(백준_필수3)알고리즘 템플릿 - cpp/image-20230430192200486.png) 

```c++
public static int chk() {
    for(int i = 3; i<30; i+=6) { // N%6==3 인 경우들만 접근
        if(i % 5 == 2) return i;
    }
    return -1;
}
```

<br>

### 4. 이항계수(조합)

**방법1) 조합의 공식 : `nCr = n!/[(n-r)!r!]` 을 이용하는 방법**

**방법2) 조합 성질 : `nCk = (n-1)C(k-1) + (n-1)Ck` 를 이용해서 DP로 구하는 방법(추천!!)**

* 점화식 : `d[i][j] = d[i-1][j-1] + d[i-1][j]`

<br>

### 5. A진법 to B진법의 변환(관계)

**필자는 이것을 `A진법 -> 10진법 -> B진법` 의 변화로 해결하고 있다.**

**[백준11576 풀이 게시글](https://bh946.github.io/baekjoontest/(C++)Base-Conversion-%EB%B0%B1%EC%A4%8011576/) 참고!!**

* `A진법 -> 10진법`
  * 예로 2진법이라면??
    * 먼저, 10진수 값이 `10` 이였다면 이를 2진법으로 표현 했을때는 `1010`이다.
      * `1010` 의 일의 자리 수를 10진수로 표현하면 `0*2^0 = 0` 이다.
      * `1010` 의 십의 자리 수를 10진수로 표현하면 `1*2^1 = 2` 이다.
      * `1010` 의 백의 자리 수를 10진수로 표현하면 `0*2^2 = 0` 이다.
      * `1010` 의 천의 자리 수를 10진수로 표현하면 `1*2^3 = 8` 이다.
    * 마지막으로 `1010` 을 10진수로 표현한다면??
      * `0*2^0 + 1*2^1 + 0*2^2 + 1*2^3 = 0 + 2 + 0 + 8 = 10`
* `10진법 -> B진법`
  * 10진수를 기수 B로 계속 나누어서 나머지 값을 거꾸로 출력하는 방식이다.
  * **그림으로 참고(추천 URL) : [10진수 A,B 진법 관계](https://piyoro.github.io/program/221770535071/)**

<br><br>

## 이분탐색

**정렬되어 있는 배열에서 특정 데이터를 찾기 위해 모든 데이터를 탐색 범위를 절반으로 줄여가며 찾는 탐색 방법**

*  **`Arrays.binarySearch(arr, target)` 함수를 활용** : 찾는 수가 등장했는지 안했는지를 이분탐색으로 알려줌(**오름차순에** 사용)
  * 물론, `sort` 처럼 범위 지정할 수 있다.
  * **단, `parametric search` 관련해서 구하려면 직접 `binarySearch` 를 작성 해줘야 한다.**

* 분할정복처럼 `st, en, mid` 인덱스 활용하며 `mid=(st+en)/2` 가 기본
  * 반드시 st,en을 1차이 나게끔 0,1로 가정하던지 해서 무한루프에 빠지는지 체크도 중요!!
    * **무한루프에 빠지게 되는경우 `mid=(left+right+1)/2` 사용을 권장**

<br>

**이분탐색 자료구조 `Arrays.binarySearch(arr, target)` 기본 사용법**

```java
int[] arr = {2, 5, 8, 12, 16, 23, 38, 56, 72, 91};
int target = 23;
System.out.println(Arrays.binarySearch(arr, target)); // 5 반환 (없으면 음수값 반환)

// EX : BOJ 1920
// input
// 생략...

// run & output
StringBuilder sb = new StringBuilder();
Arrays.sort(inArr1, 0, N); // ASC (범위지정)
for(int i = 0 ; i<M;i++){
    int findIndex = Arrays.binarySearch(inArr1, 0, N, inArr2[i]); // (범위지정)
    if(findIndex<0) sb.append(0).append('\n');
    else sb.append(1).append('\n');
}
System.out.println(sb);
```

<br>

**`binarySearch, lower_bound, upper_bound` 직접 구현 방식**

* 이분탐색으로 target의 왼쪽, 오른쪽 위치 구하는 함수 `lower_bound, upper_bound` 는 애초에 java에서 제공하지 않으므로 **직접 구현**해줘야 함
* **`upper_bound() - lower_bound()` 형태로 중복수의 개수를 구할 수 있다는점**
  * [바킹독님](https://blog.encrypted.gg/985) 의 그림부분을 참고

```java
// BOJ 10816
static int n=5;
static int[] a = {1,2,2,2,3};
public static int binarySearch(int target) {
    int st = 0;
    int en = n-1;
    while(st <= en) {
        int mid = (st+en)/2;
        if(a[mid] < target) st = mid+1;
        else if(a[mid] > target) en = mid-1;
        else return mid; // 찾은 경우
    }
    return -1; // st > en 의 경우 while문 탈출
}
public static int lower_bound(int target, int len) {
    int st = 0;
    int en = len;
    while(st < en) {
        int mid = (st+en)/2;
        if(a[mid] < target) st = mid+1;
        else en = mid; // (a[mid] >= target)
    }
    return st;
}
public static int upper_bound(int target, int len) {
    int st = 0;
    int en = len;
    while(st < en) {
        int mid = (st+en)/2;
        if(a[mid] <= target) st = mid+1;
        else en = mid; // (a[mid] > target)
    }
    return st;
}
```

<br>

### 1. 좌표압축

**나중에 문제를 풀다보면 입력값의 범위는 1에서 10^9 정도로 굉장히 큰데 그거를 배열 인덱스처럼 쓰고 싶을 수 있습니다.   
그러면 뭔가 크기 순으로 번호를 0번부터 매기고 싶다는 생각이 들텐데 이런 일을 하는게 좌표압축입니다.**

* **좌표압축 방법 : 정렬 -> 중복 제거 -> 이후 이분탐색 수행**
  * `List` 로 입출력 한 경우에는 `Set` 으로 **중복제거**하는게 매우 간편
  * 아래 예시 코드는 그냥 앞, 뒤 값 비교해서 **중복제거**

```java
//BOJ 18870
// 좌표압축 : 정렬 -> 중복제거 -> 이분탐색
Arrays.sort(inArr, 0, N); // 정렬
int index = 0;
for(int i = 0 ; i<N-1;i++){
    if(inArr[i] != inArr[i+1]) {
        inArr[index++] = inArr[i]; // 중복제거
    }
}
inArr[index] = inArr[N-1]; // 마지막 원소 넣기
for(int i = 0 ; i<N;i++){
    sb.append(lower_bound(outArr[i],index+1)); // 이분탐색
    sb.append(" ");
}
System.out.println(sb);
```

<br>

**좌표압축 또다른 예**

```java
// 문자 -> index로 변환 함수(좌표압축 함수)
public static int getID(char c) { 
	if (c <= 'Z')
		return c - 'A';
	return c - 'a' + 26; // 26은 A~Z 이후에 자리를 두기 위함
} // 아스키코드는 A가 a보다 작음
```

<br><br>

## 투 포인터

**투 포인터는 배열에서 원래 이중 for문으로 O(N^2)에 처리되는 작업을 2개 포인터의 움직임으로 O(N)에 해결하는 알고리즘**

* 이분 탐색으로 투 포인터 문제를 풀던가, 투 포인터 문제를 이분 탐색으로 풀 수 있는 경우가 많다.
* 예시로 **[수 고르기](https://www.acmicpc.net/problem/2230)** 를 풀어본다.
  * 아래 코드는 2개의 포인터를 적절히 조건에 맞게 움직여서 해를 구하는 모습이다.

```java
// BOJ 2230
Arrays.sort(inArr);
int result=2000000100;
int i = 0; int j = 1; // 투 포인터
for(i = 0; i<N; i++){
    while(j<N&&Math.abs(inArr[j]-inArr[i])<M) j++;
    if(j==N) break;
    result = Math.min(result, Math.abs(inArr[i]-inArr[j]));
}
```

<br><br>

## 해시

**해시 함수 : 임의 길이의 데이터를 고정될 길이의 데이터로 대응시키는 함수 (5135:Kim,...)**

**해시 테이블 : 아래 그림**

* 같은 키가 삽입될 수 있어서 충돌은 어쩔 수 없다.
* 대표적인 충돌회피 방법은 `Chaining, Open Addressing` 이 존재한다.
  * Chaining : 연결리스트로 회피
  * Open Addressing : Probing 방식으로 데이터 저장해서 회피
    * Linear Probing : 충돌 발생 시 오른쪽으로 1칸씩 이동
      * 단점 : Clustering(군집화) 발생
    * Quadratic Probing : 충돌 발생 시 오른쪽으로 1,3,5,... 칸씩 이동
      * 단점 : 약하긴 하지만 Clustering(군집화) 발생
    * Double Hashing : 충돌 발생 시 이동 칸의 수를 새로운 해시함수로 계산하는 방식
      * 단점 : 적중률이 낮아짐

![image-20230430212318397](/images/2023-01-03-(백준_필수3)알고리즘 템플릿 - cpp/image-20230430212318397.png)

<br>

**해시 테이블을 기반으로 이루어진 라이브러리**

* `HashSet, HashMap, LinkdedHashMap(참고)` 이 3개만 기억
  * Python 의 **set, dict** 자료구조랑 유사
    * **set** : value만 존재 => **중복 불가**에 주로 사용
      * 특히 순서를 지키지 않기 때문에 get하려면 처음부터 순회(iteration)를 통해서 구해야하므로 이런 경우 반드시 map을 사용 권장
    * **map** : key, value 쌍으로 존재 => **보통 이것**을 사용
      * 조회할 때 최적화 하려면 **entrySet** 을 활용
  * **LinkdedHashMap**는 순서를 지키고 싶을때 사용(물론 set도 존재)
* 이름이 비슷한 **BST 자료구조**인 `TreeSet, TreeMap` 과 구분할 것
  * BST는 정렬 순서를 유지하는 대신에 해시보다 느리므로, **"속도, 정렬" 2가지를 놓고 자료구조 선택**하면 된다.
    * `insert, erase, find update` 동작이 해시는 **O(1), RBT는 O(logN)**
    * 그러나, RBT는 원소가 크기 순으로 정렬되어 있다는 큰 장점이 있다. 
      * 즉, 정렬되어 있다 보니**lower_bound** 같은걸 **logN**에 바로 구할 수 있다.

```java
// 1. HashSet
HashSet<String> hs = new HashSet<>();
hs.add("java");
System.out.println(hs.contains("java")); // true

// 2. HashMap
HashMap<String, Integer> hm = new HashMap<>();
hm.put("java", 0); // save => 기존 값이 있어도 덮어씌움
hm.get("java"); // load
// 키(="java")가 없으면 put으로 새로 생성
if (!hm.containsKey("java")) hm.put("java", 1); 
// 키(="java")가 있으면 해당 값 출력, 없으면 설정한 defalut값(=3) 출력
hm.getOrDefault("java", 3);
// 키가 있으면 1씩 증가시키는 응용방식!
hm.put("java", hm.getOrDefault("java", 0)+1);
// keySet() 함수로 맵 순회
for(String key : hm.keySet()) { 
	hm.get(key); // 순서가 보장되지 않음
}
       
// 3. LinkdedHashMap => 값들 HashMap이라 동일하다 가정
for(String key : hm.keySet()) {				
	lhm.get(key); // 순서가 보장
}
```

<br>

**keySet, entrySet 를 적절히 사용해야 최적화 할 수 있다.**

* key만 순회할 때 keySet 은 적절하다. 단, value도 필요할 때는??
* value도 필요할 때는 entrySet 이 적절하다.
  * `hm.get(key)` 를 하는 순간 또 keySet을 찾는 과정을 반복하기 때문이다. (자세한 내용을 아래링크)
  * **참고 링크 : [entrySet 사용이유](https://codevang.tistory.com/289)**

```java
// 비권장
for (String key : hm.keySet()) { // keySet을 하고
    if (hm.get(key) != 0) { // hm.get(key)를 하는것은 비권장
        answer = key;
    }
}

// 권장
for (Entry<String, Integer> entry : hm.entrySet()) {
    if (entry.getValue() > 0) {
        answer = entry.getKey();
        break;
    }
}
```

<br><br>

## 이진 검색, 레드-블랙 트리(BST, RBT)

**자바의 `TreeSet, TreeMap` 은 이진 검색 트리 + 자가 균형을 이루는 RBT 자료 구조로 정의되어서 제공한다.**

**참고로 BST를 구현을 해야할 것 같을때는 배열로는 구현X, 차라리 class로 구현하자.**

**해시에서 비교를 했기 때문에 간단히 설명**

* TreeSet : 중복된 데이터의 저장을 허용하지 않으며, 정렬된 위치에 저장하므로 저장 순서를 유지하지도 않는다.
  * 여전히 get메소드 없고, iterator를 사용
* TreeMap : TreeSet과 동일한데 추가로 key, value 쌍으로 저장된다.

* prev, next나 lower_bound 이런게 필요할 때 유용
* 개념 정리 게시글 참고 : [고급트리 개념](https://bh946.github.io/algorithm/(%EA%B3%A0%EA%B8%89%EA%B0%9C%EB%85%90)-%EA%B3%A0%EA%B8%89-%ED%8A%B8%EB%A6%AC(BST,-RBT,-Splay,-OST,-Range,-Interval,-Sgement)/)

```java
// 1. TreeSet
TreeSet<Integer> ts = new TreeSet<>();
ts.add(2);
ts.add(4);
ts.add(3);
ts.add(5);
ts.add(1);
ts.add(1); // 중복 x
System.out.println(ts.contains(0));	// true
System.out.println(ts.size()); // 5
System.out.println(ts.headSet(3)); //처음 ~ 3 전까지
System.out.println(ts.tailSet(3)); //3 ~ 끝까지
System.out.println(ts.subSet(3, 5)); //3 ~ 5 전까지
Iterator<Integer> iter = ts.iterator();
while(iter.hasNext()) {
    System.out.print(iter.next());
}
System.out.println();

// 2. TreeMap
TreeMap<String, Integer> tm = new TreeMap<>();
tm.put("TreeMap1", 10);
tm.put("TreeMap2", 20);
tm.put("TreeMap3", 30);
System.out.println(tm.get("TreeMap3")); //30
System.out.println(tm.containsKey("TreeMap3"));	//true
System.out.println(tm.size()); // 3
System.out.println(tm.firstKey()); //처음 Key값
System.out.println(tm.lastKey());  //마지막 Key값
System.out.println(tm.firstEntry()); //처음 Entry값
System.out.println(tm.lastEntry()); //마지막 Entry값
System.out.println(tm.headMap("TreeMap2")); //처음 ~ TreeMap2 전까지
System.out.println(tm.tailMap("TreeMap2")); //TreeMap2 ~ 끝까지
System.out.println(tm.subMap("TreeMap1", "TreeMap3")); //TreeMap1 ~ TreeMap2 까지
```

<br><br>

## 우선순위 큐

**우선순위 큐는 pop을 할 때 가장 먼저 들어온 원소가 나오는 대신 우선순위가 가장 높은 원소가 나오는 큐이다. **  
**힙은 완전 이진트리로 구성된 자료구조 이다.**

**힙(최대 힙, 최소 힙) 자료구조를 사용해서 만든 우선순위 큐**

* 원소 추가 - O(logN)
* 우선순위 높은 원소 확인 - O(1)
* 우선순위 높은 원소 제거 - O(logN)
* **배열 자료구조 + 우선순위 큐의 경우 => 순서대로 O(1), O(N), O(N)**
* `TreeSet` 도 최소값과 최대값을 빼고, 원소 추가하고 다 가능하고 복잡도도 심지어 동일하다.
  * 그래도 굳이 `priority_queue` 를 사용하는 이유는 같은 O(logN)이라고 해도 `TreeSet` 보다 빠르고, 공간도 적게 차지한다.
  * **따라서 `priority_queue` 의 기능만 딱 필요할 경우엔 `TreeSet`이 아닌 `priority_queue` 를 사용해주자!**

<br>

**힙을 배열로 나타낼 때**

* x번지의 왼쪽, 오른쪽 자식 : 2x, 2x+1
* x번지의 부모 : x/2

<br>

**최소 힙, 최대 힙 특징**

* 최소 힙 : 부모가 자식보다 작음
* 최대 힙 : 부모가 자식보다 큼

<br>

**`PriorityQueue` 제공!!**

```java
PriorityQueue<Integer> pq = new PriorityQueue<Integer>(); // 최소힙
PriorityQueue<Integer> pq = new PriorityQueue<Integer>(Collections.reverseOrder()); // 최대힙

pq.add(3);
pq.remove();
pq.peek(); // root
```

<br>

**우선순위 비교를 직접 커스텀 할 경우!!**

```java
public static void main(String[] args) throws IOException {
    PriorityQueue<Pair> pq=new PriorityQueue<>(Pair::compareTo);
    pq.add(new Pair(1,2));
    pq.add(new Pair(1,1));
    pq.add(new Pair(2,3));
    pq.add(new Pair(2,1));

    while(!pq.isEmpty()){
        Pair p=pq.peek(); // root
        System.out.println(p.first+" "+p.second);
        pq.remove();
    }
}

static class Pair {
    int first;
    int second;

    public Pair(int first, int second) {
        this.first = first;
        this.second = second;
    }

    // Pair 클래스 내에 비교 함수!!
    public int compareTo(Pair p) {
        if(this.second < p.second) {
            return -1; // 음수는 오름차순
        }
        else if(this.second == p.second) {
            if(this.first < p.first) {
                return -1;
            }
        }
        return 1;
    }
}
```

<br><br>

## 그래프

**그래프는 인접행렬과 인접리스트로 표현할 수 있다.**

* **보통 인접리스트 사용이 많고, E가 V^2보다 훨씬 작을 때(sparse=희소) 사용한다.**
* **`모든 간선 길이가 동일` 하면 "BFS"로 거리를 구할 수 있고, `길이가 다르다면` "플로이드, 다익스트라" 알고리즘을 활용해야 한다.**

<br>

### 1. 그래프의 BFS, DFS 순회

**이미 BFS, DFS는 정리했었고 여기선 추가 보충을 위해 `"인접리스트"` 형태로 접근하는 것과 `DFS 재귀` 방식을 소개한다.**

```java
// 연결 그래프 BFS 순회
// 만약, 노드들 중에 연결 그래프 아닌것도 순회하고 싶으면 그냥 모든 노드를 돌리면 됨
// 즉, 아래 코드를 전체 for문으로 감싸고, 1 대신 for문의 i로 변경
static List<Integer>[] inArr = new ArrayList[10];
static boolean[] visited = new boolean[10];
static void bfs() {
    for(int i = 0 ;i<10;i++){
        inArr[i] = new ArrayList<Integer>();
        inArr[i].add((i+1)%10);
    } // 임의로 "인접리스트" 형태로 값 삽입
	Queue<Integer> qu = new LinkedList<>();
    qu.add(0);
    visited[0] = true;
	while(!qu.isEmpty()) {
		int cur = qu.peek();
		qu.remove();
		System.out.println(cur);
		for (int nxt : inArr[cur]) {
			if (visited[nxt]) continue;
			qu.add(nxt);
			visited[nxt] = true;
		}
	}
}

// DFS 재귀 (비재귀는 위 BFS에서 큐->스택)
static List<Integer>[] inArr = new ArrayList[10];
static boolean[] visited = new boolean[10];
static void dfs(int cur) {
    visited[cur] = true;
    System.out.println(cur);
    for (int nxt : inArr[cur]) {
        if(visited[nxt]) continue;
        dfs(nxt);
    }
}

// 항상 작성하던 DFS 재귀 방식 (최대 depth(깊이)를 지정했었음)
// 장점 : 원하는 개수만큼 만 접근이 가능
static List<Integer>[] inArr = new ArrayList[10];
static void dfs(int depth, List<Integer> val) {
	if (depth == 4) { // base condition
		result = 1;
		return;
	}
	
	for (int nxt : val) {
		if (visited[nxt]) continue;
        visited[nxt] = true;
        outArr[depth] = nxt; // 출력할 값 기록
        dfs(depth + 1, inArr[nxt]);
        // visited[nxt] = false; // backtracking
	}
}
```

<br><br>

## 트리

**트리는 무방향이고 사이클이 없는 연결 그래프이다.**

* **트리의 순회방식 - BFS&DFS 순회, 이진 트리의 순회**
* **여러가지 트리 - Segment**
* 참고로 **BST, RBT**는 위에서 이미 정리 그리고 **우선순위 큐에 사용한 힙**도 이진트리임
  * **좀 더 다양한 트리(Splay, OST, Range, Interval)는  [고급트리 개념](https://bh946.github.io/algorithm/(%EA%B3%A0%EA%B8%89%EA%B0%9C%EB%85%90)-%EA%B3%A0%EA%B8%89-%ED%8A%B8%EB%A6%AC(BST,-RBT,-Splay,-OST,-Range,-Interval,-Sgement)/) 에서 참고** 

<br>

### 1. 트리의 BFS, DFS 순회

* 트리를 **BFS** 할 때 root부터 하므로 임의의 노드에서 그 노드의 부모는 이미 방문한거고, 자식들만 방문을 안한 상태인 것이다.
* 따라서 따로 **visited배열이 필요없이 p배열(부모)** 을 알고 있으면 된다.

```java
// DFS는 큐->스택 바꾸면 동일하게 동작
static List<Integer>[] inArr = new ArrayList[10];
static int[] p = new int[10]; // 부모 배열
static int[] depth = new int[10]; // 트리 깊이 기록
static void bfs(int root) {
	Queue<Integer> qu = new LinkedList<>();
    qu.add(root);
    while(!qu.isEmpty()) {
        int cur = qu.peek();
        qu.remove();
		System.out.println(cur);
        for (int nxt : inArr[cur]) {
            if(p[cur] == nxt) continue; // 부모는 방문한 상태라서 continue
            qu.add(nxt);
            p[nxt] = cur; // parent 기록
            depth[nxt] = depth[cur] + 1; // dist배열 채우듯이 동일
        }
    }
}
```

<br>

### 2. 이진 트리의 순회

* **레벨 순회(=bfs(root))** : 높이 순서대로 방문한다.
  * 기존이랑 **동일**. root를 시작점으로 **bfs** 돌리면 높이 순서대로 위에서부터 차례로 순회한다.
* **전위, 중위, 후위 순회**
  * 전위 : 위 -> 왼 -> 오
  * 중위 : 왼 -> 위 -> 오
  * 후위 : 왼 -> 오 -> 위
* **구현 쉬워서 코드 생략**

<br>

### 3. Segment Tree(구간합)

**여러개의 데이터가 연속으로 있을때 `배열` 에서는 그 구간의 합을 구할때 복잡도가 N이 걸리는데, 이걸 `세그먼트 트리` 를 이용해서 logN으로 개선시키려는 목적**

* 리프 노드: 배열의 연속된 값 그 자체
* 내부 노드: 왼쪽 자식과 오른쪽 자식의 합
* **아래 그림을 꼭 기억하면 충분히 segmentBuild 함수정도는 만들 수 있을 것이다.**
  * **재귀를 너무 이해하려고 하는것 보다 아래 상태공간 트리를 재귀함수로 짜려고 노력하는게 중요하다.**


![image-20230526215318317](/images/2023-01-11-(백준_필수3)알고리즘 템플릿 - java/image-20230526215318317.png)

<br>

```java
/**
 * BOJ 2042
 * 구간 합 구하는 함수 : segmentSum
 * 트리의 노드 수정하는 함수 : segmentUpdate
 * 세그먼트 트리 만드는 함수 : segmentBuild
 */
static int N, M, K;
static long[] inArr;
static long[] outArr;

// node(outArr)가 담당하는 구간 : start, end
public static long segmentBuild(int start, int end, int node) {
    if(start == end) { // base condition
        outArr[node] = inArr[start];
        return outArr[node];
    }

    int mid = (start+end) / 2; // 왼, 오 구간 나누기
    outArr[node] = segmentBuild(start, mid, node*2) + segmentBuild(mid+1, end, node*2+1);
    return outArr[node];
}

// 구하는 합 구간 : left, right
public static long segmentSum(int start, int end, int left, int right, int node) {
    // 1. 겹치지 않는 경우 => base condition
    if((left < start && right < start) || (left > end && right > end)) return 0;

    // 2. 완전히 포함되는 경우 => base condition
    if(left <= start && right >= end) return outArr[node];

    // 3. 나머지 경우(자식 트리 탐색) => 왼, 오 탐색
    int mid = (start+end) / 2;
    return segmentSum(start, mid, left, right, node*2) + segmentSum(mid+1, end, left, right, node*2+1);
}

// 수정할 노드 인덱스 : idx, 수정할 값 : dif
public static void segmentUpdate(int start, int end, int idx, long dif, int node) {
    // 1. 겹치치 않는 경우
    if((start < idx && end < idx) || (start > idx && end > idx)) return;
    // 2. 완전히 포함되는 경우
    if(start <= idx && end >= idx) outArr[node] += dif;

    // base condition (무한루프 안빠지게)
    if(start==end) return;
    // 3. 나머지 경우(자식 트리 탐색)
    int mid = (start+end) /2;
    segmentUpdate(start, mid, idx, dif, node*2);
    segmentUpdate(mid+1, end, idx, dif, node*2+1);
}

public static void main(String[] args) throws IOException {
    // input
    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
    StringTokenizer stk = new StringTokenizer(br.readLine(), " ");
    N = Integer.parseInt(stk.nextToken());
    M = Integer.parseInt(stk.nextToken());
    K = Integer.parseInt(stk.nextToken());
    inArr = new long[N];
    outArr = new long[N*4];
    for(int i = 0 ;i <N; i++){
        inArr[i] = Long.parseLong(br.readLine());
    }
    // run & output
    StringBuilder sb = new StringBuilder();
    segmentBuild(0, N-1, 1); // 인덱스 1부터 저장해야 인덱스 연산 편안
    for(int i = 0 ; i<M+K; i++){
        stk = new StringTokenizer(br.readLine(), " ");
        int a = Integer.parseInt(stk.nextToken());
        int b = Integer.parseInt(stk.nextToken());
        long c = Long.parseLong(stk.nextToken()); // type 조심

        if(a==1) {
            // segmentUpdate
            // b번째 수에 c를 더하는게 아닌,
            // b번째 수를 c로 바꿔야 하는건 `c-inArr[b-1]` 를 더해야 한다는 의미이다.
            segmentUpdate(0, N-1, b-1, c-inArr[b-1], 1);
            inArr[b-1] = c; // b번째 수를 값 c로 변환
        } else{ // a==2
            // segmentSum
            sb.append(segmentSum(0, N-1, b-1, (int)c-1, 1)).append('\n');
        }
    }
    System.out.println(sb);
}
```

<br><br>

## 위상 정렬

**위상 정렬(Topological Sort) : 방향 그래프에서 간선으로 주어진 정점 간 선후관계를 위배하지 않도록 나열하는 정렬**

* 단순히 부모 자식관계를 위배하지만 않으면 되므로 생각보다 간단한 정렬이다.
* indegree가 0인게 제일 부모이며 최외각에 존재하는건 자명하다.

![image-20230506001732475](/images/2023-01-03-(백준_필수3)알고리즘 템플릿 - cpp/image-20230506001732475.png)

```java
// BOJ 2252

public static int N, M;
public static List<Integer>[] inArr; // input (graph)
public static List<Integer> outArr = new ArrayList<>(); // output
public static int[] deg = new int[32005]; // 0 init

public static void main(String[] args) throws IOException {
    // input
    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
    StringTokenizer stk = new StringTokenizer(br.readLine(), " ");
    N = Integer.parseInt(stk.nextToken());
    M = Integer.parseInt(stk.nextToken());
    inArr = new ArrayList[N+5];
    for(int i = 1 ; i<=N;i++) inArr[i] = new ArrayList<>(); // init
    for(int i = 0 ;i<M;i++){
        stk = new StringTokenizer(br.readLine(), " ");
        int a = Integer.parseInt(stk.nextToken());
        int b = Integer.parseInt(stk.nextToken());
        inArr[a].add(b); // graph (방향 그래프)
        deg[b] += 1; // indegree
    }

    // run
    Queue<Integer> qu = new LinkedList<>();
    for(int i = 1; i<=N; i++)
        if(deg[i]==0) qu.add(i); // indegree 0 이 젤 최외각
    while(!qu.isEmpty()) {
        int cur = qu.peek();
        qu.remove();
        outArr.add(cur);
        for(int nxt : inArr[cur]) {
            deg[nxt]--;
            if(deg[nxt] == 0) qu.add(nxt);
        }
    }

    // output
    StringBuilder sb = new StringBuilder();
    for(int num : outArr) sb.append(num).append(' ');
    System.out.println(sb);

    if(outArr.size() != N)
        System.out.println("cycle exists");
}
```

<br><br>

## 최소 신장 트리(MST)

* **바킹독 : https://blog.encrypted.gg/1024**
* **예전에 정리한 개념글 : [MST-Prim,Kruskal](https://bh946.github.io/algorithm/(%EA%B0%9C%EB%85%90)-Greedy-Algorithm(%ED%83%90%EC%9A%95%EC%A0%81%EC%9D%B8-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98)/#mst%EC%B5%9C%EC%86%8C%EB%B9%84%EC%9A%A9-%EC%8B%A0%EC%9E%A5%ED%8A%B8%EB%A6%AC)**

<br>

**크루스칼, 프림 알고리즘이 대표적**

**크루스칼 알고리즘은 Union Find라는 알고리즘을 선행학습 하고 아래 코드를 이해할 것.**

![image-20230506012547858](/images/2023-01-03-(백준_필수3)알고리즘 템플릿 - cpp/image-20230506012547858.png)

<br>

```java
// BOJ 1197
/**
MST - kruskal
1. 비내림차순 정렬(가중치 기준) => 제일 작은 가중치부터 선택하려고 하는것
2. Union Find(=합집합 찾기) 이용 : 같은 그래프에 속하는지를 판별하기 위함
*/
public static int[] p = new int[10005]; // 부모기록 배열(-1 init)
static int find(int x) {
    if(p[x] < 0) return x; // 부모가 없는경우 자신이 부모
    return p[x] = find(p[x]); // 부모 찾을때 까지 재귀
}
static boolean isUnion(int u, int v) {
    u = find(u); v = find(v); // u,v 노드의 root(각 집합에서의 root를 찾는것)
    if(u==v) return true;
    if(p[u] > p[v]) {
        int temp = u;
        u=v; v=temp;
    } // swap(u,v)
    p[u] += p[v]; // 자식이 많은쪽에 merge => 여기선 p[u]로
    p[v] = u; // 부모 기록
    return false;
}

public static void main(String[] args) throws IOException {
    // input
    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
    StringTokenizer stk = new StringTokenizer(br.readLine(), " ");
    int V = Integer.parseInt(stk.nextToken());
    int E = Integer.parseInt(stk.nextToken());
    List<Edge> inArr = new ArrayList<>(E); // 또는 그냥 배열로 고고
    for(int i = 0;i<E;i++){
        stk = new StringTokenizer(br.readLine(), " ");
        int a = Integer.parseInt(stk.nextToken());
        int b = Integer.parseInt(stk.nextToken());
        int c = Integer.parseInt(stk.nextToken()); // 가중치
        inArr.add(new Edge(a,b,c));
    }

    // run
    // 1. 비내림차순 정렬(가중치 기준)
    ObjectSort ob = new ObjectSort();
    Collections.sort(inArr, ob);

    // 2. Union Find(=합집합 찾기) 이용 : 같은 그래프에 속하는지를 판별하는 알고리즘
    Arrays.fill(p, -1); // init
    int result = 0;
    int cnt = 0;
    for(Edge edge : inArr){
        if(isUnion(edge.a, edge.b)) continue;
        result += edge.c;
        cnt++;
        if(cnt == V-1) break; // 종료 시점 (모든 노드 방문한 경우)
    }

    // output
    System.out.println(result);
}
static class Edge {
    int a;
    int b;
    int c;
    public Edge(int a, int b, int c) {
        this.a = a;
        this.b = b;
        this.c = c;
    }
}
static class ObjectSort implements Comparator<Edge> {
    @Override
    public int compare(Edge o1, Edge o2) {
        return o1.c - o2.c; // 오름차순
    }
}
```

<br>

**프림 알고리즘은 우선순위 큐를 이용해서 구현을 하는데, 구현이 좀 복잡하다. 따라서 pass**

<br><br>











## 최단 경로 트리

* **바킹독 : https://blog.encrypted.gg/1035, https://blog.encrypted.gg/1037**
* **예전에 정리한 개념글 : [Floyd](https://bh946.github.io/algorithm/(%EA%B0%9C%EB%85%90)-Dynamic_Programming(%EB%8F%99%EC%A0%81%EA%B3%84%ED%9A%8D%EB%B2%95)/#%EC%B5%9C%EB%8B%A8%EA%B1%B0%EB%A6%ACfloyd), [Dijkstra](https://bh946.github.io/algorithm/(%EA%B0%9C%EB%85%90)-Greedy-Algorithm(%ED%83%90%EC%9A%95%EC%A0%81%EC%9D%B8-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98)/#dijkstra%EB%8B%A4%EC%9D%B5%EC%8A%A4%ED%8A%B8%EB%9D%BC)**
* **유형**
  * 거리가 일정??? `BFS` 로 최단 거리 구하기
  * 거리가 다르다??? `플로이드(n^3) or 다익스트라(n^2)` 로 구하기


<br>

**`플로이드 알고리즘`은 모든 정점 쌍 사이의 최단 경로를 구하는 알고리즘이라 O(n<sup>3</sup>)의 큰 복잡도를 가진다.  
다만, 구현이 3중 for문으로 간단히 할 수 있으며 n이 1000정도면 이 알고리즘을 써도 된다.**

* 최단 거리 테이블(2차원) 이 채워진다 => 코드보면 d배열 관련인데 생각보다 쉬운 로직!
* 근데, 경로까지 구하고싶으면 테이블 하나 더 만들어서 기록해놔야 한다 => nxt배열에 기록

![image-20230506013350391](/images/2023-01-03-(백준_필수3)알고리즘 템플릿 - cpp/image-20230506013350391.png)

![image-20230506013359812](/images/2023-01-03-(백준_필수3)알고리즘 템플릿 - cpp/image-20230506013359812.png)

<br>

```java
// BOJ 11780
// n이 100이라 플로이드 가능
public static int[][] d = new int[105][105];
public static int[][] p = new int[105][105];
public static int n, m;

public static void main(String[] args) throws IOException {
    // input => 1 4 2, 1 4 1 처럼 들어올 수 도 있으니 처음부터 d 에 min 값으로 갱신하자.
    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
    StringTokenizer stk = new StringTokenizer(br.readLine());
    n = Integer.parseInt(stk.nextToken());
    stk = new StringTokenizer(br.readLine());
    m = Integer.parseInt(stk.nextToken());
    for(int i = 1 ; i<=n ;i++) {
        Arrays.fill(d[i], 10000000);
    }
    for(int i = 1; i<=m; i++){
        stk = new StringTokenizer(br.readLine(), " ");
        int a = Integer.parseInt(stk.nextToken());
        int b = Integer.parseInt(stk.nextToken());
        int c = Integer.parseInt(stk.nextToken());
        d[a][b] = Math.min(d[a][b], c);
        p[a][b] = b; // 경유 경로 기록
    }
    for(int i = 1; i<=n;i++) d[i][i] = 0; // 자기 자신의 경로는 당연히 비용 0

    // run => DP 방식(i,j,k만 잘이해하면 생각보다 간단)
    for(int k = 1; k<=n; k++) { // k를 경유하는 곳이라 생각하면 됨.
        for(int i = 1; i<=n; i++) { // i->j 를 가는 경로 비용을 구하는것
            for(int j = 1; j<=n; j++) {
                if(d[i][k]+d[k][j] < d[i][j]){
                    d[i][j] = Math.min(d[i][j], d[i][k]+d[k][j]);
                    p[i][j] = p[i][k]; // 경유 경로 기록
                }
            }
        }
    }

    // output => 출력이 여러개 있음.
    StringBuilder sb = new StringBuilder(); // 가중치 출력
    for(int i = 1 ; i<=n;i++){
        for(int j = 1; j<=n; j++){
            if(d[i][j] == 10000000) sb.append(0).append(' ');
            else sb.append(d[i][j]).append(' ');
        }
        sb.append('\n');
    }
    System.out.print(sb);

    for(int i = 1; i<=n; i++) {
        for(int j = 1; j<=n; j++) {
            sb = new StringBuilder(); // 경로 출력
            if(d[i][j] == 0 || d[i][j] == 10000000) {
                System.out.println(0);
                continue;
            }
            int st = i;
            int sizes = 1;
            while(st != j) { // 자기 자신 가리키는 순간 탈출
                sb.append(st).append(' ');
                st = p[st][j];
                sizes++;
            }
            sb.append(j);
            System.out.print(sizes);
            System.out.println(" "+sb);
        }
    }
}
```

<br>

**`다익스트라 알고리즘 `은 하나의 정점으로부터 다른 모든 정점까지의 최단 거리를 구하는 알고리즘이므로 복잡도는 플로이드보다 한단계 작은 O(n<sup>2</sup>) 이다.**

* 참고 : 가중치가 음의 값이 있으면 이 알고리즘 사용 불가
* 동작원리는 간단한데 한 정점에서 갈 수 있는 최단 거리 정점을 택하면서 갱신해나가면 된다.
* 여기서 개선된 알고리즘이 있는데 우선순위 큐를 활용한 알고리즘이다. 이 로직을 기억
  * 우선순위 큐에 거리를 다 넣어둔다음 매번 최소인걸 선택하는 로직
  * 물론 경로까지 구하는 방법은 플로이드 알고리즘 때와 유사

![image-20230506014449754](/images/2023-01-03-(백준_필수3)알고리즘 템플릿 - cpp/image-20230506014449754.png)

![image-20230506015237505](/images/2023-01-03-(백준_필수3)알고리즘 템플릿 - cpp/image-20230506015237505.png)

![image-20230506015246272](/images/2023-01-03-(백준_필수3)알고리즘 템플릿 - cpp/image-20230506015246272.png)

<br><br>

## 컴퓨터그래픽스 관련

**CCW, 교차여부, 다각형 면적, 다각형 포함, 볼록 껍질(외피=Convex Hull), 평면 소거법(직사각형 합집합=Plane Sweeping) 관련**

* 개념 정리 게시글 참고 : [컴퓨터그래픽스 개념](https://bh946.github.io/algorithm/(%EA%B3%A0%EA%B8%89%EA%B0%9C%EB%85%90)-%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B7%B8%EB%9E%98%ED%94%BD%EC%8A%A4(%EA%B8%B0%ED%95%98%EC%97%B0%EC%82%B0,-%EB%8B%A4%EA%B0%81%ED%98%95-%EB%A9%B4%EC%A0%81%EA%B3%BC-%ED%8F%AC%ED%95%A8,-Convex-Hull,-Plane-Sweeping)/)

<br>

### 1. 기본 기하 연산(between, intersect)

```c++
/*
ccw 함수(cw : counter clockwise = 시계방향)
leftTurn, rightTurn, collinear 함수 : 좌,우,일직선 검사
direction 함수 : 세점의 회전방향 검사에 따라서 1,-1,0 반환
between 함수 : 점 c가 선분 (a,b)에 위치하는가 검사
intersectProp 함수 : 교차여부를 구하는데, 선분의 끝점이 교차점 허용하지 않는 경우
intersect 함수 : 교차여부를 구하는데, 선분의 끝점이 교차점 허용하는 경우

이 중에서 between, intersect 가 중요

자료형 왠만하면 long long 쓰자
*/

#include<iostream>
using namespace std;

struct point {
	long long x;
	long long y;
};
typedef point Point;

// OP벡터, OQ벡터 (O는 원점)
// det(행렬식) => q가 p에 어느 방향인지 출력
long long ccw2(Point p, Point q) {
	return p.x * q.y - p.y * q.x;
}

// RP벡터, RQ벡터 => 시점R을 원점으로 만들어서 계산
// 시점을 원점으로 이동 : p-r, q-r
int ccw(Point r, Point p, Point q) {
	p.x -= r.x;
	p.y -= r.y;
	q.x -= r.x;
	q.y -= r.y;
	return ccw2(p, q);
}

// 세점 a,b,c의 회전방향이 좌,우,일직선인가 검사
bool leftTurn(Point a, Point b, Point c) {
	return ccw(a, b, c) > 0; // 좌회전 검사
}
bool rightTurn(Point a, Point b, Point c) {
	return ccw(a, b, c) < 0; // 우회전 검사
}
bool collinear(Point a, Point b, Point c) {
	return ccw(a, b, c) == 0; // 일직선 검사
}

// 선분 교차 검사를 위해 회전 방향에 따른 값 출력
// 좌 : 1, 우 : -1, 일 : 0
int direction(Point a, Point b, Point c) {
	if (leftTurn(a,b,c)) return 1;
	if (rightTurn(a,b,c)) return -1;
	if (collinear(a,b,c)) return 0;
}

// 점 c가 선분 (a,b)에 위치하는가
bool between(Point a, Point b, Point c) {
	if (!collinear(a, b, c)) return false; // 일직선 상에 없으면 false
	// 아래부턴 일직선 상에 있으니까 범위제한만 주면 된다.
	if (a.x != b.x) { // 수직선 아니면
		
		return (a.x <= c.x && c.x <= b.x) || (b.x <= c.x && c.x <= a.x);
	}
	else { // 수직선 이면
		return (a.y <= c.y && c.y <= b.y) || (b.y <= c.y && c.y <= a.y);
	}
}

// 선분 교차 검사 (교차점 허용) => 선분 ab, cd
int intersect(Point a, Point b, Point c, Point d) {
	// (a,b,c)*(a,b,d) ==-1 && (c,d,a)*(c,d,b)==-1 성립하면 교차
	// 추가조건 때문에 <=0로 판별
	if (direction(a, b, c) * direction(a, b, d) <= 0 && direction(c, d, a) * direction(c, d, b) <= 0) {
		// direction함수는 방향만을 나타내기 때문에 만약 0인 경우 일직선상인 건데,
		// 두 직선이 서로 접하는지 범위제한을 줘서 판단할 필요가 있음(between 함수 활용)
		if (direction(a, b, c) * direction(a, b, d) == 0 && direction(c, d, a) * direction(c, d, b) == 0) {
			// 점 c또는 d가 a,b직선 상에 존재하나 판단
			// 점 a또는 b가 c,d직선 상에 존재하나 판단
			if (between(a, b, c) || between(a, b, d)|| between(c, d, a) || between(c, d, b)) {
				return 1;
			}
			else
				return 0;
		}
		return 1;
	}
	else
		return 0;
}

// 선분 교차 검사 (교차점 제외) => 선분 ab, cd
bool intersectProp(Point a, Point b, Point c, Point d) {
	return direction(a, b, c) * direction(a, b, d) < 0 && direction(c, d, a) * direction(c, d, b) < 0;
}
```

<br>

### 2. 다각형 면적과 포함 계산

```c++
/*
area 함수 : 다각형 면적 구하기
insidePolygon 함수 : 다각형 포함 구하기
*/

// 다각형 면적 구하기 (외전 전부 더하면 됨)
double area(vector<Point> p) {
	int ret = 0;
	int n = p.size(); // 다각형 p의 정점 개수
	for (int i = 0; i < n; i++) {
		int j = (i + 1) % n; // 마지막에 index n->0으로 바뀜
		ret += (p[i].x * p[j].y - p[i].y * p[j].x);
	}
	return abs(ret) / 2.0;
}

// 다각형 포함 문제 (교차점 홀수면 내부 포함 인정)
bool insidePolygon(Point q, vector<Point> P) {
	int n = P.size();
	int crossings = 0;
	for (int i = 0; i < n; i++) {
		int iPlus1 = (i + 1) % n; // 마지막에 index n->0으로 바뀜
		// 1. 점 q가 다각형 에지(표면)에 있나 먼저 확인
		if (between(P[i], P[iPlus1], q)) return false;
		// 2. 교차점 판별 => crossings에 +1
		if((P[i].y<q.y&&P[iPlus1].y>=q.y&&leftTurn(P[i],P[iPlus1],q)) ||
			(P[iPlus1].y<q.y&&P[i].y>=q.y&&leftTurn(P[iPlus1],P[i],q)))
			crossings++;
	}
	if (crossings % 2 != 0) return true; // 홀수라면 true !!
	return false;
}
```

<br>

### 3. 볼록 외피(Convex Hull)

**O(NlogN ) 방법 소개 - 참고 사이트 : https://www.crocus.co.kr/1288**

```c++
/*
1. 우선 기준점을 잡는다. (보통 기준점은 y좌표가 가장 작은 것을 기준으로 한다.)
=> y좌표, x좌표 기준 오름차순 정렬해서 기준점을 P[0]으로 바로 잡자

2. 그리고 이 기준점으로 하여 다른 점들을 반시계 방향으로 정렬한다.
=> 각도에 따라 정렬 핵심 (참고 : 원점 이동한 상대위치로 각도 구함)

3. 컨벡스 헐 알고리즘(그라함 스캔(Graham's Scan) 알고리즘)을 이용한다.
=> 사이트 그림보면 이해하기 쉬움
*/

#include<iostream>
#include<algorithm>
#include<cmath> // atan2 (아크탄젠트 - 두점사이 절대각도 구함)
#include<stack>
using namespace std;

struct point {
	int x, y;
	int p, q;
};
typedef point Point;

double getAngle(Point p) {
    return atan2(p.q, p.p);
}

// 1. 각도 비교 사용시 각도 비교를 우선으로 정렬
// 2. 각도 비교 사용 안할시 y기준 정렬, x기준 정렬
bool comp(Point a, Point b) {
    // p, q 사용시 아래 조건문 만족하게 됨
    // p, q 사용안하면 0으로 초기화 되어있어서 아래 조건문 불만족
    if (getAngle(a) != getAngle(b)) return getAngle(a) < getAngle(b);
    
    if (a.y != b.y) return a.y < b.y;
    return a.x < b.x;
}

Point P[100];

int main() {
    int n; // 점 개수
    cin >> n;

    for (int i = 0; i < n; i++) {
        int x, y;
        cin >> x >> y;
        P[i] = { x,y };
    }

    // y좌표, x좌표 기준 오름차순 정렬
    sort(P, P + n, comp);

    // 기준점(=P[0])기준 상대위치 기록 (따라서 i=1부터)
    for (int i = 1; i < n; i++) {
        P[i].p = P[i].x - P[0].x; // 기준점 빼서 원점으로 이동
        P[i].q = P[i].y - P[0].y;
    }

    // 구했던 상대위치 값으로 반시계 방향 정렬(기준점 제외. 따라서 p+1부터)
    // => 기준점에서 각도 비교로 반시계 정렬하면 됨
    sort(P + 1, P + n, comp);

    // 1st, 2st로 바로 초기값 사용 가능
    stack<int> st;
    st.push(0); st.push(1); // 0, 1 index 푸시

    // 전처리 과정 끝
    // 알고리즘 시작
    int next = 2; // next는 index 2부터 판단 시작
    while (next < n) { // 0부터 시작했으므로 next가 최종 n까지 가면 1바퀴 다 돈것이다
        while (st.size() >= 2) {
            int first, second;
            second = st.top();
            st.pop();
            first = st.top();

            // first, second, next가 좌회전 ( > 0 )이라면 second push 하고 next 이동
            // 우회전( < 0 )이라면 위의 while문 계속 반복 (즉, 이전 first,second상태로 되돌아감)
            if (ccw(P[first], P[second], P[next]) > 0) { // leftTurn써도 됨
                st.push(second);
                break;
            }
        }

        // next push
        st.push(next++);
    }

    cout << st.size(); // 볼록외피 좌표 index들 담겨있음

    return 0;
}
```

<br>

### 4. 평면 소거법(Plane Sweeping) => 합집합

```c++
#include<iostream>
#include<vector>
using namespace std;

struct Rectangle {
	int x1, y1, x2, y2;
};

vector<Rectangle> inArr;
int Q[10]; // 직사각형 x좌표 정렬해서 기록
int S[10]; // 직사각형 y좌표 정렬해서 기록
int counts[10]; // 겹쳐진 사각형 수
int m1 = 8; // events - Q size
int m2 = 8; // S size

// 합집합의 면적 계산 (합집합이므로 중복 면접 제외)
int UnionArea() {
	int sweepLine = 0; int delta = 0; int area = 0; // 면적
	for (int i = 0; i < m1; i++) {
		sweepLine = Q[i];
		Rectangle R = { 0,0,0,0 };
        // 0. 사용할 사각형 선택(x값 겹칠때 마다 선택)
		for (int j = 0; j < inArr.size(); j++) {
			if (inArr[j].x1 == Q[i] || inArr[j].x2 == Q[i]) {
				R = inArr[j];
				break;
			}
		}

        // 1. counts배열 구하기(y값 활용)
		// sweepLine이 만나는 사각형의 왼쪽 가로선만 +1, 오른쪽 가로선은 -1
		if (sweepLine == R.x1) delta = 1;
		else delta = -1;

		int y1 = R.y1; int y2 = R.y2;
		for (int j = 0; j < m2; j++) {
			if (y1 <= S[j] && S[j] < y2) {
				counts[j] += delta; // S[j]~S[j+1] 구간에 겹쳐진 사각형의 수
			}
		}
        
        // 2. 면적 계산 시작 
        // 현재 내부면적 세로줄(S[j + 1] - S[j])
		int curlength = 0; 
		for (int j = 0; j < m2; j++) {
			if (counts[j] > 0) { // counts배열 있는 값만(사각형 있는 경우에만)
				curlength += S[j + 1] - S[j];
			}
		}
        
		// 현재 내부면적 가로줄(Q[i+1]-Q[i])
		if ((i + 1) < m1) {
			area += curlength * (Q[i + 1] - Q[i]); // 현재 구한 면적 더함
		}
	}
	return area;
}


int main() {
	cin >> N;
	for (int i = 0; i < N; i++) {
		cin >> inArr[i].x1 >> inArr[i].y1 >> inArr[i].x2 >> inArr[i].y2;
		Q[i * 2] = inArr[i].x1; Q[i * 2 + 1] = inArr[i].x2;
		S[i * 2] = inArr[i].y1; S[i * 2 + 1] = inArr[i].y2;
	}
	m1 = N * 2; // 총 x축 개수
	m2 = N * 2; // 총 y축 개수
	
    // x축, y축 기록한 배열들 꼭 오름차순으로 정렬 후 사용
	sort(&Q[0], &Q[m1]);
	sort(&S[0], &S[m2]);

	cout << unionArea();

	return 0;
}
```

<br><br>

## Network Flow(=Max-Flow, Min-Cut, 이분 매칭)

**Ford-Fulkerson(DFS.복잡도:flow), Edmonds-Karp(BFS.복잡도:VE^2), Dinic's Algorithm(BFS,DFS.복잡도:EV^2) 가 있으며 여기서 `Dinic's` 만 암기해도 충분**

* Ford-Fulkerson과 Edmonds-Karp는 DFS, BFS만 다르며 나머지는 로직이 정확히 동일
* **Dinic's** 는 BFS,DFS 뭘 쓰든 상관없는데 본인은 **BFS로 레벨트리 구하고, DFS(재귀)로 연산을 진행**
* **중요한 점**
  * **"이분 매칭" 문제를 "Max-Flow" 문제로 치환해서 풀 수 있다.**
  * **"Min-Cut" 문제는 그냥 "Max-Flow" 로 풀었을 때 답과 동일하다.**
  * **보통 문제를 푸는 방식은 문제에 적합하게 "그래프" 를 설계한 후 풀어나간다.**
    * **"그래프" 그리는 TIP**
      * 그래프에는 **에지**를 그릴텐데 반드시 유량이 아닌 **용량**을 적어줄 것
        * 햇갈리면 안되는게 **유량은 나중에** 계산할때 값 생기기 시작
      * **멀티 Source, Sink**의 경우?? 외부에 **S, T 노드를 임의로 추가**해서 사용
        * Max Flow는 S->T 로 흐르는 최대 유량을 구하는 형태이기 때문
        * 임의로 S, T를 추가했으므로 그래프 그릴때 용량을 잘 설정해야함
      * 복잡한 문제들은 **에지를 안주고** 직접 에지를 **구해야** 할때도 존재
        * **예시 문제 : [Jerry and Tom](https://www.acmicpc.net/problem/14750)**
        * 참고 : 해당 예시에서는 에지를 직접 구해야하며, 해당 에지는 "선분교차" 여부에 따라 구해진다.

<br>

```c++
/*
BOJ 14286 문제. Min-Cut 문제 => "Max-Flow"
*/
#include<iostream>
#include<vector> // tree
#include<queue> // bfs
#include<algorithm> // fill
#define INF 987654321
using namespace std;

int c[505][505]; // 용량
int f[505][505]; // 유량
vector<int> vc[505]; // tree
int level[505]; // 레벨 그래프
int work[505];

int N, M, S, T; // 정점 수, 에지 수, 시작 노드, 끝 노드

bool bfs() {
	// init
	fill(level, level + 505, -1);
	queue<int> qu; // bfs
	level[S] = 0;
	qu.push(S);
	while (!qu.empty()) {
		int cur = qu.front();
		qu.pop();

		for (int i = 0; i < vc[cur].size(); i++) {
			int nxt = vc[cur][i];
			if (c[cur][nxt] <= f[cur][nxt] || level[nxt] != -1) continue;
			// 레벨이 아직 정해지지 않았고 잔여용량이 0이상은 계속 진행
			level[nxt] = level[cur] + 1; // level 기록 (그냥 깊이 기록임)
			qu.push(nxt);
		}
	}
	return level[T] != -1; // -1 이면 false 반환(종료 의미)
}

int dfs(int cur, int flow) {
	// base condition
	if (cur == T) return flow; // cur -> depth로 이해

	for (int i = work[cur]; i < vc[cur].size(); i++) {
		int nxt = vc[cur][i];
		if (level[nxt] - level[cur] != 1 || c[cur][nxt] <= f[cur][nxt]) continue;
		// 레벨 차가 1이고, 잔여용량이 0이상은 계속 진행

		// 최소 유량 탐색
		int minF = dfs(nxt, min(c[cur][nxt] - f[cur][nxt], flow));

		// 유량 update
		if (minF > 0) {
			f[cur][nxt] += minF;
			f[nxt][cur] -= minF;
			work[cur] = i; // index 기록해서 시간 단축
			return minF;
		}
	}
	work[cur] = vc[cur].size();
	return 0;
}

int main() {
	// speed up
	ios::sync_with_stdio(0);
	cin.tie(0);

	// input
	cin >> N >> M;
	int n1, n2, w;
	for (int i = 0; i < M; i++) {
		cin >> n1 >> n2 >> w;
		vc[n1].push_back(n2);
		vc[n2].push_back(n1); // 양방향
		c[n1][n2] += w; // 양방향 간선이므로, 양쪽으로 용량 할당
		c[n2][n1] += w;
	}
	cin >> S >> T;

	// run
	int maximumFlow = 0; // 제거된 최소 간선 가중치 합
	while (true) {
		if (!bfs()) break; // 종료

		fill(work, work + 505, 0);
		int flow = dfs(S, INF);

		// 최대 유량 update
		maximumFlow += flow;
	}

	// output
	cout << maximumFlow;
	return 0;
}
```

<br><br>

# 참고

**`set, unordered_set, priority_queue` 의 경우에 무슨 자료구조를 언제 사용할까를 정해두려고 한다.**

* 우선 `set` 을 우선으로 사용하되 `prev, next, lower_bound` 같은 동작들이 필요없고 `priority_queue` 가 사용하는 동작만 필요하다면 `priority_queue` 를 사용하자.
