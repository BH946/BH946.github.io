---
title:  "[백준_필수3]알고리즘 템플릿 - java"
categories : [Baekjoon]
tag : [백준, 프로그래머스, 알고리즘 문제풀이]
toc: trues
toc_sticky: true
author_profile: false
sidebar:
   nav: "docs"
typora-root-url: ../../..
---



# Intro..

**사용할 알고리즘들의 템플릿들을 정리하겠다.**

**물론 약간의 알고리즘 해석만을 동반하며, 자세한 해석은 아래 링크를 달아두겠다.**

* **참고 링크 : 구글링 등등**
* 코드들만 기록할랬는데,,, 정리하다보니 해석을 좀 많이했네,,

<br><br>

# Template

**반드시 백준에 제출할 때는 클래스명 : Main**

**package는 꼭 주석 or 제거**

```java
// 포괄적인 라이브러리 선언
import java.util.*;
import java.io.*;
```

<br><br>

## Java TIP

**inner class, inner static class**

* `inner class` 는 외부 클래스로 따로 빼는걸 추천하고, 내부 클래스는 static 사용을 권장
* [참고URL](https://yuja-kong.tistory.com/entry/Java-inner-class-%EC%99%80-inner-static-class-%EC%B0%A8%EC%9D%B4)

```java
class MyClass {
    class InnerClass{} // inner class
    static class InnerStaticClass{} // inner static class
}
```

<br>

**primitive type, reference type**

* `primitive type` 스택 사용 및 값 복사(깊은 복사)
  * 대표적 예시로 기본 타입 : boolean , byte , char , short , int , long , float, double
* `reference type` 힙 사용 및 주소값 복사(얕은 복사)
  * Array, Object, String 등등
  * **단, `String`은 값이 바뀔때 새로운 메모리 주소에 값을 생성하기 때문에 "깊은 복사" 로 생각하기도 하지만 기본 동작은 "얕은 복사" 라는점을 잘 이해하자**
* **c++의 STL은 깊은 복사가 이루어지는데, 이 때문에 java에서 혼동이 많이 왔었다. 잘 구분!!**

```java
String a = "hello"; // a : hello
String b = a; // b : &a (a주소값 가지는 중)
a = "world"; // a : world (새로운 메모리 주소에 새로 world 저장)

// 출력결과 (마치 깊은 복사를 진행한것 같은 효과)
a : world
b : hello
```

<br>

**자바는 소수점 표기도 특징이 있다.**

* **`3E10` 이런 형태로 지수 표기를 함.**
  * 본인은 이런경우 그냥 `printf` 를 사용해서 해결함
    * ex : `System.out.printf("%.1f", result);`
* **소수점 관련 함수는 보통 `Math.round(), String.format()` 을 주로 사용**
  * 둘다 소수점 n번째 자리까지 반올림!!
  * 참고 - 올림 : Math.ceil(), 버림 Math.floor();
  * 단, Math.round() 와 String.format() 의 차이점이 있음 - 소수점 뒤의 0 절삭유무

```java
// 차이점
double test = 3000.000;
System.out.println(Math.round(test*1000)/1000); // 3000
System.out.println(String.format("%.3f", test)); // 3000.000
// 참고로 원하는 소수점 n번째 표현은? 아래 예시는 n=3
double pi = 3.141592
System.out.println(Math.round(pi*1000)/1000.0); // 3.142
/*
즉, 
3.141592*1000 => 3141.592 여기서 round => 3142
3142/1000.0 => 3.142
*/
```

<br><br>

## 입출력 - I/O

**일반 Scanner 방식보다 빠른 방식**

* **INPUT**으로 `BufferedReader, StringTokenizer` 사용
  * `System.in` 으로 입력을 `InputStreamReader` 로 받아서 `BufferedReader` 에 담는다.
  * `br.readLine()` 를 `" "` 기준으로 잘라서 `StringTokenizer` 에 담는다. (split 처럼)
  * 만약 입력의 끝나는 부분을 알고싶다면???
    * `br.readLine()==null` 로 알 수 있으며, 테스트는 **Ctrl+D** 를 입력하면 된다.
* **OUTPUT**으로 `StringBuilder` 사용
  * `System.out.println` 도 많이쓰지만, 많은 출력땐 `StringBuilder` 를 권장

```java
import java.io.IOException;
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.util.StringTokenizer;

public class Main {
	static int[][] arr = new int[301][301];

	public static void main(String[] args) throws IOException {
        // 1. 입력!!
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		StringTokenizer stk = new StringTokenizer(br.readLine()," ");
		int n = Integer.parseInt(stk.nextToken());
		int m = Integer.parseInt(stk.nextToken());
		// 그 다음 부터 n(행)번 입력 받기 (m은 열)
		for (int i = 0; i < n; i++) {
			stk = new StringTokenizer(br.readLine(), " "); 
			for (int j = 0; j < m; j++) {
				arr[i][j] = Integer.parseInt(stk.nextToken());
			}			
		}
        
		// 2. 출력!!
		StringBuilder sb = new StringBuilder(); 
		sb.append("n : " + n + ", m : " + m).append('\n');
		
		for (int i = 0; i < n; i++) {
			for (int j = 0; j < m; j++) {
				sb.append(arr[i][j]);
			}
			sb.append('\n');
		}
		System.out.println(sb);
	}
}
```

<br><br>

## 문자열 - string

**주의사항**

* c++처럼 java도 string은 문자열을 이어붙일때 잘못 사용하면 **O(N^2) 복잡도**를 발생시킬 수 있다.
  * `s+'a'` 라는 새 문자열 객체를 만든후 `s`에 더하기 때문에 `s+'a'` 만큼 매번 추가로 길이가 필요하기 때문이다.
* **따라서 반드시 아래 방식으로 사용해야한다 - O(N)**
  * `'a'` 만 생성되어서 `s` 에 더하기 때문에 `a` 만큼 길이만 추가로 필요하기 때문에 빠르다.
  * **`StringBuilder` 를 사용해야한다.**
* **한번에 초기화하는 fill 메소드 설명**
  * 배열, 리스트 - **`Arrays.fill(), Collections.fill()`**
* `String` 변경 불가, `StringBuilder` 변경 가능
* `parseInt()` : `String` -> `int`
  * `intValue()` : `Integer` -> `int`


```java
// 1. O(N^2) 복잡도 코드
String s = "hi";
s = s+" hello"
// 2. O(N) 복잡도 코드
StringBuilder sb = new StringBuilder();
sb.append("hi").append(" hello").toString();
s.insert, delete, deleteCharAt, setCharAt, reverse, setLength 등등 다양
```

<br>

**아래 문법들은 기본적으로 암기**

```java
String s = "abcde";
s.length();
s.isEmpty();
s.charAt(2); // index 2로 문자찾기
s.indexOf("c"); // 문자로 첫번째 인덱스 찾기
s.lastIndexOf("c"); // 문자로 마지막 인덱스 찾기

s.substring(2, 4); // 2~3 문자열
s.substring(3); // 3~ 문자열
s.replace('b', 'k'); // akcde (새로운 객체 생성)

s.equlas("abcde"); // 비교(기존 ==은 주소를 비교)
s.contains("bc"); // 포함여부
s.compareTo("abcdd"); // 동일:0, s가 사전순 앞:-1, s가 사전순 뒤:1, 마지막 문자만 다르면 마지막 문자의 사전순 차이 반환(여기선 1)
s.split(" ");
s.trim(); // 앞뒤만 공백 제거
s.toLowerCase();
s.toUpperCase();

Integer.parseInt("300"); // Str -> Int
Integer.toString(300); // Int -> Str
```

<br>

**한번에 초기화하는 fill 메소드 - Arrays, Collections**

```java
int[] myArray = new int[10];
Arryas.fill(myArray, 0); // 0으로 init
List<Integer> myList = new ArrayList<>(10);
Collections.fill(myList, null); // null로 init
```

<br><br>

## Array, List(ArrayList)

**List는 인터페이스라서 ArrayList(클래스) 로 구현, Array는 우리가 잘 아는 그 배열이다.**

**Array와 List의 차이는 정적, 동적 길이란 차이가 있고 `length, size()` 를 쓰는 차이도 있다.**

* **참고로 String은 `length()`**

```java
// Array init
int arr[] = {0,1,2}; // length:3
int[] arr = new int[3]; // length:3

// ArrayList init
ArrayList<String> arrayList = new ArrayList<>(Arrays.asList("apple", "banana"));
List<Integer> list = new ArrayList<>(); 
// method
list.add(값), list.get(index), list.set(index, 값), list.remove(index), list.remove(값), list.removeAll(list2) 등등
    
// 문자열 배열을 List로 변환
String[] temp = "abcde";
List<String> list = new ArrayList<>(Arrays.asList(temp));

// List를 문자열 배열로 변환
List<String> list = new ArrayList<>();
String[] temp = list.toArray(new String[list.size()]);

// 정수 배열을 List로 변환
int[] temp = { 123, 789, 456 };
List<Integer> list = new ArrayList<>(Arrays.asList(temp));

// List를 정수 배열로 변환
List<Integer> list = new ArrayList<>();
int[] temp = list.stream().mapToInt(i->i).toArray();

// 중복없이 값을 넣고 싶을 때 (원래는 sort후 중복 무시하는 형태로 얻었었는데, 좀 귀찮았음)
if (list.indexOf(value) < 0) {	// 없으면 -1 리턴
	list.put(value);
}

// 리스트 값 하나씩 가져올 때 (int 일 경우)
for(int i = 0; i < list.size(); i++) {
	list.get(i).intValue();
}
```

<br><br>

## Collections

**Array말고 List쪽의 메소드라 볼 수 있다.**

```java
int[] arr = { 123, 789, 456 }; // array
List<Integer> list = new ArrayList<>(Arrays.asList(arr)); // array to list(arraylist)

Collections.max(list)
Collections.min(list)
Collections.sort(list) // asc
Collections.sort(list, Collections.reverseOrder()) // desc
Collections.reverse(list) // { 456, 789, 123 }

Collections.frequency(list, 123) // 123 요소 개수 반환
Collections.binarySearch(list, 123) // 이분검색(못찾을때 좀 특이)
// 없으면 123보다 큰 최초의 위치를 찾아서 -1을 곱하고 1을 빼서 반환 (-4)
```

<br><br>

## 자를 때(분할할 때)

**특정 정수를 자를 때**

```java
// remain에 자른 정수를 담음
while(value != 0) { // ex : 123 -> 12 -> 1 -> 0
    remain = value % 10; // 123%10=3 -> 12%10=2 -> 1%10 = 1
    value /= 10; // 123/10=12 -> 12/10=1 -> 1/10=0
}
```

<br>

**스트링처럼 split이나 substring을 배열에서 하려면?**

```java
str.substring(3,5); String[] arr = str.split(""); // String의 경우
Arrays.copyOfRange(원본배열, 시작, 끝); // 배열의 경우
```

<br><br>

## BFS, DFS

**BFS(넢이우선검색), DFS(깊이우선검색)은 정말 단골 문제들이다.** 

* **BFS를 우선**으로 사용하며, DFS는 DFS로만 풀리는 문제에 사용하면 된다.
* **BFS는 큐** 를 활용하고, **DFS는 스택 또는 재귀(필자는 주로 재귀)**를 활용한다.
* **주의할점은 BFS는 방문기록을 큐에 집어넣는 시점에 남겨야 한다.**

<br>

**BFS 기본형태 4방향**

```java
// BOJ 1926번 : 그림
// 입력이 좌상을 0,0 으로 좌표계 형성하게끔 들어왔다 가정
public class test { 
    static int[] dx = {0,1,0,-1}; // 행 : 우,하,좌,상
    static int[] dy = {1,0,-1,0}; // 열 : 우,하,좌,상
    static boolean[][] visited = new boolean[505][505];
    static int N;
    static int M;
    static int[][] inArr = new int[505][505];
    static int resultTemp;

    public static void bfs(int x, int y) {
        Queue<Pair> qu = new LinkedList<>(); // LinkedList 로 선언해야함
        visited[x][y] = true; // 방문 표시
        qu.add(new Pair(x,y)); // push

        while(!qu.isEmpty()) {
            int cx = qu.peek().first; // front
            int cy = qu.peek().second;
            resultTemp++;
            qu.remove(); // pop

            for (int i=0; i<4; i++){
                int nx = cx + dx[i];
                int ny = cy + dy[i];
                if(nx<0 || ny<0 || nx>N-1 || ny>M-1) continue; // 범위 내 체크
                if(visited[nx][ny]) continue; // 방문 여부 체크
                if(inArr[nx][ny] == 1) {
                    // 땅이 있는 경우(=1) 큐에 추가
                    visited[nx][ny] = true; // 방문 표시
                    qu.add(new Pair(nx,ny));
                }
            }
        }
    }

    public static void main(String[] args) throws IOException {
        // input
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer stk = new StringTokenizer(br.readLine(), " ");
        N = Integer.parseInt(stk.nextToken());
        M = Integer.parseInt(stk.nextToken());
        for (int i = 0 ; i< N ; i++){
            stk = new StringTokenizer(br.readLine(), " ");
            for(int j = 0 ; j< M; j++){
                inArr[i][j] = Integer.parseInt(stk.nextToken());
            }
        }
        // run
        int resultMax = 0;
        int resultCount = 0;
        for(int i = 0; i<N;i++){
            for(int j = 0 ; j<M;j++){
                if(visited[i][j] || inArr[i][j] == 0) continue;
                resultTemp = 0; // 넓이 변수
                bfs(i, j); // 0,0 시작
                resultMax = Math.max(resultMax, resultTemp);
                resultCount++;
            }
        }
        System.out.println(resultCount);
        System.out.println(resultMax);
    }

    static class Pair {
        int first;
        int second;

        public Pair(int first, int second) {
            this.first = first;
            this.second = second;
        }
    }
}
```

<br>

**BFS 시작점이 여러 개**

* BFS를 **동시에** 동작하듯이 해야하는 경우에 해당된다.
* 같이 시작할 시작점들을 while문 돌리기전 큐에 전부 삽입후 평소처럼 BFS를 진행한다.
* **큐의 특성상 들어온 순서대로 진행할거기 때문에 가능한 것이다.**

<br>

**BFS 거리측정 + 시작점이 두 종류**

* `BOJ 4179번 : 불!` 문제를 예시로 들겠다.
  * 위처럼 시작점 여러개를 적용을 하는 부분이 초기에 진행된다.
  * 그리고 두 종류로 BFS를 따로 동작하는 형식이다.

```java
public class Main {
    static int R, C; // Row, Column
    static char[][] inArr = new char[1005][1005];
    static int[][] dist1 = new int[1005][1005]; // J
    static int[][] dist2 = new int[1005][1005]; // F
    static int[] dx = {0,1, 0, -1};
    static int[] dy = {1,0, -1, 0};

    public static void bfs() {
        // init dist1, dist2
        for(int i=0;i<1005;i++){
            Arrays.fill(dist1[i], -1);
            Arrays.fill(dist2[i], -1);
        }
        // J(지훈), F(불) 위치 찾아서 각각 큐에 push
        Queue<Pair> qu1 = new LinkedList<>(); // LinkedList 로 선언해야함(J)
        Queue<Pair> qu2 = new LinkedList<>(); // LinkedList 로 선언해야함(F)
        for(int i = 0; i<R;i++){
            for(int j = 0 ;j<C;j++){
                if(inArr[i][j] == 'J') {
                    dist1[i][j] = 0; // 지훈이 거리 기록(분)
                    qu1.add(new Pair(i,j));
                }
                if(inArr[i][j] == 'F') {
                    dist2[i][j] = 0; // 불 거리 기록(분)
                    qu2.add(new Pair(i,j));
                }
            }
        }
        // F(불) BFS
        while(!qu2.isEmpty()) {
            int cx = qu2.peek().first;
            int cy = qu2.peek().second;
            qu2.remove();

            for(int i = 0 ; i<4;i++){
                int nx = cx+dx[i];
                int ny = cy+dy[i];
                if (nx<0 || ny<0 || nx> R - 1 || ny > C - 1) continue; // 범위 내 체크
                if (inArr[nx][ny] == '#') continue; // 벽 체크
                if (dist2[nx][ny] == -1) {
                    dist2[nx][ny] = dist2[cx][cy] + 1; // 거리(분) 기록
                    qu2.add(new Pair(nx, ny));
                }
            }
        }
        // J(지훈) BFS
        // 불이 언제 어디서 퍼지는지 다 알고난 후 J(지훈)를 BFS 한다.
        // J가 범위를 벗어난 경우 탈출 성공이라 했으므로, 
        // 이때 불이 퍼지기 전에 탈출인지만 추가로 체크하면 된다.
        while(!qu1.isEmpty()){
            int cx = qu1.peek().first;
            int cy = qu1.peek().second;
            qu1.remove();

            for(int i = 0 ; i<4;i++){
                int nx = cx + dx[i];
                int ny = cy + dy[i];
                // 범위 내 체크
                if (nx<0 || ny<0 || nx>R-1 || ny>C-1){
                    // 이곳은 범위 밖(즉, 탈출)
                    // 따라서 이때 불 보다 먼저인지 체크(dist1[cx][cy] < dist2[cx][cy])
                    // dist2[cx][cy] == -1 의 의미는 F(불)이 사방에 갇혀서 못나온 경우다.
                    if (dist1[cx][cy] < dist2[cx][cy] || dist2[cx][cy] == -1) {
                        System.out.println(dist1[cx][cy]+1);
                        return;
                    }
                    continue;
                }
                if (inArr[nx][ny] == '#') continue; // 벽 체크
                if (dist1[nx][ny] == -1) {
                    dist1[nx][ny] = dist1[cx][cy] + 1; // 거리(분) 기록
                    qu1.add(new Pair(nx,ny));
                }
            }
        }
        System.out.println("IMPOSSIBLE");
    }
    public static void main(String[] args) throws IOException {
        // input
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer stk = new StringTokenizer(br.readLine(), " ");
        R = Integer.parseInt(stk.nextToken());
        C = Integer.parseInt(stk.nextToken());
        for(int i = 0 ; i<R;i++){
            stk = new StringTokenizer(br.readLine(), "");
            String inStr = stk.nextToken(); // string
            for(int j = 0 ; j<C;j++){
                inArr[i][j] = inStr.charAt(j); // char
            }
        }
        // run & output
        bfs();
    }
    static class Pair {
        int first, second;
        public Pair(int first, int second) {
            this.first = first; this.second = second;
        }
    }
}
```

<br>

**1차원에서의 BFS (즉, 4방향이 아니라)**

* dx,dy 배열을 통해서 `for(int i=0; i<4; i++)`에서 `nx, ny` 를 구하는 것이, 
* 꼭 4방향이 아니라 필요에따라 `for (auto nx : inArr[cx])` 형태로 다른 요소들의 접근으로 바뀐다던지 이런식으로도 응용한다는 것이다.

<br>

**DFS : 큐->스택 변경시 동일하게 동작하며, 아래 그래프 쪽 파트에서 재귀 방식도 참고(백트래킹에서 많이 사용)**

<br><br>

## 재귀(Recursion)

**`절차지향적 사고 -> 귀납적 사고` 가 반드시 필요!!!**

**절차적으로 이해하지 마라!! 귀납적으로 그냥 이렇게 되겠구나라고 생각만 하라!! 도미노를 생각!!**

* **수학적 귀납법**
  * **1번 도미노가 쓰러진다.  
    k번 도미노가 쓰러지면 k+1번 도미노도 쓰러진다.**
    * 참(true) : **1번 도미노가 쓰러진다, k번 도미노가 쓰러지면(가정)**
    * 두 문장이 참이므로 **k+1번 도미노..** 또한 귀납적으로 참
  * **예시1) 아래 코드의 예시**
    * **func1(1)이 1을 출력한다.  
      func1(k)가 k,k-1,k-2...1을 출력하면 func1(k+1)은 k+1,k,k-1,k-2...1을 출력한다.**
  * **예시2) 하노이 탑 이동 순서(n개 원판을 기둥 1 -> 기둥 3 으로 이동)**
    * n-1개의 원판을 1->2 이동  
      n번 원판을 1->3 이동  
      n-1개의 원판을 2->3 이동  
      => 규칙이 큰 원판 위에 작은 원판을 두는것이기 때문에 반드시 n-1개 원판이 기둥 2에 있고,   
      n번 원판이 기둥 1-> 기둥 3 으로 이동하는 경우의 존재는 생각해보면 자명하다.
    * **원판이 1개일 때 원판을 내가 원하는 곳으로 옮길 수 있다.  
      원판이 k개일 때 옮길 수 있으면 원판이 k+1개일 때에도 옮길 수 있다.**
* **재귀 함수의 조건**
  * Base condition : 특정 입력에 대해서는 자기 자신을 호출하지 않고 종료되어야 함
  * 모든 입력은 Base condition으로 수렴
* **재귀에 대한 정보**
  * 함수의 인자로 어떤 것을 받고 어디까지 계산한 후 자기 자신에게 넘겨줄지 명확하게 정해야 함
    * 모든 재귀 함수는 for문으로 만들 수 있음
    * 재귀는 for문 보다 메모리/시간에서 손해를 봄(함수 호출량 때문)

  * 한 함수가 자기 자신을 여러 번 호출하게 되면 비효율적일 수 있음(계산 중복 때문)
    * 예 : 피보나치 수열 => 해결법(DP로 중복 계산 재사용을 통해서 해결)

  * 재귀함수가 자기 자신을 부를 때 스택 영역에 계속 누적이 됨
    * 100000 정도 호출했을 때 정상동작 하지 않으면 구글 검색을 통해 스택 메모리 제한을 해제할 것

<br>

**재귀로 로직 작성 순서**

​	**1. 함수의 정의**

​	**2. base condition**

​	**3. 재귀 식**

```java
static StringBuilder sb = new StringBuilder(); // 문자열 기록
public static void func(int n){
    if(n==0) return; // base condition
    sb.append(n+" ");
    func(n-1); // 재귀
} 
public static void main(String[] args) throws IOException {
    func(5);
    System.out.println(sb); // 출력
}
```

<br><br>

## 백트래킹(Backtracking)

**`상태 공간트리` 를 그려가면서 문제를 이해하고, 재귀 형태로 풀어나가면 된다.**

**`깊이우선검색(=DFS)`을 기반으로 검색을 진행하며, 각 마디가 유망하지 않으면 그 마디의 부모 마디로 돌아가서 다시 검색을 계속하는 방식이다.**

* **참고 : `백트래킹` 은 깊이우선검색(DFS)을 기반으로 하지만, `분기한정법` 은 여러 검색 방법들을 지원하는 차이가 있다.**

<br>

**N과 M(1) - 대표적인 템플릿**

```java
// BOJ 15649
// N과 M(1) : 1부터 N까지 자연수 중에서 `중복 없이(=visited 활용)` M개를 고른 수열
// 즉, (1 2) (1 3) 은 가능하지만 (1 1)은 불가
static int N, M;
static int[] outArr = new int[10];
static boolean[] visited = new boolean[10];
static StringBuilder sb = new StringBuilder();

public static void dfs(int depth) {
    // base condition
    if(depth == M) {
        for(int i = 0 ; i<M; i++){
            sb.append(outArr[i]+" ");
        }
        sb.append('\n');
        return;
    }
    
    for(int i = 1 ; i<=N; i++){
        if(visited[i]) continue;
        visited[i] = true;
        outArr[depth] = i;
        dfs(depth+1); // recursion
        visited[i] = false; // backtracking
    }
}
```

<br>

**N과 M 시리즈 - dfs 방식 백트래킹 사고력 확장**

```java
// 참고 : 1~N 순서대로 접근했기 때문에 수열을 구하면 사전순(오름차순)으로 출력
// 그러나, 랜덤 값이 들어온 경우에 사전순 출력을 위해선 수열 구하기전에 sort작업이 필요

// `i > preValue`로 구하는 값 오름차순 (즉, 현재값 > 이전값)
for (int i = 1; i <= N; i++) {
    if (!visited[i] && i > preValue) { // 만약 비내림차순은? `i>=preValue`
        visited[i] = true;
        outArr[depth] = i;
        dfs(depth + 1, i);
        visited[i] = false; // backtracking
    }
}

// 1부터 N까지 자연수 중에서 `중복 허용(=visited 활용X)` M개를 고른 수열
for (int i = 1; i <= N; i++) {
    if (!visited[i]) {
        //visited[i] = true;
        outArr[depth] = i;
        dfs(depth + 1);
        //visited[i] = false; // backtracking
    }
}

// 애초에 입력이 1 2 3 4 가 아닌 1 1 2 3 이런식으로 중복으로 들어올 경우 처리방법 소개
// `tempNum != inArr[i]` 이 핵심
int tempNum = 0; // 이전값 기록해둬서 중복 수열 생성되지 않도록 하기 위함
for (int i = 1; i <= N; i++) {
    if (!visited[i] && tempNum != inArr[i]) {
        tempNum = inArr[i];
        visited[i] = true;
        outArr[depth] = inArr[i];
        dfs(depth + 1, inArr[i]);
        visited[i] = false;
    }
}

// 마지막으로 시간초과를 해결하는 TIP => 아래 동작만 필요한 경우들에 사용!!
for (int i = index; i < chicken.size(); i++) { // 반드시 index부터 시작해야 시간초과 안전
    p = chicken[i];
    if (visited[p.first][p.second]) continue;
    visited[p.first][p.second] = true;
    outArr[depth] = i; // 선택된 치킨집 index 기록
    dfs(depth + 1, i); 
    visited[p.first][p.second] = false; // backtracking
}
```

<br>

**부분수열의 합 - 응용(사고력 확장)**

```java
// 이 문제도 위 코드와 같은 형태로 해결할 수 있지만, 좀 더 간단하게 해결할 수도 있다.
// 위 코드의 경우 하나의 형태로만 재귀를 한것이다.
// 하지만, 이 문제를 상태 트리 그려보면 값을 더한경우 안더한경우로 나눠 볼 수 있다.
// 즉, 2개 형태로 재귀를 할 수 있고 훨씬 코드도 간결해진다.
public static void func(int depth, int sum) {
	if (depth == N) { // base condition
		if (sum == S) result++;
		return;
	}
	func(depth + 1, sum); // 안더함
	func(depth + 1, sum + inArr[depth]); // 더함
}
```

<br><br>

## Branch-and-Bound(분기한정법)

**이건 이런게 있다란 개념만 이해해두자. [분기한정법-개념](https://bh946.github.io/algorithm/(%EA%B0%9C%EB%85%90)-Branch-and-Bound(%EB%B6%84%EA%B8%B0%ED%95%9C%EC%A0%95%EB%B2%95)/)**

* **분기한정법 : Backtracking +** **다른 탐색들(DFS,BFS,우선순위큐 등)**
  * **Bound** : 마디가 유망한지 여부를 결정하기 위해서 한계치(bound) 계산
  
  * **So far the best** : 현재까지 찾은 최적의 답
  
* **최적화 문제의 SST 비교**

  * 최적화 문제의 SST 비교 최소화 문제(예: TSP)
    * 트리 깊어질수록 BOUND값이 절대 작아질 수 없음(Low Bound를 구함)


  * 최적화 문제의 SST 비교 최대화 문제(예: 0-1냅색)
    * 트리 깊어질수록 BOUND값이 절대 커질 수 없음(Upper Bound를 구함)

<br><br>

## 시뮬레이션(구현)

**존나 풀어라... 단, 구현인 만큼 코드 작성 전 꼭 도식화를 진행**

* **존나 풀어라 : [구현(실버급 인기 순)](https://solved.ac/search?query=%23implementation+*s&sort=solved&direction=desc&page=1)**
* **자주 나오는 로직은 그냥 외우자**
  * 예로 2차원 배열 회전 로직은 `B[x][y]=A[N-1-y][x]`

```java
// 90도 회전 함수 => ccw(반시계)
public static void rotate() {
    // 1. tmp에 복제
	int[][] tmp = new int[12][12];
	for (int i = 0; i < N; i++) {
		for (int j = 0; j < M; j++) {
			tmp[i][j] = inArr[i][j];
		}
	}
	// 2. 배열요소 swap
	for (int i = 0; i < N; i++) { 
		for (int j = 0; j < M; j++) {
            // CW : B[x][y]=A[y][M-1-x]
            // CCW : B[x][y]=A[N-1-y][x]
			inArr[i][j] = tmp[N-1-j][i];
		}
	}
    // 3. 배열크기 swap
    swap(N,M);
}
예제 배열:
[1, 2, 3]
[4, 5, 6]
[7, 8, 9]
CW(시계) 회전 결과:
[7, 4, 1]
[8, 5, 2]
[9, 6, 3]
CCW(반시계) 회전 결과:
[3, 6, 9]
[2, 5, 8]
[1, 4, 7]
```

<br><br>

## 정렬(Sort)

**Arrays.sort(Quick), Collections.sort(Merge) 이용**

* **응용**을 예시 들면, 정렬 때 같은 수는 인접하는 성질을 이용해 **중복 원소 제거**도 가능
  * **정렬은 아니지만 숫자를 바로 index와 매칭해서 받는 로직도 잘 기억**

```java
// 1. Arrays.sort => primitive type 배열 지원 + String까지 지원
int[] num = {5,2,8};
Arrays.sort(num); // 오름차순
Integer[] num = {5,2,8}; // Collection 때문에 Integer로 선언
Arrays.sort(num, Collections.reverseOrder()); // 내림차순

// 2. Collections.sort => ArrayList, LinkedList와 같은 Collection 타입 지원
List<Integer> num = nuw ArrayList<Integer>();
num.add(5); nums.add(2); num.add(8);
Collections.sort(num); // 오름차순
Collections.sort(num, Collections.reverseOrder()); // 내림차순

// 3. sort 커스텀 => comp 수정 (Comparator 구현)
static int[] order = {3,1,5};
static Integer[] inArr = {1,2,0};
public static void main(String[] args) {
    ObjectSort ob = new ObjectSort();
    Arrays.sort(inArr, ob);

    System.out.println(Arrays.toString(inArr));
    // 출력 : [1, 0, 2]
}
static class ObjectSort implements Comparator <Integer> {
    @Override
    public int compare(Integer a, Integer b) { // a, b는 inArr값
        return order[a] - order[b]; // 비교를 order배열로 하게끔 커스텀
    } 
    // a가 b의 앞에 와야할 때 위 식이 양수, 그렇지 않을 때 음수, 동일할 때 0
    // 즉, 오름차순을 의미
}

// 정렬 TIP!!
// Long.compare(a.x, b.x) 는 a.x < b.x ? -1 : (a.x==b.x?0:1) 와 동일!!
    static class ObjectSortTip implements Comparator <Point> {
        @Override
        public int compare(Point a, Point b) {
            if(getAngle(a) != getAngle(b)) return Double.compare(getAngle(a), getAngle(b));
            if(a.y != b.y) return Long.compare(a.y, b.y);
            return Long.compare(a.y, b.y); // == a.x < b.x ? -1 : (a.x==b.x?0:1)
        }
    }
```

<br><br>

## 다이나믹 프로그래밍(DP)

**DP란 여러 개의 하위 문제를 먼저 푼 후 그 결과를 쌓아올려 주어진 문제를 해결하는 알고리즘**

**참고로 DP는 정말 대표하는 문제들이 많고 유형들도 가지각색이라서 많은 경험이 필요**

<br>

**DP를 푸는 과정 - 테이블 잡고 식 찾는 연습이 매우매우 중요**

​	**1. 테이블 정의하기**

​	**2. 점화식 찾기**

​	**3. 초기값 정하기**

<br>

**EX) 1로 만들기 [BOJ : 1463번](https://www.acmicpc.net/problem/1463)**

* **테이블 정의하기**
  * D[i]는 i를 1로 만들기 위해 필요한 연산 사용 횟수의 최솟값
* **점화식 찾기**
  * D[12]는 ??   
    3로 나누면 (D[12] = D[4] + 1)  
    2로 나누면 (D[12] = D[6] + 1)  
    1을 빼면 (D[12] = D[11] + 1)  
    => D[12] = min(D[4]+1, D[6]+1, D[11]+1)
  * D[k] = ?   
    => D[k] = min(D[k/3]+1, D[k/2]+1, D[k-1]+1)
* **초기값 정의하기**
  * D[1] = 0

```java
// input
BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
StringTokenizer stk = new StringTokenizer(br.readLine());
N = Integer.parseInt(stk.nextToken());
// init - dp
d[1] = 0;
// run
for(int i = 2 ; i<=N; i++){
    d[i] = d[i-1]+1;
    if(i%2==0) d[i] = Math.min(d[i], d[i/2]+1);
    if(i%3==0) d[i] = Math.min(d[i], d[i/3]+1);
}
// output
System.out.println(d[N]);
```

<br><br>

## 그리디(Greedy)

**그리디란 지금 가장 최적인 답을 근시안적으로 택하는 알고리즘 = 관찰을 통해 탐색 범위를 줄이는 알고리즘**

**구현자체는 굉장히 간단해서 따로 정해진 코드 탬플릿은 X**

**단, 코테에서 추천 전략은 문제가 100% 그리디 풀이란게 확신하면 짜서 제출 및 틀리면 빠르게 손절  
100% 확신이 없으면, 일단 넘어가고 마지막에 남은 시간에 코딩 시작**

<br><br>

## 수학(Math)

**자세한 개념은 반드시 [알고리즘 기초1 - 수학](https://bh946.github.io/baekjoon/(%EB%B0%B1%EC%A4%80_%EA%B0%95%EC%9D%981)%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EA%B8%B0%EC%B4%881-%EC%88%98%ED%95%99(%EA%B0%9C%EB%85%90)/), [바킹독 - 수학](https://blog.encrypted.gg/983) 게시물을 함께 참고**

<br>

### 1. 소수

**개선시킨 소수판정과 소인수분해는 모두 O(√n)**

**1부터 n까지의 수 중에서 소수 목록을 구하는건 에라토스테네스의 체를 사용**

* **소수 판정법(소수 1개!!)  - O(√n)**
  * 합성수 N에서 1을 제외한 가장 작은 약수는 √N 이하이다.
    * `EX) N=18 : 2<=√18, N=25 : 5<=√25, N=21 : 3<=√21`

```java
// √N 이하까지만 확인해도 소수 판별이 가능하므로 복잡도 N -> √N 개선
public static boolean isPrime(int n) {
    if(n == 1) return false;
    for(int i = 2; i*i<=n; i++) { // √N 이하까지 돈다.
        if(n%i == 0) return false;
    }
    return true;
}
```

<br>

* **소수 목록(소수 여러개!!) - 에라토스테네스의 체**
  * 소수는 자신보다 작은 수들의 배수값과 동일한게 있으면 안되는 특징을 이용
  * 예로 2의 경우?? 
    * 처음 `prime[2]`는 소수로 그대로 있고, `prime[4, 6, 8...]` 배수들은 소수가 아닌것으로 걸러지는 형태이다.

```java
// 에라토스테네스의 체
// prime배열 의미 : false면 소수, true면 소수아님 => 초기값 false로 초기화(전역배열)
int p = 2;
while(p*p <= N) {
    if(prime[p] == false) {
        for(int i = p*p; i<=N; i+=p) { // i+=p 는 p의 배수들 걸러내려고
            prime[i] = true;
        }
    }
    p++;
}
```

<br>

* **소인수분해**
  * 소인수분해 : 자연수를 소인수(약수들 중 소수)들의 곱으로 표현하는 것
    * `EX) 60 = 2 x 2 x 3 x 5`
  * 방법1) N 이하의 모든 소수를 에라토스테네스의 체로 다 찾은 다음에 그 소수들로 N을 나누어보는 방법
  * **방법2) 하지만, 이보다 더 괜찮은 방법이 존재(루트N 복잡도)**
    * i를 2,3,4,5... 올라가면서 N을 나누어 떨어질때마다 소인수 목록에 기록하는 방법

```java
// 소인수분해
for(int i = 2; i*i<=N; i++) { // √N 이하까지 돈다.
    while(N%i == 0) { // while문 (약수는 나누어 떨어져야 함)
        System.out.println(i); // 구한 소인수
        N/=i; // n이 1이 될때까지 갱신
    }
}
if(N!=1) System.out.println(N); // 마지막에 n이 1이 안될경우도 있는데, 그땐 n으로 나누면 1이 됨
```

* **참고) 팩토리얼 수에서 특정 수의 개수 구할때 유용한 특징 존재** : 10!의 경우 5의 개수를 구하기 위해 5를 10으로 나누면, 1~10 곱한 값 사이의 5가 나온 개수가 출력된다.

<br>

### 2. 최대공약수, 최소공배수(GCD, LCM)

* **최대 공약수(GCD), 최소 공배수(LCM) - 유클리드 호제법**
  * `유클리드 호제법` : 2개의 자연수 a, b에 대해서 a를 b로 나눈 나머지를 r이라고 하면(단, a> b), a와 b의 최대 공약수는 b와 r의 최대 공약수와 같다.
    * (a, b) = (b, r)
    * EX) 10 20 : (10, 20) = (20, 10) = (10, 0) = 10

```java
// 최대공약수 -> (a, b) = (b, r)
// (1) 재귀 방식
public static int gcd(int a, int b) {
    if(b==0) return a;
    return gcd(b,a%b);
}
// (2) 반복문 방식 - 정수론의 정리 이용
// 정리 : 두 정수 a(≥0)와 b(>0) 가 있을 때, a = b∙q+r (0 ≤r<b) 이면  gcd(a,b) = gcd(b,r) 이다.
public static int gcd(int a, int b) {
    int r1 = a; int r2 = b; // init
    while(r2>0) {
        int q = r1/r2; // 몫
        int r = r1-r2*q; // 나머지 r = a-b*q
        r1 = r2; r2 = r;
    }
    return r1;
}

// 최소공배수 -> A X B = GCD(A,B) X LCM(A,B)
public static int lcm(int a, int b) {
    return a / gcd(a,b) * b; // overflow 방지 위해 나누기 먼저(곱셈이라 가능)
}
```

<br>

### 3. 연립합동방정식

**아래 그림에서 조건에 만족한 학생 수를 구하기 위해 0~29 학생 수 때의 상황을 테이블로 나타냈고,  
정답은 27명임을 알 수 있으며 이런 문제를 `연립합동방정식` 이다.**

![image-20230430191943232](/images/2023-01-03-(백준_필수3)알고리즘 템플릿 - cpp/image-20230430191943232.png)

<br>

**다만, 이렇게 0~29 명 때를 전부 찾아보는게 아닌 5개만 확인하면 되는 효율적인 방법을 소개한다.**

* `N%6==3` 인 수들이 필요하고, 이는 처음 3부터 시작해서 +6인 `3,9,15,21,27`이다.
* 이 5개의 수들 중에서 `N%5==2` 를 찾기만 하면 된다.

![image-20230430192200486](/images/2023-01-03-(백준_필수3)알고리즘 템플릿 - cpp/image-20230430192200486.png) 

```c++
public static int chk() {
    for(int i = 3; i<30; i+=6) { // N%6==3 인 경우들만 접근
        if(i % 5 == 2) return i;
    }
    return -1;
}
```

<br>

### 4. 이항계수(조합)

**방법1) 조합의 공식 : `nCr = n!/[(n-r)!r!]` 을 이용하는 방법**

**방법2) 조합 성질 : `nCk = (n-1)C(k-1) + (n-1)Ck` 를 이용해서 DP로 구하는 방법(추천!!)**

* 점화식 : `d[i][j] = d[i-1][j-1] + d[i-1][j]`

<br>

### 5. A진법 to B진법의 변환(관계)

**필자는 이것을 `A진법 -> 10진법 -> B진법` 의 변화로 해결하고 있다.**

**[백준11576 풀이 게시글](https://bh946.github.io/baekjoontest/(C++)Base-Conversion-%EB%B0%B1%EC%A4%8011576/) 참고!!**

* `A진법 -> 10진법`
  * 예로 2진법이라면??
    * 먼저, 10진수 값이 `10` 이였다면 이를 2진법으로 표현 했을때는 `1010`이다.
      * `1010` 의 일의 자리 수를 10진수로 표현하면 `0*2^0 = 0` 이다.
      * `1010` 의 십의 자리 수를 10진수로 표현하면 `1*2^1 = 2` 이다.
      * `1010` 의 백의 자리 수를 10진수로 표현하면 `0*2^2 = 0` 이다.
      * `1010` 의 천의 자리 수를 10진수로 표현하면 `1*2^3 = 8` 이다.
    * 마지막으로 `1010` 을 10진수로 표현한다면??
      * `0*2^0 + 1*2^1 + 0*2^2 + 1*2^3 = 0 + 2 + 0 + 8 = 10`
* `10진법 -> B진법`
  * 10진수를 기수 B로 계속 나누어서 나머지 값을 거꾸로 출력하는 방식이다.
  * **그림으로 참고(추천 URL) : [10진수 A,B 진법 관계](https://piyoro.github.io/program/221770535071/)**

<br><br>

## 이분탐색

**정렬되어 있는 배열에서 특정 데이터를 찾기 위해 모든 데이터를 탐색 범위를 절반으로 줄여가며 찾는 탐색 방법**

*  **`Arrays.binarySearch(arr, target)` 함수를 활용** : 찾는 수가 등장했는지 안했는지를 이분탐색으로 알려줌(**오름차순에** 사용)
  * 물론, `sort` 처럼 범위 지정할 수 있다.
  * **단, `parametric search` 관련해서 구하려면 직접 `binarySearch` 를 작성 해줘야 한다.**

* 분할정복처럼 `st, en, mid` 인덱스 활용하며 `mid=(st+en)/2` 가 기본
  * 반드시 st,en을 1차이 나게끔 0,1로 가정하던지 해서 무한루프에 빠지는지 체크도 중요!!
    * **무한루프에 빠지게 되는경우 `mid=(left+right+1)/2` 사용을 권장**

<br>

**이분탐색 자료구조 `Arrays.binarySearch(arr, target)` 기본 사용법**

```java
int[] arr = {2, 5, 8, 12, 16, 23, 38, 56, 72, 91};
int target = 23;
System.out.println(Arrays.binarySearch(arr, target)); // 5 반환 (없으면 음수값 반환)

// EX : BOJ 1920
// input
// 생략...

// run & output
StringBuilder sb = new StringBuilder();
Arrays.sort(inArr1, 0, N); // ASC (범위지정)
for(int i = 0 ; i<M;i++){
    int findIndex = Arrays.binarySearch(inArr1, 0, N, inArr2[i]); // (범위지정)
    if(findIndex<0) sb.append(0).append('\n');
    else sb.append(1).append('\n');
}
System.out.println(sb);
```

<br>

**`binarySearch, lower_bound, upper_bound` 직접 구현 방식**

* 이분탐색으로 target의 왼쪽, 오른쪽 위치 구하는 함수 `lower_bound, upper_bound` 는 애초에 java에서 제공하지 않으므로 **직접 구현**해줘야 함
* **`upper_bound() - lower_bound()` 형태로 중복수의 개수를 구할 수 있다는점**
  * [바킹독님](https://blog.encrypted.gg/985) 의 그림부분을 참고

```java
// BOJ 10816
static int n=5;
static int[] a = {1,2,2,2,3};
public static int binarySearch(int target) {
    int st = 0;
    int en = n-1;
    while(st <= en) {
        int mid = (st+en)/2;
        if(a[mid] < target) st = mid+1;
        else if(a[mid] > target) en = mid-1;
        else return mid; // 찾은 경우
    }
    return -1; // st > en 의 경우 while문 탈출
}
public static int lower_bound(int target, int len) {
    int st = 0;
    int en = len;
    while(st < en) {
        int mid = (st+en)/2;
        if(a[mid] < target) st = mid+1;
        else en = mid; // (a[mid] >= target)
    }
    return st;
}
public static int upper_bound(int target, int len) {
    int st = 0;
    int en = len;
    while(st < en) {
        int mid = (st+en)/2;
        if(a[mid] <= target) st = mid+1;
        else en = mid; // (a[mid] > target)
    }
    return st;
}
```

<br>

### 1. 좌표압축

**나중에 문제를 풀다보면 입력값의 범위는 1에서 10^9 정도로 굉장히 큰데 그거를 배열 인덱스처럼 쓰고 싶을 수 있습니다.   
그러면 뭔가 크기 순으로 번호를 0번부터 매기고 싶다는 생각이 들텐데 이런 일을 하는게 좌표압축입니다.**

* **좌표압축 방법 : 정렬 -> 중복 제거 -> 이후 이분탐색 수행**
  * `List` 로 입출력 한 경우에는 `Set` 으로 **중복제거**하는게 매우 간편
  * 아래 예시 코드는 그냥 앞, 뒤 값 비교해서 **중복제거**

```java
//BOJ 18870
// 좌표압축 : 정렬 -> 중복제거 -> 이분탐색
Arrays.sort(inArr, 0, N); // 정렬
int index = 0;
for(int i = 0 ; i<N-1;i++){
    if(inArr[i] != inArr[i+1]) {
        inArr[index++] = inArr[i]; // 중복제거
    }
}
inArr[index] = inArr[N-1]; // 마지막 원소 넣기
for(int i = 0 ; i<N;i++){
    sb.append(lower_bound(outArr[i],index+1)); // 이분탐색
    sb.append(" ");
}
System.out.println(sb);
```

<br>

**좌표압축 또다른 예**

```java
// 문자 -> index로 변환 함수(좌표압축 함수)
public static int getID(char c) { 
	if (c <= 'Z')
		return c - 'A';
	return c - 'a' + 26; // 26은 A~Z 이후에 자리를 두기 위함
} // 아스키코드는 A가 a보다 작음
```

<br><br>

## 투 포인터

**투 포인터는 배열에서 원래 이중 for문으로 O(N^2)에 처리되는 작업을 2개 포인터의 움직임으로 O(N)에 해결하는 알고리즘**

* 이분 탐색으로 투 포인터 문제를 풀던가, 투 포인터 문제를 이분 탐색으로 풀 수 있는 경우가 많다.
* 예시로 **[수 고르기](https://www.acmicpc.net/problem/2230)** 를 풀어본다.
  * 아래 코드는 2개의 포인터를 적절히 조건에 맞게 움직여서 해를 구하는 모습이다.

```java
// BOJ 2230
Arrays.sort(inArr);
int result=2000000100;
int i = 0; int j = 1; // 투 포인터
for(i = 0; i<N; i++){
    while(j<N&&Math.abs(inArr[j]-inArr[i])<M) j++;
    if(j==N) break;
    result = Math.min(result, Math.abs(inArr[i]-inArr[j]));
}
```

<br><br>

## 해시

**해시 함수 : 임의 길이의 데이터를 고정될 길이의 데이터로 대응시키는 함수 (5135:Kim,...)**

**해시 테이블 : 아래 그림**

* 같은 키가 삽입될 수 있어서 충돌은 어쩔 수 없다.
* 대표적인 충돌회피 방법은 `Chaining, Open Addressing` 이 존재한다.
  * Chaining : 연결리스트로 회피
  * Open Addressing : Probing 방식으로 데이터 저장해서 회피
    * Linear Probing : 충돌 발생 시 오른쪽으로 1칸씩 이동
      * 단점 : Clustering(군집화) 발생
    * Quadratic Probing : 충돌 발생 시 오른쪽으로 1,3,5,... 칸씩 이동
      * 단점 : 약하긴 하지만 Clustering(군집화) 발생
    * Double Hashing : 충돌 발생 시 이동 칸의 수를 새로운 해시함수로 계산하는 방식
      * 단점 : 적중률이 낮아짐

![image-20230430212318397](/images/2023-01-03-(백준_필수3)알고리즘 템플릿 - cpp/image-20230430212318397.png)

<br>

**해시 테이블을 기반으로 이루어진 라이브러리**

* `HashSet, HashMap, LinkdedHashMap(참고)` 이 3개만 기억
  * Python 의 **set, dict** 자료구조랑 유사
    * **set** : value만 존재 => **중복 불가**에 주로 사용
      * 특히 순서를 지키지 않기 때문에 get하려면 처음부터 순회(iteration)를 통해서 구해야하므로 이런 경우 반드시 map을 사용 권장
    * **map** : key, value 쌍으로 존재 => **보통 이것**을 사용
      * 조회할 때 최적화 하려면 **entrySet** 을 활용
  * **LinkdedHashMap**는 순서를 지키고 싶을때 사용(물론 set도 존재)
* 이름이 비슷한 **BST 자료구조**인 `TreeSet, TreeMap` 과 구분할 것
  * BST는 정렬 순서를 유지하는 대신에 해시보다 느리므로, **"속도, 정렬" 2가지를 놓고 자료구조 선택**하면 된다.
    * `insert, erase, find update` 동작이 해시는 **O(1), RBT는 O(logN)**
    * 그러나, RBT는 원소가 크기 순으로 정렬되어 있다는 큰 장점이 있다. 
      * 즉, 정렬되어 있다 보니**lower_bound** 같은걸 **logN**에 바로 구할 수 있다.

```java
// 1. HashSet
HashSet<String> hs = new HashSet<>();
hs.add("java");
System.out.println(hs.contains("java")); // true

// 2. HashMap
HashMap<String, Integer> hm = new HashMap<>();
hm.put("java", 0); // save => 기존 값이 있어도 덮어씌움
hm.get("java"); // load
// 키(="java")가 없으면 put으로 새로 생성
if (!hm.containsKey("java")) hm.put("java", 1); 
// 키(="java")가 있으면 해당 값 출력, 없으면 설정한 defalut값(=3) 출력
hm.getOrDefault("java", 3);
// 키가 있으면 1씩 증가시키는 응용방식!
hm.put("java", hm.getOrDefault("java", 0)+1);
// keySet() 함수로 맵 순회
for(String key : hm.keySet()) { 
	hm.get(key); // 순서가 보장되지 않음
}
       
// 3. LinkdedHashMap => 값들 HashMap이라 동일하다 가정
for(String key : hm.keySet()) {				
	lhm.get(key); // 순서가 보장
}
```

<br>

**keySet, entrySet 를 적절히 사용해야 최적화 할 수 있다.**

* key만 순회할 때 keySet 은 적절하다. 단, value도 필요할 때는??
* value도 필요할 때는 entrySet 이 적절하다.
  * `hm.get(key)` 를 하는 순간 또 keySet을 찾는 과정을 반복하기 때문이다. (자세한 내용을 아래링크)
  * **참고 링크 : [entrySet 사용이유](https://codevang.tistory.com/289)**

```java
// 비권장
for (String key : hm.keySet()) { // keySet을 하고
    if (hm.get(key) != 0) { // hm.get(key)를 하는것은 비권장
        answer = key;
    }
}

// 권장
for (Entry<String, Integer> entry : hm.entrySet()) {
    if (entry.getValue() > 0) {
        answer = entry.getKey();
        break;
    }
}
```

<br><br>

## 이진 검색, 레드-블랙 트리(BST, RBT)

**자바의 `TreeSet, TreeMap` 은 이진 검색 트리 + 자가 균형을 이루는 RBT 자료 구조로 정의되어서 제공한다.**

**참고로 BST를 구현을 해야할 것 같을때는 배열로는 구현X, 차라리 class로 구현하자.**

**해시에서 비교를 했기 때문에 간단히 설명**

* TreeSet : 중복된 데이터의 저장을 허용하지 않으며, 정렬된 위치에 저장하므로 저장 순서를 유지하지도 않는다.
  * 여전히 get메소드 없고, iterator를 사용
* TreeMap : TreeSet과 동일한데 추가로 key, value 쌍으로 저장된다.

* prev, next나 lower_bound 이런게 필요할 때 유용
* 개념 정리 게시글 참고 : [고급트리 개념](https://bh946.github.io/algorithm/(%EA%B3%A0%EA%B8%89%EA%B0%9C%EB%85%90)-%EA%B3%A0%EA%B8%89-%ED%8A%B8%EB%A6%AC(BST,-RBT,-Splay,-OST,-Range,-Interval,-Sgement)/)

```java
// 1. TreeSet
TreeSet<Integer> ts = new TreeSet<>();
ts.add(2);
ts.add(4);
ts.add(3);
ts.add(5);
ts.add(1);
ts.add(1); // 중복 x
System.out.println(ts.contains(0));	// true
System.out.println(ts.size()); // 5
System.out.println(ts.headSet(3)); //처음 ~ 3 전까지
System.out.println(ts.tailSet(3)); //3 ~ 끝까지
System.out.println(ts.subSet(3, 5)); //3 ~ 5 전까지
Iterator<Integer> iter = ts.iterator();
while(iter.hasNext()) {
    System.out.print(iter.next());
}
System.out.println();

// 2. TreeMap
TreeMap<String, Integer> tm = new TreeMap<>();
tm.put("TreeMap1", 10);
tm.put("TreeMap2", 20);
tm.put("TreeMap3", 30);
System.out.println(tm.get("TreeMap3")); //30
System.out.println(tm.containsKey("TreeMap3"));	//true
System.out.println(tm.size()); // 3
System.out.println(tm.firstKey()); //처음 Key값
System.out.println(tm.lastKey());  //마지막 Key값
System.out.println(tm.firstEntry()); //처음 Entry값
System.out.println(tm.lastEntry()); //마지막 Entry값
System.out.println(tm.headMap("TreeMap2")); //처음 ~ TreeMap2 전까지
System.out.println(tm.tailMap("TreeMap2")); //TreeMap2 ~ 끝까지
System.out.println(tm.subMap("TreeMap1", "TreeMap3")); //TreeMap1 ~ TreeMap2 까지
```

<br><br>

## 우선순위 큐

**우선순위 큐는 pop을 할 때 가장 먼저 들어온 원소가 나오는 대신 우선순위가 가장 높은 원소가 나오는 큐이다. **  
**힙은 완전 이진트리로 구성된 자료구조 이다.**

**힙(최대 힙, 최소 힙) 자료구조를 사용해서 만든 우선순위 큐**

* 원소 추가 - O(logN)
* 우선순위 높은 원소 확인 - O(1)
* 우선순위 높은 원소 제거 - O(logN)
* **배열 자료구조 + 우선순위 큐의 경우 => 순서대로 O(1), O(N), O(N)**
* `TreeSet` 도 최소값과 최대값을 빼고, 원소 추가하고 다 가능하고 복잡도도 심지어 동일하다.
  * 그래도 굳이 `priority_queue` 를 사용하는 이유는 같은 O(logN)이라고 해도 `TreeSet` 보다 빠르고, 공간도 적게 차지한다.
  * **따라서 `priority_queue` 의 기능만 딱 필요할 경우엔 `TreeSet`이 아닌 `priority_queue` 를 사용해주자!**

<br>

**힙을 배열로 나타낼 때**

* x번지의 왼쪽, 오른쪽 자식 : 2x, 2x+1
* x번지의 부모 : x/2

<br>

**최소 힙, 최대 힙 특징**

* 최소 힙 : 부모가 자식보다 작음
* 최대 힙 : 부모가 자식보다 큼

<br>

**`PriorityQueue` 제공!!**

```java
PriorityQueue<Integer> pq = new PriorityQueue<Integer>(); // 최소힙
PriorityQueue<Integer> pq = new PriorityQueue<Integer>(Collections.reverseOrder()); // 최대힙

pq.add(3);
pq.remove();
pq.peek(); // root
```

<br>

**우선순위 비교를 직접 커스텀 할 경우!!**

```java
public static void main(String[] args) throws IOException {
    PriorityQueue<Pair> pq=new PriorityQueue<>(Pair::compareTo);
    pq.add(new Pair(1,2));
    pq.add(new Pair(1,1));
    pq.add(new Pair(2,3));
    pq.add(new Pair(2,1));

    while(!pq.isEmpty()){
        Pair p=pq.peek(); // root
        System.out.println(p.first+" "+p.second);
        pq.remove();
    }
}

static class Pair {
    int first;
    int second;

    public Pair(int first, int second) {
        this.first = first;
        this.second = second;
    }

    // Pair 클래스 내에 비교 함수!!
    public int compareTo(Pair p) {
        if(this.second < p.second) {
            return -1; // 음수는 오름차순
        }
        else if(this.second == p.second) {
            if(this.first < p.first) {
                return -1;
            }
        }
        return 1;
    }
}
```

<br><br>

## 그래프

**그래프는 인접행렬과 인접리스트로 표현할 수 있다.**

* **보통 인접리스트 사용이 많고, E가 V^2보다 훨씬 작을 때(sparse=희소) 사용한다.**
* **`모든 간선 길이가 동일` 하면 "BFS"로 거리를 구할 수 있고, `길이가 다르다면` "플로이드, 다익스트라" 알고리즘을 활용해야 한다.**

<br>

### 1. 그래프의 BFS, DFS 순회

**이미 BFS, DFS는 정리했었고 여기선 추가 보충을 위해 `"인접리스트"` 형태로 접근하는 것과 `DFS 재귀` 방식을 소개한다.**

```java
// 연결 그래프 BFS 순회
// 만약, 노드들 중에 연결 그래프 아닌것도 순회하고 싶으면 그냥 모든 노드를 돌리면 됨
// 즉, 아래 코드를 전체 for문으로 감싸고, 1 대신 for문의 i로 변경
static List<Integer>[] inArr = new ArrayList[10];
static boolean[] visited = new boolean[10];
static void bfs() {
    for(int i = 0 ;i<10;i++){
        inArr[i] = new ArrayList<Integer>();
        inArr[i].add((i+1)%10);
    } // 임의로 "인접리스트" 형태로 값 삽입
	Queue<Integer> qu = new LinkedList<>();
    qu.add(0);
    visited[0] = true;
	while(!qu.isEmpty()) {
		int cur = qu.peek();
		qu.remove();
		System.out.println(cur);
		for (int nxt : inArr[cur]) {
			if (visited[nxt]) continue;
			qu.add(nxt);
			visited[nxt] = true;
		}
	}
}

// DFS 재귀 (비재귀는 위 BFS에서 큐->스택)
static List<Integer>[] inArr = new ArrayList[10];
static boolean[] visited = new boolean[10];
static void dfs(int cur) {
    visited[cur] = true;
    System.out.println(cur);
    for (int nxt : inArr[cur]) {
        if(visited[nxt]) continue;
        dfs(nxt);
    }
}

// 항상 작성하던 DFS 재귀 방식 (최대 depth(깊이)를 지정했었음)
// 장점 : 원하는 개수만큼 만 접근이 가능
static List<Integer>[] inArr = new ArrayList[10];
static void dfs(int depth, List<Integer> val) {
	if (depth == 4) { // base condition
		result = 1;
		return;
	}
	
	for (int nxt : val) {
		if (visited[nxt]) continue;
        visited[nxt] = true;
        outArr[depth] = nxt; // 출력할 값 기록
        dfs(depth + 1, inArr[nxt]);
        // visited[nxt] = false; // backtracking
	}
}
```

<br><br>

## 트리

**트리는 무방향이고 사이클이 없는 연결 그래프이다.**

* **트리의 순회방식 - BFS&DFS 순회, 이진 트리의 순회**
* **여러가지 트리 - Segment**
* 참고로 **BST, RBT**는 위에서 이미 정리 그리고 **우선순위 큐에 사용한 힙**도 이진트리임
  * **좀 더 다양한 트리(Splay, OST, Range, Interval)는  [고급트리 개념](https://bh946.github.io/algorithm/(%EA%B3%A0%EA%B8%89%EA%B0%9C%EB%85%90)-%EA%B3%A0%EA%B8%89-%ED%8A%B8%EB%A6%AC(BST,-RBT,-Splay,-OST,-Range,-Interval,-Sgement)/) 에서 참고** 

<br>

### 1. 트리의 BFS, DFS 순회

* 트리를 **BFS** 할 때 root부터 하므로 임의의 노드에서 그 노드의 부모는 이미 방문한거고, 자식들만 방문을 안한 상태인 것이다.
* 따라서 따로 **visited배열이 필요없이 p배열(부모)** 을 알고 있으면 된다.

```java
// DFS는 큐->스택 바꾸면 동일하게 동작
static List<Integer>[] inArr = new ArrayList[10];
static int[] p = new int[10]; // 부모 배열
static int[] depth = new int[10]; // 트리 깊이 기록
static void bfs(int root) {
	Queue<Integer> qu = new LinkedList<>();
    qu.add(root);
    while(!qu.isEmpty()) {
        int cur = qu.peek();
        qu.remove();
		System.out.println(cur);
        for (int nxt : inArr[cur]) {
            if(p[cur] == nxt) continue; // 부모는 방문한 상태라서 continue
            qu.add(nxt);
            p[nxt] = cur; // parent 기록
            depth[nxt] = depth[cur] + 1; // dist배열 채우듯이 동일
        }
    }
}
```

<br>

### 2. 이진 트리의 순회

* **레벨 순회(=bfs(root))** : 높이 순서대로 방문한다.
  * 기존이랑 **동일**. root를 시작점으로 **bfs** 돌리면 높이 순서대로 위에서부터 차례로 순회한다.
* **전위, 중위, 후위 순회**
  * 전위 : 위 -> 왼 -> 오
  * 중위 : 왼 -> 위 -> 오
  * 후위 : 왼 -> 오 -> 위
* **구현 쉬워서 코드 생략**

<br>

### 3. Segment Tree(구간합)

**여러개의 데이터가 연속으로 있을때 `배열` 에서는 그 구간의 합을 구할때 복잡도가 N이 걸리는데, 이걸 `세그먼트 트리` 를 이용해서 logN으로 개선시키려는 목적**

* 리프 노드: 배열의 연속된 값 그 자체
* 내부 노드: 왼쪽 자식과 오른쪽 자식의 합
* **아래 그림을 꼭 기억하면 충분히 segmentBuild 함수정도는 만들 수 있을 것이다.**
  * **재귀를 너무 이해하려고 하는것 보다 아래 상태공간 트리를 재귀함수로 짜려고 노력하는게 중요하다.**


![image-20230526215318317](/images/2023-01-11-(백준_필수3)알고리즘 템플릿 - java/image-20230526215318317.png)

<br>

```java
/**
 * BOJ 2042
 * 구간 합 구하는 함수 : segmentSum
 * 트리의 노드 수정하는 함수 : segmentUpdate
 * 세그먼트 트리 만드는 함수 : segmentBuild
 */
static int N, M, K;
static long[] inArr;
static long[] outArr;

// node(outArr)가 담당하는 구간 : start, end
public static long segmentBuild(int start, int end, int node) {
    if(start == end) { // base condition
        outArr[node] = inArr[start];
        return outArr[node];
    }

    int mid = (start+end) / 2; // 왼, 오 구간 나누기
    outArr[node] = segmentBuild(start, mid, node*2) + segmentBuild(mid+1, end, node*2+1);
    return outArr[node];
}

// 구하는 합 구간 : left, right
public static long segmentSum(int start, int end, int left, int right, int node) {
    // 1. 겹치지 않는 경우 => base condition
    if((left < start && right < start) || (left > end && right > end)) return 0;

    // 2. 완전히 포함되는 경우 => base condition
    if(left <= start && right >= end) return outArr[node];

    // 3. 나머지 경우(자식 트리 탐색) => 왼, 오 탐색
    int mid = (start+end) / 2;
    return segmentSum(start, mid, left, right, node*2) + segmentSum(mid+1, end, left, right, node*2+1);
}

// 수정할 노드 인덱스 : idx, 수정할 값 : dif
public static void segmentUpdate(int start, int end, int idx, long dif, int node) {
    // 1. 겹치치 않는 경우
    if((start < idx && end < idx) || (start > idx && end > idx)) return;
    // 2. 완전히 포함되는 경우
    if(start <= idx && end >= idx) outArr[node] += dif;

    // base condition (무한루프 안빠지게)
    if(start==end) return;
    // 3. 나머지 경우(자식 트리 탐색)
    int mid = (start+end) /2;
    segmentUpdate(start, mid, idx, dif, node*2);
    segmentUpdate(mid+1, end, idx, dif, node*2+1);
}

public static void main(String[] args) throws IOException {
    // input
    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
    StringTokenizer stk = new StringTokenizer(br.readLine(), " ");
    N = Integer.parseInt(stk.nextToken());
    M = Integer.parseInt(stk.nextToken());
    K = Integer.parseInt(stk.nextToken());
    inArr = new long[N];
    outArr = new long[N*4];
    for(int i = 0 ;i <N; i++){
        inArr[i] = Long.parseLong(br.readLine());
    }
    // run & output
    StringBuilder sb = new StringBuilder();
    segmentBuild(0, N-1, 1); // 인덱스 1부터 저장해야 인덱스 연산 편안
    for(int i = 0 ; i<M+K; i++){
        stk = new StringTokenizer(br.readLine(), " ");
        int a = Integer.parseInt(stk.nextToken());
        int b = Integer.parseInt(stk.nextToken());
        long c = Long.parseLong(stk.nextToken()); // type 조심

        if(a==1) {
            // segmentUpdate
            // b번째 수에 c를 더하는게 아닌,
            // b번째 수를 c로 바꿔야 하는건 `c-inArr[b-1]` 를 더해야 한다는 의미이다.
            segmentUpdate(0, N-1, b-1, c-inArr[b-1], 1);
            inArr[b-1] = c; // b번째 수를 값 c로 변환
        } else{ // a==2
            // segmentSum
            sb.append(segmentSum(0, N-1, b-1, (int)c-1, 1)).append('\n');
        }
    }
    System.out.println(sb);
}
```

<br><br>

## 위상 정렬

**위상 정렬(Topological Sort) : 방향 그래프에서 간선으로 주어진 정점 간 선후관계를 위배하지 않도록 나열하는 정렬**

**BFS(큐)로도 풀이가 가능하고 DFS로도 풀이가 가능한데 둘다 보여주겠다.**

* 단순히 부모 자식관계를 위배하지만 않으면 되므로 생각보다 간단한 정렬이다.
* indegree가 0인게 제일 부모이며 최외각에 존재하는건 자명하다.

![image-20230506001732475](/images/2023-01-03-(백준_필수3)알고리즘 템플릿 - cpp/image-20230506001732475.png)

```java
// BOJ 2252

public static int N, M;
public static List<Integer>[] inArr; // input (graph)
public static List<Integer> outArr = new ArrayList<>(); // output
public static int[] deg = new int[32005]; // 0 init

public static void main(String[] args) throws IOException {
    // input
    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
    StringTokenizer stk = new StringTokenizer(br.readLine(), " ");
    N = Integer.parseInt(stk.nextToken());
    M = Integer.parseInt(stk.nextToken());
    inArr = new ArrayList[N+5];
    for(int i = 1 ; i<=N;i++) inArr[i] = new ArrayList<>(); // init
    for(int i = 0 ;i<M;i++){
        stk = new StringTokenizer(br.readLine(), " ");
        int a = Integer.parseInt(stk.nextToken());
        int b = Integer.parseInt(stk.nextToken());
        inArr[a].add(b); // graph (방향 그래프)
        deg[b] += 1; // indegree
    }

    // run
    Queue<Integer> qu = new LinkedList<>();
    for(int i = 1; i<=N; i++)
        if(deg[i]==0) qu.add(i); // indegree 0 이 젤 최외각
    while(!qu.isEmpty()) {
        int cur = qu.peek();
        qu.remove();
        outArr.add(cur);
        for(int nxt : inArr[cur]) {
            deg[nxt]--;
            if(deg[nxt] == 0) qu.add(nxt);
        }
    }

    // output
    StringBuilder sb = new StringBuilder();
    for(int num : outArr) sb.append(num).append(' ');
    System.out.println(sb);

    if(outArr.size() != N)
        System.out.println("cycle exists");
}
```

<br>

**SCC(Strongly Connected Component) 도 추가로 BOJ 문제 하나 풀어보겠다.**

* **SCC 개념익히기 좋은 글 : [네이버 블로그](https://m.blog.naver.com/PostView.naver?blogId=babobigi&logNo=221880301130&referrerCode=0&searchKeyword=SCC)**
* **출력때 TreeMap 활용**

```java
/**
 * BOJ 2150
 * 1. G를 DFS로 순회하면서 finish time을 구한다 => 위상정렬 구하는 또다른 방식중 하나
 * 2. G의 에지 방향을 반대로 한 𝐺^𝑇 (transpose of G)에서 DFS를 이용해 순회
 * => 단, 앞에서 구한 finish time의 역순을 고려하면서 DFS 적용
 * 3. 𝐺^𝑇 에서 도달가능한 것들의 집합은 SCC가 된다
*/
static int V, E;
static List<Integer>[] inArr = new ArrayList[10005];
static List<Integer>[] reArr = new ArrayList[10005];
static List<Integer>[] outArr = new ArrayList[10005];
static int[] f = new int[10005]; // finish time
static boolean[] visited = new boolean[10005];

public static void main(String[] args) throws IOException {
    for(int i = 0 ; i<10005; i++) {
        inArr[i] = new ArrayList<>();
        reArr[i] = new ArrayList<>();
        outArr[i] = new ArrayList<>();
    }
    // input
    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
    StringTokenizer stk = new StringTokenizer(br.readLine(), " ");
    V = Integer.parseInt(stk.nextToken());
    E = Integer.parseInt(stk.nextToken());
    for(int i = 0 ; i<E;i++) {
        stk = new StringTokenizer(br.readLine(), " ");
        int a = Integer.parseInt(stk.nextToken());
        int b = Integer.parseInt(stk.nextToken());
        inArr[a].add(b);
        reArr[b].add(a);
    }

    // run
    // 1. Graph를 DFS로 순회하면서 finish time을 구한다
    Stack<Integer> st = new Stack<>();
    for(int i = 1; i<=V; i++) {
        if(!visited[i]) {
            dfs(i, st);
        }
    }
    Arrays.fill(visited, false);
    int SCCNum = 0;

    // 2. G의 에지 방향을 반대로 한 𝐺^𝑇 (transpose of G)에서 DFS를 이용해 순회
    // => 단, 앞에서 구한 finish time의 역순을 고려하면서 DFS 적용 (역순=내림차순 고려)
    while(!st.isEmpty()) {
        int cur = st.peek(); st.pop();

        if(visited[cur]) continue; // 이미 SCC 그룹에 속해 있다는 것
        redfs(cur, SCCNum);
        SCCNum++;
    }

    // output
    StringBuilder sb = new StringBuilder();
    sb.append(SCCNum).append('\n');

    TreeMap<Integer, Integer> map = new TreeMap<>(); // key를 기준으로 오름차순 정렬.
    for(int i = 0 ; i<SCCNum; i++) {
        Collections.sort(outArr[i]);
        map.put(outArr[i].get(0), i); // key : SCC 그룹의 첫번째 항, value : 인덱스.
    }

    // map의 value를 이용하여 => RBT 특성상 정렬되었기 때문
    // 첫번째 항이 작은 순서대로 출력. => 문제에서 출력 조건때문에!
    map.keySet().forEach(key -> {
        int cur = map.get(key);

        for (int nxt : outArr[cur]) {
            sb.append(nxt + " ");
        }
        sb.append("-1\n");
    });
    System.out.println(sb);
}

public static void dfs (int depth, Stack st) {
    visited[depth] = true;

    for(int nxt : inArr[depth]) {
        if(!visited[nxt]) {
            dfs(nxt, st);
        }
    }
    st.add(depth); // 탐색 종료시점
}

public static void redfs(int depth, int SCCNum) {
    visited[depth] = true;
    // 3. 𝐺^𝑇 에서 도달가능한 것들의 집합은 SCC가 된다
    outArr[SCCNum].add(depth);

    for(int nxt : reArr[depth]) {
        if(!visited[nxt]) {
            redfs(nxt, SCCNum);
        }
    }
}
```

<br><br>

## 최소 신장 트리(MST)

* **바킹독 : https://blog.encrypted.gg/1024**
* **예전에 정리한 개념글 : [MST-Prim,Kruskal](https://bh946.github.io/algorithm/(%EA%B0%9C%EB%85%90)-Greedy-Algorithm(%ED%83%90%EC%9A%95%EC%A0%81%EC%9D%B8-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98)/#mst%EC%B5%9C%EC%86%8C%EB%B9%84%EC%9A%A9-%EC%8B%A0%EC%9E%A5%ED%8A%B8%EB%A6%AC)**

<br>

**크루스칼, 프림 알고리즘이 대표적**

**크루스칼 알고리즘은 Union Find라는 알고리즘을 선행학습 하고 아래 코드를 이해할 것.**

![image-20230506012547858](/images/2023-01-03-(백준_필수3)알고리즘 템플릿 - cpp/image-20230506012547858.png)

<br>

```java
// BOJ 1197
/**
MST - kruskal
1. 비내림차순 정렬(가중치 기준) => 제일 작은 가중치부터 선택하려고 하는것
2. Union Find(=합집합 찾기) 이용 : 같은 그래프에 속하는지를 판별하기 위함
*/
public static int[] p = new int[10005]; // 부모기록 배열(-1 init)
static int find(int x) {
    if(p[x] < 0) return x; // 부모가 없는경우 자신이 부모
    return p[x] = find(p[x]); // 부모 찾을때 까지 재귀
}
static boolean isUnion(int u, int v) {
    u = find(u); v = find(v); // u,v 노드의 root(각 집합에서의 root를 찾는것)
    if(u==v) return true;
    if(p[u] > p[v]) {
        int temp = u;
        u=v; v=temp;
    } // swap(u,v)
    p[u] += p[v]; // 자식이 많은쪽에 merge => 여기선 p[u]로
    p[v] = u; // 부모 기록
    return false;
}

public static void main(String[] args) throws IOException {
    // input
    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
    StringTokenizer stk = new StringTokenizer(br.readLine(), " ");
    int V = Integer.parseInt(stk.nextToken());
    int E = Integer.parseInt(stk.nextToken());
    List<Edge> inArr = new ArrayList<>(E); // 또는 그냥 배열로 고고
    for(int i = 0;i<E;i++){
        stk = new StringTokenizer(br.readLine(), " ");
        int a = Integer.parseInt(stk.nextToken());
        int b = Integer.parseInt(stk.nextToken());
        int c = Integer.parseInt(stk.nextToken()); // 가중치
        inArr.add(new Edge(a,b,c));
    }

    // run
    // 1. 비내림차순 정렬(가중치 기준)
    ObjectSort ob = new ObjectSort();
    Collections.sort(inArr, ob);

    // 2. Union Find(=합집합 찾기) 이용 : 같은 그래프에 속하는지를 판별하는 알고리즘
    Arrays.fill(p, -1); // init
    int result = 0;
    int cnt = 0;
    for(Edge edge : inArr){
        if(isUnion(edge.a, edge.b)) continue;
        result += edge.c;
        cnt++;
        if(cnt == V-1) break; // 종료 시점 (모든 노드 방문한 경우)
    }

    // output
    System.out.println(result);
}
static class Edge {
    int a;
    int b;
    int c;
    public Edge(int a, int b, int c) {
        this.a = a;
        this.b = b;
        this.c = c;
    }
}
static class ObjectSort implements Comparator<Edge> {
    @Override
    public int compare(Edge o1, Edge o2) {
        return o1.c - o2.c; // 오름차순
    }
}
```

<br>

**프림 알고리즘은 우선순위 큐를 이용해서 구현을 하는데, 구현이 좀 복잡하다. 따라서 pass**

<br><br>

## 최단 경로 트리

* **바킹독 : https://blog.encrypted.gg/1035, https://blog.encrypted.gg/1037**
* **예전에 정리한 개념글 : [Floyd](https://bh946.github.io/algorithm/(%EA%B0%9C%EB%85%90)-Dynamic_Programming(%EB%8F%99%EC%A0%81%EA%B3%84%ED%9A%8D%EB%B2%95)/#%EC%B5%9C%EB%8B%A8%EA%B1%B0%EB%A6%ACfloyd), [Dijkstra](https://bh946.github.io/algorithm/(%EA%B0%9C%EB%85%90)-Greedy-Algorithm(%ED%83%90%EC%9A%95%EC%A0%81%EC%9D%B8-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98)/#dijkstra%EB%8B%A4%EC%9D%B5%EC%8A%A4%ED%8A%B8%EB%9D%BC)**
* **유형**
  * 거리가 일정??? `BFS` 로 최단 거리 구하기
  * 거리가 다르다??? `플로이드(모든정점-n^3) or 다익스트라(하나의정점-n^2)` 로 구하기
    * `다익스트라` 의 경우 가중치 음수는 사용 못하는데, 이땐 `벨만포드` 알고리즘이라는 것을 사용한다. (필요시 공부해 볼 것)
    * **중요한점**  
      `플로이드` 는 모든 정점에서 모든 정점과의 최단 경로를 구하고,  
      `다익스트라` 는 하나의 정점에서 모든 정점과의 최단 경로를 구한다.
      * 이때, `다익스트라` 는 하나의 정점에서 하나의 정점과의 최단 경로를 구할 수 있다는 점도 이해하자. 
      * 즉, 꼭 모든 정점과의 경로로만 생각하지말고, A->B 처럼 하나의 정점에서 하나의 정점의 최소경로로도 생각 할 수 있다고 이해하라는 것


<br>

**`플로이드 알고리즘`은 모든 정점 쌍 사이의 최단 경로를 구하는 알고리즘이라 O(n<sup>3</sup>)의 큰 복잡도를 가진다.  
다만, 구현이 3중 for문으로 간단히 할 수 있으며 n이 1000정도면 이 알고리즘을 써도 된다.**

* 최단 거리 테이블(2차원) 이 채워진다 => 코드보면 d배열 관련인데 생각보다 쉬운 로직!
* 근데, 경로까지 구하고싶으면 테이블 하나 더 만들어서 기록해놔야 한다 => nxt배열에 기록

![image-20230506013350391](/images/2023-01-03-(백준_필수3)알고리즘 템플릿 - cpp/image-20230506013350391.png)

![image-20230506013359812](/images/2023-01-03-(백준_필수3)알고리즘 템플릿 - cpp/image-20230506013359812.png)

<br>

```java
// BOJ 11780
// n이 100이라 플로이드 가능
public static int[][] d = new int[105][105];
public static int[][] p = new int[105][105];
public static int n, m;

public static void main(String[] args) throws IOException {
    // input => 1 4 2, 1 4 1 처럼 들어올 수 도 있으니 처음부터 d 에 min 값으로 갱신하자.
    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
    StringTokenizer stk = new StringTokenizer(br.readLine());
    n = Integer.parseInt(stk.nextToken());
    stk = new StringTokenizer(br.readLine());
    m = Integer.parseInt(stk.nextToken());
    for(int i = 1 ; i<=n ;i++) {
        Arrays.fill(d[i], 10000000);
    }
    for(int i = 1; i<=m; i++){
        stk = new StringTokenizer(br.readLine(), " ");
        int a = Integer.parseInt(stk.nextToken());
        int b = Integer.parseInt(stk.nextToken());
        int c = Integer.parseInt(stk.nextToken());
        d[a][b] = Math.min(d[a][b], c);
        p[a][b] = b; // 경유 경로 기록
    }
    for(int i = 1; i<=n;i++) d[i][i] = 0; // 자기 자신의 경로는 당연히 비용 0

    // run => DP 방식(i,j,k만 잘이해하면 생각보다 간단)
    for(int k = 1; k<=n; k++) { // k를 경유하는 곳이라 생각하면 됨.
        for(int i = 1; i<=n; i++) { // i->j 를 가는 경로 비용을 구하는것
            for(int j = 1; j<=n; j++) {
                if(d[i][k]+d[k][j] < d[i][j]){
                    d[i][j] = Math.min(d[i][j], d[i][k]+d[k][j]);
                    p[i][j] = p[i][k]; // 경유 경로 기록
                }
            }
        }
    }

    // output => 출력이 여러개 있음.
    StringBuilder sb = new StringBuilder(); // 가중치 출력
    for(int i = 1 ; i<=n;i++){
        for(int j = 1; j<=n; j++){
            if(d[i][j] == 10000000) sb.append(0).append(' ');
            else sb.append(d[i][j]).append(' ');
        }
        sb.append('\n');
    }
    System.out.print(sb);

    for(int i = 1; i<=n; i++) {
        for(int j = 1; j<=n; j++) {
            sb = new StringBuilder(); // 경로 출력
            if(d[i][j] == 0 || d[i][j] == 10000000) {
                System.out.println(0);
                continue;
            }
            int st = i;
            int sizes = 1;
            while(st != j) { // 자기 자신 가리키는 순간 탈출
                sb.append(st).append(' ');
                st = p[st][j];
                sizes++;
            }
            sb.append(j);
            System.out.print(sizes);
            System.out.println(" "+sb);
        }
    }
}
```

<br>

**`다익스트라 알고리즘 `은 하나의 정점으로부터 다른 모든 정점까지의 최단 거리를 구하는 알고리즘이므로 복잡도는 플로이드보다 한단계 작은 O(n<sup>2</sup>) 이다.**

* 참고 : 가중치가 음의 값이 있으면 이 알고리즘 사용 불가
* 동작원리는 간단한데 한 정점에서 갈 수 있는 최단 거리 정점을 택하면서 갱신해나가면 된다.
* 여기서 개선된 알고리즘이 있는데 우선순위 큐를 활용한 알고리즘이다. 이 로직을 기억
  * 우선순위 큐에 거리를 다 넣어둔다음 매번 최소인걸 선택하는 로직
  * 물론 경로까지 구하는 방법은 플로이드 알고리즘 때와 유사

![image-20230506014449754](/images/2023-01-03-(백준_필수3)알고리즘 템플릿 - cpp/image-20230506014449754.png)

![image-20230506015237505](/images/2023-01-03-(백준_필수3)알고리즘 템플릿 - cpp/image-20230506015237505.png)

![image-20230506015246272](/images/2023-01-03-(백준_필수3)알고리즘 템플릿 - cpp/image-20230506015246272.png)

```java
/**
 * BOJ 11779
 * 참고 : 다익스트라 특성상 경로를 여러개 구할 수 있기 때문에, 어떤 경로든 백준에서 정답 처리한다.
 */
static int[] d = new int[1005]; // 최단 거리 테이블
static int[] pre = new int[1005]; // 이전 경로 기록

public static void main(String[] args) throws IOException {
    Arrays.fill(d, 100000000);
    List<Pair>[] inArr = new ArrayList[1005];
    for(int i = 0 ; i<1005; i++) inArr[i] = new ArrayList<>();
    PriorityQueue<Pair> pq = new PriorityQueue<>(Pair::compareTo); // 최소힙

    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
    StringTokenizer stk = new StringTokenizer(br.readLine());
    int N = Integer.parseInt(stk.nextToken());
    stk = new StringTokenizer(br.readLine());
    int M = Integer.parseInt(stk.nextToken());
    for(int i = 0 ; i<M;i++) {
        stk = new StringTokenizer(br.readLine(), " ");
        int u = Integer.parseInt(stk.nextToken());
        int v = Integer.parseInt(stk.nextToken());
        int w = Integer.parseInt(stk.nextToken());
        inArr[u].add(new Pair(v, w));
    }
    stk = new StringTokenizer(br.readLine(), " ");
    int st = Integer.parseInt(stk.nextToken()); // 시작 노드
    int en = Integer.parseInt(stk.nextToken()); // 도착 노드
    // input 끝

    // run
    d[st] = 0; // 시작 노드는 가중치 0
    pq.add(new Pair(st, d[st])); // 도착노드, 가중치
    while(!pq.isEmpty()) {
        Pair cur = pq.peek(); pq.remove();
        // 예로 시작 노드 d[st]가 0인지 먼저 확인
        // => 일치하지 않으면 큐에있는 cur 은 최단 거리가 아닌 원소라 continue
        if(d[cur.v] != cur.w) continue;
        for(Pair nxt : inArr[cur.v]) {
            if(d[nxt.v] <= d[cur.v]+nxt.w) continue; // 거리 비교
            d[nxt.v] = d[cur.v]+nxt.w;
            pq.add(new Pair(nxt.v, d[nxt.v]));
            pre[nxt.v] = cur.v; // 이전 경로 기록
        }
    }

    // output
    System.out.println(d[en]); // 최소 비용
    // 경로 구해서 출력
    List<Integer> path = new ArrayList<>();
    int cur = en;
    while(cur != st) {
        path.add(cur);
        cur = pre[cur];
    }
    path.add(cur);
    System.out.println(path.size());
    StringBuilder sb = new StringBuilder();
    for(int i = path.size()-1; i>=0; i--) {
        sb.append(path.get(i)).append(' ');
    }
    System.out.println(sb);
}
static class Pair {
    private int v; // 도착노드
    private int w; // 가중치
    public Pair(int v, int w) {
        this.v = v;
        this.w = w;
    }
    // 우선순위 큐 비교 직접 커스텀
    public int compareTo(Pair p) {
        if(this.w < p.w) {
            return -1;
        }
        return 1;
    }
}
```

<br><br>

## 컴퓨터그래픽스 관련

**CCW, 교차여부, 다각형 면적, 다각형 포함, 볼록 껍질(외피=Convex Hull), 평면 소거법(직사각형 합집합=Plane Sweeping) 관련**

* 개념 정리 게시글 참고 : [컴퓨터그래픽스 개념](https://bh946.github.io/algorithm/(%EA%B3%A0%EA%B8%89%EA%B0%9C%EB%85%90)-%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B7%B8%EB%9E%98%ED%94%BD%EC%8A%A4(%EA%B8%B0%ED%95%98%EC%97%B0%EC%82%B0,-%EB%8B%A4%EA%B0%81%ED%98%95-%EB%A9%B4%EC%A0%81%EA%B3%BC-%ED%8F%AC%ED%95%A8,-Convex-Hull,-Plane-Sweeping)/)

<br>

### 1. 기본 기하 연산(between, interaction)

* **between, interaction 함수만 보면 충분!!**

```java
/*
EX : BOJ 17387
ccw 함수(cw : counter clockwise = 시계방향)
direction 함수 : 세점의 회전방향 검사에 따라서 1,-1,0 반환(오른손 활용)
between 함수 : 점 c가 선분 (a,b)에 위치하는가 검사
interactionProp 함수 : 교차여부를 구하는데, 선분의 끝점이 교차점 허용하지 않는 경우
interaction 함수 : 교차여부를 구하는데, 선분의 끝점이 교차점 허용하는 경우

자료형 왠만하면 long long 쓰자
*/
public static List<Point> inArr = new ArrayList<>();
public static long ccw(Point a, Point b, Point c) {
    // 깊은 복제
    Point a1 = new Point(a.x, a.y);
    Point b1 = new Point(b.x, b.y);
    Point c1 = new Point(c.x, c.y);
    // 원점 이동
    a1.x -= c1.x;
    a1.y -= c1.y;
    b1.x -= c1.x;
    b1.y -= c1.y;
    // det(행렬식) 계산
    return a1.x*b1.y-a1.y*b1.x;
}

public static int direction(Point a, Point b, Point c) {
    // 좌 : 1, 우 : -1, 일 : 0
    if(ccw(a,b,c) > 0) return 1;
    if(ccw(a,b,c) < 0) return -1;
    return 0; // ccw(a,b,c)==0
}

// 점 c가 a,b직선 상에 존재하는지 판별함수
public static boolean between(Point a, Point b, Point c) {
    // 1. 일직선 상에 존재하나 먼저 확인
    if (ccw(a, b, c) != 0) return false;
    else {
        // 2. 수직 여부 확인 후 범위제한
        if (a.x == b.x) {
            if ((c.y >= a.y && c.y <= b.y) || (c.y >= b.y && c.y <= a.y)) return true;
        }
        else {
            if ((c.x >= a.x && c.x <= b.x) || (c.x >= b.x && c.x <= a.x)) return true;
        }
        return false;
    }
}

// 추가조건 : 교차점 포함(끝 점이 교차하는 그런것들 다 포함)
public static int interaction(Point a, Point b, Point c, Point d) {
    // (a,b,c)*(a,b,d) ==-1 && (c,d,a)*(c,d,b)==-1 성립하면 교차
    // 추가조건 때문에 <=0로 판별
    if (direction(a, b, c) * direction(a, b, d) <= 0 && direction(c, d, a) * direction(c, d, b) <= 0) {
        // direction 함수는 방향만을 나타내기 때문에 만약 0인 경우 일직선상,
        // 두 직선이 서로 접하는지 범위제한을 줘서 판단할 필요가 있음(between 함수 활용)
        if (direction(a, b, c) * direction(a, b, d) == 0 && direction(c, d, a) * direction(c, d, b) == 0) {
            // 점 c또는 d가 a,b직선 상에 존재하나 판단
            // 점 a또는 b가 c,d직선 상에 존재하나 판단
            if (between(a, b, c) || between(a, b, d)|| between(c, d, a) || between(c, d, b))
                return 1;
            else
                return 0;
        }
        else
            return 1;
    }
    else
        return 0;
}

// <참고>
// 선분 교차 검사 (교차점 제외) => 선분 ab, cd
bool interactionProp(Point a, Point b, Point c, Point d) {
    // (a,b,c)*(a,b,d) ==-1 && (c,d,a)*(c,d,b)==-1 성립하면 교차
	return direction(a, b, c) * direction(a, b, d) < 0 && direction(c, d, a) * direction(c, d, b) < 0;
}

public static void main(String[] args) throws IOException {
    // input
    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
    StringTokenizer stk;
    for(int i = 0 ; i<2;i++){
        stk = new StringTokenizer(br.readLine(), " ");
        long x1 = Long.parseLong(stk.nextToken());
        long y1 = Long.parseLong(stk.nextToken());
        long x2 = Long.parseLong(stk.nextToken());
        long y2 = Long.parseLong(stk.nextToken());
        inArr.add(new Point(x1,y1)); // 직선 1개
        inArr.add(new Point(x2,y2)); // 직선 1개
    }
    // run & output
    System.out.println(interaction(inArr.get(0), inArr.get(1), inArr.get(2),inArr.get(3)));
}
static class Point {
    long x; long y;
    public Point(long x, long y) {
        this.x = x; this.y = y;
    }
}
```

<br>

### 2. 다각형 면적과 포함 계산

```java
/*
BOJ 2166
area 함수 : 다각형 면적 구하기
*/
public static List<Point> inArr = new ArrayList<>();

public static long ccw(Point a, Point b, Point c) {
    // 깊은 복제
    Point a1 = new Point(a.x, a.y);
    Point b1 = new Point(b.x, b.y);
    Point c1 = new Point(c.x, c.y);
    // 원점 이동
    a1.x -= c1.x;
    a1.y -= c1.y;
    b1.x -= c1.x;
    b1.y -= c1.y;
    // det(행렬식) 계산
    return a1.x*b1.y-a1.y*b1.x;
}

// 외적 전부 더하기
public static double area() {
    double ret = 0;
    int n = inArr.size(); // 다각형의 정점 개수
    for(int i = 1; i<n; i++) {
        int nxtI = (i+1) % n; // 마지막에 index n->0으로 바뀜
        ret+=ccw(inArr.get(i), inArr.get(nxtI), inArr.get(0)); // index 0 정점 기준 외적 구했음
    }
    return Math.abs(ret) / 2.0;
}

public static void main(String[] args) throws IOException {
    // input
    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
    StringTokenizer stk;
    int N = Integer.parseInt(br.readLine());
    for(int i = 0 ; i<N;i++){
        stk = new StringTokenizer(br.readLine(), " ");
        long a = Integer.parseInt(stk.nextToken());
        long b = Integer.parseInt(stk.nextToken());
        inArr.add(new Point(a, b));
    }

    // run & output4
    double result = Math.round(area()*10)/10.0; // 소수 둘째자리에서 반올림 (첫재 자리까지 표기)
    System.out.printf("%.1f", result); // 자바는 지수를 24E8 이런형태로 출력해서 printf 문을 사용
}
static class Point {
    long x; long y;
    public Point(long x, long y){
        this.x = x; this.y = y;
    }
}
```

<br>

```java
/**
BOJ 1688
insidePolygon 함수 : 다각형 포함 구하기
다각형 포함 문제 (교차점 홀수면 내부 포함 인정)
*/
public static List<Point> barrier = new ArrayList<>();
public static List<Point> friends = new ArrayList<>(); // 대연, 영훈, 범진

public static long ccw(Point a, Point b, Point c) {
    // 복제
    Point a1 = new Point(a.x, a.y);
    Point b1 = new Point(b.x, b.y);
    Point c1 = new Point(c.x, c.y);
    // 원점이동
    a1.x -= c1.x;
    a1.y -= c1.y;
    b1.x -= c1.x;
    b1.y -= c1.y;
    // det(행렬식) 계산
    return a1.x* b1.y- a1.y* b1.x;
}

// 점 c가 a,b직선 상에 존재하는지 판별함수
public static boolean between(Point a, Point b, Point c) {
    // 1. 일직선 상에 존재하나 먼저 확인
    if (ccw(a, b, c) != 0) return false;
    else {
        // 2. 수직 여부 확인 후 범위제한
        if(a.x == b.x) { // 세로선
            if((c.y>=a.y&&c.y<=b.y)||(c.y>=b.y&&c.y<=a.y)) return true;
        }else{ // 가로선
            if((c.x>=a.x&&c.x<=b.x)||(c.x>=b.x&&c.x<=a.x)) return true;
        }
        return false;
    }
}

public static boolean leftTurn(Point a, Point b, Point c) {
    if(ccw(a,b,c)>0) return true;
    return false;
}

public static boolean insidePolygon(int friIndex) {
    int crossing = 0; // 교차 홀수여야 내부라 판단
    int n = barrier.size();
    Point fri = friends.get(friIndex);
    for (int i = 0 ; i<n; i++){
        int iNxt = (i+1) % n;
        Point a = barrier.get(i);
        Point b = barrier.get(iNxt);
        // 1. 경계면인지 확인(여기선 경계면도 포함이라서 true 로)
        if(between(a,b,fri)) return true;
        // 2. 교차점 판별(범위 비교로 판단)
        if((a.y<fri.y && b.y>=fri.y&&leftTurn(a,b,fri)) ||
           (b.y<fri.y && a.y>=fri.y&&leftTurn(b,a,fri)))
            crossing++;
    }
    if(crossing%2!=0) return true;
    return false;
}

public static void main(String[] args) throws IOException {
    // input
    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
    StringTokenizer stk;
    int N = Integer.parseInt(br.readLine());
    for(int i = 0 ; i<N; i++) {
        stk = new StringTokenizer(br.readLine(), " ");
        long a = Long.parseLong(stk.nextToken());
        long b = Long.parseLong(stk.nextToken());
        barrier.add(new Point(a,b));
    }
    for(int i = 0 ; i<3; i++) {
        stk = new StringTokenizer(br.readLine(), " ");
        long a = Long.parseLong(stk.nextToken());
        long b = Long.parseLong(stk.nextToken());
        friends.add(new Point(a,b));
    }

    // run
    for(int i = 0 ; i<3; i++) {
        if(insidePolygon(i)) System.out.println(1);
        else System.out.println(0);
    }

}
static class Point {
    long x; long y;
    public Point(long x, long y) {
        this.x = x; this.y = y;
    }
}
```

<br>

### 3. 볼록 외피(Convex Hull)

**O(NlogN ) 방법 소개 - 참고 사이트 : https://www.crocus.co.kr/1288**

```java
/*
1. 우선 기준점을 잡는다. (보통 기준점은 y좌표가 가장 작은 것을 기준으로 한다.)
=> y좌표, x좌표 기준 오름차순 정렬해서 기준점을 P[0]으로 바로 잡자

2. 그리고 이 기준점으로 하여 다른 점들을 반시계 방향으로 정렬한다.
=> 각도에 따라 정렬 핵심 (참고 : 원점 이동한 상대위치로 각도 구함)
=> arctan(y,x) 활용 : 두 점사이의 절대각도 구함

3. 컨벡스 헐 알고리즘(그라함 스캔(Graham's Scan) 알고리즘)을 이용한다.
=> 사이트 그림보면 이해하기 쉬움
*/
public static List<Point> inArr = new ArrayList<>();

public static long ccw(Point a, Point b, Point c) {
    // 복제
    Point a1 = new Point(a.x, a.y);
    Point b1 = new Point(b.x, b.y);
    Point c1 = new Point(c.x, c.y);
    // 원점이동
    a1.x -= c1.x;
    a1.y -= c1.y;
    b1.x -= c1.x;
    b1.y -= c1.y;
    // det(행렬식) 계산
    return a1.x* b1.y- a1.y* b1.x;
}

public static void main(String[] args) throws IOException {
    // input
    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
    StringTokenizer stk;
    int N = Integer.parseInt(br.readLine());
    for(int i = 0 ; i<N;i++) {
        stk = new StringTokenizer(br.readLine(), " ");
        long a = Long.parseLong(stk.nextToken());
        long b = Long.parseLong(stk.nextToken());
        inArr.add(new Point(a,b));
    }

    // run
    // y좌표, x좌표 기준 오름차순 정렬
    ObjectSort ob = new ObjectSort();
    Collections.sort(inArr, ob);
    // 기준점(=inArr.get(0))기준 상대위치 기록 (따라서 i=1부터)
    for (int i = 1; i<N; i++){
        inArr.get(i).p = inArr.get(i).x - inArr.get(0).x;
        inArr.get(i).q = inArr.get(i).y - inArr.get(0).y;
    }
    // => 기준점에서 각도 비교로 반시계 정렬(기준점(=0) 제외)
    List<Point> subList = inArr.subList(1, N); // 추출 리스트
    Collections.sort(subList, ob); // 정렬
    List<Point> inArr2 = new ArrayList<>();
    inArr2.add(inArr.get(0));
    inArr2.addAll(subList); // 병합

    // 1st, 2st로 바로 초기값 사용
    Stack<Integer> st = new Stack<>(); // index 기록하므로 그냥 int자료형 사용
    st.add(0); st.add(1); // 0, 1 index 푸시

    // 전처리 끝
    // 알고리즘 시작
    int next = 2;
    while (next < N) {
        while (st.size() >= 2) {
            int first, second;
            second = st.peek();
            st.pop();
            first = st.peek();

            // leftTurn 사용
            if (ccw(inArr2.get(first), inArr2.get(second), inArr2.get(next)) > 0) {
                st.add(second);
                break;
            }
        }
        st.add(next++); // next push
    }

    // output
    System.out.println(st.size());
}
public static double getAngle(Point a) {
    return Math.atan2(a.q, a.p); // 아크탄젠트로 각도 계산
}
static class ObjectSort implements Comparator <Point> {
    @Override
        public int compare(Point a, Point b) {
        if(getAngle(a) != getAngle(b)) return Double.compare(getAngle(a), getAngle(b));
        if(a.y != b.y) return Long.compare(a.y, b.y);
        return Long.compare(a.x, b.x); // == a.x < b.x ? -1 : (a.x==b.x?0:1)
    }
}
static class Point {
    long x; long y; // 절대위치
    long p; long q; // 상대위치
    public Point(long x, long y){
        this.x = x; this.y = y;
        this.p = 0; this.q = 0;
    }
}
```

<br>

### 4. 평면 소거법(Plane Sweeping) => 합집합

* `BOJ2185` 를 풀어야하는데, 아래 코드로는 풀리지 않는다..
* 아래코드는 좌표가 겹치지 않고, 왼쪽아래 오른쪽위 좌표 순서로 받는것을 가정했을때 올바르게 동작한다.

```java
public static List<Rectangle> inArr = new ArrayList<>();
public static List<Integer> Q = new ArrayList<>();
public static List<Integer> S = new ArrayList<>();
public static int[] counts = new int[10005];

public static int unionArea() {
    int sweepLine = 0; int delta = 0; int area = 0; // 면적
    for (int i = 0; i<Q.size(); i++) { // x값 전부 순회!
        sweepLine = Q.get(i);
        Rectangle R = new Rectangle(0,0,0,0);
        // 0. 사용할 사각형 선택(x값 겹칠때 마다 선택)
        for(int j = 0 ; j<inArr.size(); j++) {
            if(inArr.get(j).x1 == Q.get(i) || inArr.get(j).x2==Q.get(i)) {
                R = inArr.get(j);
                break;
            }
        }

        // 1. counts배열 구하기(y값 활용)
        // sweepLine이 만나는 사각형의 왼쪽 가로선만 +1, 오른쪽 가로선은 -1
        if (sweepLine == R.x1) delta = 1;
        else delta = -1; // => R.x2와 만난다고 볼 수 있음

        int y1 = R.y1; int y2 = R.y2;
        for (int j = 0 ; j<S.size(); j++) {
            if(y1 <= S.get(j) && S.get(j) < y2)
                counts[j] += delta; // S[j]~S[j+1] 구간에 겹쳐진 사각형의 수
        }

        // 2. 면적 계산 시작
        // 현재 내부면적 세로줄(S[j + 1] - S[j])
        int curLen = 0;
        for (int j = 0; j < S.size(); j++) {
            if (counts[j] > 0) { // counts배열 있는 값만(사각형 있는 경우에만)
                curLen += S.get(j+1) - S.get(j);
            }
        }

        // 현재 내부면적 가로줄(Q[i+1]-Q[i])
        if ((i + 1) < Q.size()) {
            // 사각형 면적 : 세로*가로
            area += curLen * (Q.get(i+1) - Q.get(i)); // 현재 구한 면적 더함
        }
    }
    return area;
}

public static void main(String[] args) throws IOException {
    // input
    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
    StringTokenizer stk;
    int N = Integer.parseInt(br.readLine());
    int temp = 0;
    for(int i = 0 ; i<N;i++) {
        stk = new StringTokenizer(br.readLine(), " ");
        int x1 = Integer.parseInt(stk.nextToken());
        int y1 = Integer.parseInt(stk.nextToken());
        int x2 = Integer.parseInt(stk.nextToken());
        int y2 = Integer.parseInt(stk.nextToken());
        inArr.add(new Rectangle(x1, y1, x2, y2));
        Q.add(x1); Q.add(x2); S.add(y1); S.add(y2);
    }
    // x축, y축 기록한 배열들 꼭 오름차순으로 정렬 후 사용
    Collections.sort(Q);
    Collections.sort(S);

    // run & output
    System.out.println(unionArea());
}
static class Rectangle {
    int x1; int y1; int x2; int y2;
    public Rectangle(int x1, int y1, int x2, int y2) {
        this.x1 = x1; this.y1 = y1; this.x2 = x2; this.y2 = y2;
    }
}

```

<br><br>

## Network Flow(=Max-Flow, Min-Cut, 이분 매칭)

**Ford-Fulkerson(DFS.복잡도:flow), Edmonds-Karp(BFS.복잡도:VE^2), Dinic's Algorithm(BFS,DFS.복잡도:EV^2) 가 있으며 여기서 `Dinic's` 만 암기해도 충분**

**아래 코드에서는 `Dinic's 와 멀티 Source, Sink의 경우` 예를 소개한다.**

* **Ford-Fulkerson**과 **Edmonds-Karp**는 DFS, BFS만 다르며 나머지는 로직이 정확히 동일

* **Dinic's** 는 **BFS로 레벨트리 구하고, DFS(재귀)로 연산을 진행**

* **중요한 점**
  * **"이분 매칭" 문제를 "Max-Flow" 문제로 치환해서 풀 수 있다.**
  
  * **"Min-Cut" 문제는 그냥 "Max-Flow" 로 풀었을 때 답과 동일하다.**
  
  * **보통 문제를 푸는 방식은 문제에 적합하게 "그래프" 를 설계한 후 풀어나간다.**
    
    * **"그래프" 그리는 TIP (아래 그림은 Jerry And Tom예시)**
    
      ![image-20230618164132047](/images/2023-01-11-(백준_필수3)알고리즘 템플릿 - java/image-20230618164132047.png) 
    
      * 그래프에는 **에지**를 그릴텐데 반드시 유량이 아닌 **용량**을 적어줄 것
        * 햇갈리면 안되는게 **유량은 나중에** 계산할 때 값 생기기 시작
      * **멀티 Source, Sink**의 경우?? 외부에 **S, T 노드를 임의로 추가**해서 사용
        * Max Flow는 S->T 로 흐르는 최대 유량을 구하는 형태이기 때문
        * 임의로 S, T를 추가했으므로 그래프 그릴때 용량을 잘 설정해야함
      * 복잡한 문제들은 **에지를 안주고** 직접 에지를 **구해야** 할때도 존재
        * **예시 문제 : [Jerry and Tom](https://www.acmicpc.net/problem/14750)**
        * 참고 : 해당 예시에서는 에지를 직접 구해야하며, 해당 에지는 "선분교차" 여부에 따라 구해진다.
  
* **참고 용어**
  * Residual network graph : 잉여(=잔여) 그래프
  * Level graph : 레벨 그래프(=트리의 각 노드들 깊이 표현)
  * Argmenting path : 가능한 s->t 경로
    * 이것을 BFS or DFS 로 구함

<br>

```java
/*
BOJ 14286 문제. Min-Cut 문제 => "Max-Flow"
<Dinic's Algo>
0. init 잉여그래프(c:용량으로)
1. 레벨그래프를 구함 - BFS를 사용
2. flow를 찾음 - DFS와 레벨그래프 사용(차단유량 찾기. 1개가아닌 가능한 전부) with 잉여그래프
3. update 잉여 그래프 = 유량 update 를 의미
4. TotalFlow 에 구한 flow들을 더함
=> 1~4 를 반복 - 레벨그래프 구하기 불가할 때 까지(1번 과정이 불가할때까지)

참고 : 코드상에서 work는 속도 개선용일 뿐, reverseIdx는 굉장히 중요(ArrayList에 기록하다보니 필요하게 됨)
 */
static int N, M, S, T;
static List<Node>[] inArr = new ArrayList[505];
static int[] level = new int[505];
static int[] work = new int[505]; // 속도 개선용

public static boolean bfs() {
    Arrays.fill(level, -1);
    Queue<Integer> qu = new LinkedList<>(); // bfs

    level[S] = 0; // start
    qu.add(S);
    while(!qu.isEmpty()) {
        int curIdx = qu.peek(); qu.remove();
        for(Node cur : inArr[curIdx]) {
            // 잔여용량 부족이나 레벨이미 채워진 경우엔 continue
            if(cur.c<=cur.f || level[cur.nxtIdx] != -1) continue;
            level[cur.nxtIdx] = level[curIdx] + 1; // => 깊이 기록을 의미
            qu.add(cur.nxtIdx);
        }
    }
    if(level[T] != -1) return true;
    return false; // 이 경우는 BFS 순회 실패의 경우. 즉, Dinic's 의 종료시점
}

// "residual capacity : 잔여용량" 의 개념이 중요
public static int dfs(int curIdx, int curRsdCap) {
    // base condition
    if (curIdx == T) return curRsdCap; // 끝 도달시 return

    //        for (Node cur : inArr[curIdx]) {
    for(int i = work[curIdx]; i<inArr[curIdx].size(); i++) {
        Node cur = inArr[curIdx].get(i);
        // 잔여용량 부족이나 레벨 차가 1이 아닌 경우엔 continue
        if(cur.c<=cur.f || level[cur.nxtIdx] - level[curIdx] != 1) continue;
        // 최소 유량 탐색
        int nxtRsdCap = cur.c-cur.f; // 잔여용량 : 용량-유량
        int minFlow = dfs(cur.nxtIdx, Math.min(nxtRsdCap, curRsdCap));
        // 3. update 잉여 그래프 = 유량 update 를 의미
        if(minFlow > 0) {
            cur.f += minFlow;
            inArr[cur.nxtIdx].get(cur.reverseIdx).f -= minFlow;
            work[curIdx] = i;
            return minFlow;
        }
    }
    work[curIdx] = inArr[curIdx].size();
    return 0;
}

public static void main(String[] args) throws IOException {
    // init
    for(int i = 0 ;i <505;i++) inArr[i] = new ArrayList<>();
    // input
    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
    StringTokenizer stk = new StringTokenizer(br.readLine(), " ");
    N = Integer.parseInt(stk.nextToken());
    M = Integer.parseInt(stk.nextToken());
    int a, b, c;
    for(int i = 0 ;i <M;i++) {
        stk = new StringTokenizer(br.readLine(), " ");
        a = Integer.parseInt(stk.nextToken());
        b = Integer.parseInt(stk.nextToken());
        c = Integer.parseInt(stk.nextToken()); // weight
        // 0. init 잉여그래프(c:용량으로)
        inArr[a].add(new Node(b, inArr[b].size(), c,0));
        inArr[b].add(new Node(a, inArr[a].size()-1, c,0)); // 양방향 간선
    }
    stk = new StringTokenizer(br.readLine(), " ");
    S = Integer.parseInt(stk.nextToken());
    T = Integer.parseInt(stk.nextToken());

    // run
    int totalFlow = 0; // 제거된 최소 간선 가중치 합
    while(true) {
        // 1. 레벨그래프를 구함 - BFS를 사용
        if(!bfs()) break;
        // 2. flow를 찾음 - DFS와 레벨그래프 사용(차단유량 찾기)
        Arrays.fill(work, 0); // 속도 개선용으로 사용(안써도 됨)
        int flow = dfs(S, 10000000); // 10000000 : 임의로 설정한 잔여용량
        // 3. TotalFlow 에 구한 flow들을 더함
        totalFlow += flow;
    }

    // output
    System.out.println(totalFlow);
}
static class Node {
    int nxtIdx; // 연결 노드인겸 index
    int reverseIdx; // 역방향 노드의 배열 index
    int c; // capacity(용량)
    int f; // flow(유량)
    public Node (int nxtIdx, int reveresIdx, int c, int f) {
        this.nxtIdx = nxtIdx; this.reverseIdx=reveresIdx; this.c = c; this.f = f;
    }
}
```

<br>

```java
/*
멀티 Source, Sink 의 문제로 볼 수 있다.
풀이
0. 시작(S), 끝(T)를 임의로 지정해서 일반적인 S->T maxflow로 바꾼다.
1. 쥐와 간선에 대한 정보는 "선분 교차 판정"을 이용 => 간선
2. 최대 유량으로 해결 => Dinic's 사용하겠음

EX) S = 0, T = H+M+1
참고 : 양방향이긴 하지만, 실제로 반대방향은 용량이 없는 0으로 꼭 설정
또한, 경계선은 포함하지 않는다고 했으므로 intersect 가 훨씬 간단
*/
static List<Node>[] inArr = new ArrayList[505];
static int[] level = new int[505];
static int[] work = new int[505]; // 속도 개선용
static int N, K, H, M; // N모서리 개수, K용량, H쥐구멍 개수, M쥐의 수
static int S, T; // 시작, 끝
static Point[] house = new Point[1005];
static Point[] hole = new Point[55];
static Point[] mouse = new Point[255]; // H*K

public static long ccw(Point a, Point b, Point c) {
    // 깊은 복제
    Point a1 = new Point(a.x, a.y);
    Point b1 = new Point(b.x, b.y);
    Point c1 = new Point(c.x, c.y);
    // 원점 이동
    a1.x -= c1.x;
    a1.y -= c1.y;
    b1.x -= c1.x;
    b1.y -= c1.y;
    // det(행렬식) 계산
    return a1.x*b1.y-a1.y*b1.x;
}

public static int direction(Point a, Point b, Point c) {
    // 좌 : 1, 우 : -1, 일 : 0
    if(ccw(a,b,c) > 0) return 1;
    if(ccw(a,b,c) < 0) return -1;
    return 0; // ccw(a,b,c)==0
}

// intersect => 직선 2개 교차 판별 (끝점 포함 => 0 가능을 의미)
public static boolean intersect(Point a, Point b, Point c, Point d) {
    // (a,b,c)*(a,b,d) ==-1 && (c,d,a)*(c,d,b)==-1 성립하면 교차
    return direction(a, b, c) * direction(a, b, d) <= 0 && direction(c, d, a) * direction(c, d, b) <= 0;
}

public static boolean bfs() {
    Arrays.fill(level, -1);
    Queue<Integer> qu = new LinkedList<>(); // bfs

    level[S] = 0; // start
    qu.add(S);
    while(!qu.isEmpty()) {
        int curIdx = qu.peek(); qu.remove();
        for(Node cur : inArr[curIdx]) {
            // 잔여용량 부족이나 레벨이미 채워진 경우엔 continue
            if(cur.c<=cur.f || level[cur.nxtIdx] != -1) continue;
            level[cur.nxtIdx] = level[curIdx] + 1; // => 깊이 기록을 의미
            qu.add(cur.nxtIdx);
        }
    }
    if(level[T] != -1) return true;
    return false; // 이 경우는 BFS 순회 실패의 경우. 즉, Dinic's 의 종료시점
}

// "residual capacity : 잔여용량" 의 개념이 중요
public static int dfs(int curIdx, int curRsdCap) {
    // base condition
    if (curIdx == T) return curRsdCap; // 끝 도달시 return

    //        for (Node cur : inArr[curIdx]) {
    for(int i = work[curIdx]; i<inArr[curIdx].size(); i++) {
        Node cur = inArr[curIdx].get(i);
        // 잔여용량 부족이나 레벨 차가 1이 아닌 경우엔 continue
        if(cur.c<=cur.f || level[cur.nxtIdx] - level[curIdx] != 1) continue;
        // 최소 유량 탐색
        int nxtRsdCap = cur.c-cur.f; // 잔여용량 : 용량-유량
        int minFlow = dfs(cur.nxtIdx, Math.min(nxtRsdCap, curRsdCap));
        // update 잉여 그래프 = 유량 update 를 의미
        if(minFlow > 0) {
            cur.f += minFlow;
            inArr[cur.nxtIdx].get(cur.reverseIdx).f -= minFlow;
            work[curIdx] = i;
            return minFlow;
        }
    }
    work[curIdx] = inArr[curIdx].size();
    return 0;
}

public static void main(String[] args) throws IOException {
    // init
    for(int i = 0; i<505; i++)
        inArr[i] = new ArrayList<>();
    // input
    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
    StringTokenizer stk = new StringTokenizer(br.readLine(), " ");
    N = Integer.parseInt(stk.nextToken());
    K = Integer.parseInt(stk.nextToken());
    H = Integer.parseInt(stk.nextToken());
    M = Integer.parseInt(stk.nextToken());
    int a, b;
    for(int i = 0 ;i <N;i++) {
        stk = new StringTokenizer(br.readLine(), " ");
        a = Integer.parseInt(stk.nextToken());
        b = Integer.parseInt(stk.nextToken());
        house[i] = new Point(a, b);
    }
    for(int i = 0 ;i <H;i++) {
        stk = new StringTokenizer(br.readLine(), " ");
        a = Integer.parseInt(stk.nextToken());
        b = Integer.parseInt(stk.nextToken());
        hole[i] = new Point(a,b);
    }
    for(int i = 0 ;i <M;i++) {
        stk = new StringTokenizer(br.readLine(), " ");
        a = Integer.parseInt(stk.nextToken());
        b = Integer.parseInt(stk.nextToken());
        mouse[i] = new Point(a,b);
    }

    // run
    // 0. 시작(S), 끝(T)를 임의로 지정해서 일반적인 S->T maxflow로 바꾼다.
    S=0; T=H+M+1; // 시작S: 0, 끝T: H+M+1

    // 1. 쥐와 간선에 대한 정보는 "선분 교차 판정"을 이용 => 간선
    // Edge 구하기 1
    // (초기세팅) 모든 쥐(M)들은 1만큼의 용량 존재, 모든 쥐구멍(H)은 K만큼의 용량 존재
    for (int i = 1; i <= M; i++) { // S=0이므로 i=1부터
        inArr[0].add(new Node(i, inArr[i].size(), 1, 0));
        inArr[i].add(new Node(0, inArr[0].size()-1, 0, 0)); // 양방향
    } // 1~M 사용
    for (int i = M + 1; i <= M + H; i++) { // T=H+M+1이므로 i<=M+H까지
        inArr[i].add(new Node(M+H+1, inArr[M+H+1].size(), K, 0));
        inArr[M+H+1].add(new Node(i, inArr[i].size()-1, 0, 0)); // 양방향
    } // M+1~M+H 사용

    // Edge 구하기 2
    // 쥐와 쥐구멍 에지 생성(교차 확인을 통해)
    for (int i = 0; i < M; i++) {
        for (int j = 0; j < H; j++) {
            boolean flag = true;
            for (int k = 0; k < N; k++) {
                int idx = (k + 1) % N;
                if (direction(hole[j], house[k], house[idx]) == 0) continue; // 쥐구멍이 벽에 있다는건 교차로 판별하면 안됌
                if (intersect(mouse[i], hole[j], house[k], house[idx])) { // 쥐, 쥐구멍 교차 확인
                    flag = false; // 중간에 모서리가 존재한다는 의미
                    break;
                }

            }
            if (flag) {
                // 용량 1 존재. 만약 교차 안했으면 에지자체가 없는거. 그래프 연결 안되어있는것.
                inArr[i+1].add(new Node(M + j + 1, inArr[M+j+1].size(), 1, 0));
                inArr[M+j+1].add(new Node(i + 1, inArr[i+1].size()-1, 0, 0)); // 양방향
            }
        }
    }

    // 2. 최대 유량으로 해결 => Dinic's 사용하겠음
    // run
    int totalFlow = 0; // 제거된 최소 간선 가중치 합
    while(true) {
        // 1. 레벨그래프를 구함 - BFS를 사용
        if(!bfs()) break;
        // 2. flow를 찾음 - DFS와 레벨그래프 사용(차단유량 찾기)
        Arrays.fill(work, 0); // 속도 개선용으로 사용(안써도 됨)
        int flow = dfs(S, 10000000); // 10000000 : 임의로 설정한 잔여용량
        // 3. TotalFlow 에 구한 flow들을 더함
        totalFlow += flow;
    }

    // output
    if (totalFlow == M) System.out.println("Possible");
    else System.out.println("Impossible");
}

static class Node {
    int nxtIdx; // 연결 노드인겸 index
    int reverseIdx; // 역방향 노드의 배열 index
    int c; // capacity(용량)
    int f; // flow(유량)
    public Node (int nxtIdx, int reveresIdx, int c, int f) {
        this.nxtIdx = nxtIdx; this.reverseIdx=reveresIdx; this.c = c; this.f = f;
    }
}

static class Point {
    long x; long y;
    public Point(long x, long y) {
        this.x = x; this.y = y;
    }
}
```

<br><br>

## 정수론

**`피타고라스` 관련 구하는 방법은 아래를 참고**

```java

/**
 * BOJ16123 메모리 초과 문제로 해결 불가
 * 따라서 원시 피타고라스 쌍 구하는 과정만 익혀보겠음.
 *
 * 그냥 피타고라스는 a^2+b^2=c^2 을 만족하기만 하면 되고
 * 원시 피타고라스는 gcd(a,b,c)=1 즉, 최대공약수=1 까지 만족
 * 아래 알고리즘은 원시 피타고라스를 구하는 것이고, 피타고라스 전부를 구하고 싶다면
 * 구한 a,b,c에 스칼라배를 통해서 나머지 피타고라스 수까지 구하면 된다.
 */
static List<Point> outArr = new ArrayList<>();

public static void main(String[] args) throws IOException {
    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
    long L = Long.parseLong(br.readLine()); // n < m <= L
    long a, b, c;
    for(int m = 2; m<=L; m++) {
        if(m%2==0) { // 짝수
            for(int n=1; n<m; n+=2) { // 홀수
                a = (long) (Math.pow(m,2)-Math.pow(n,2));
                b = 2*m*n;
                c = (long) (Math.pow(m,2)+Math.pow(n,2));
                outArr.add(new Point(m,n,a,b,c));
            }
        }
        else { // 홀수
            for(int n=2; n<m; n+=2) {
                a = (long) (Math.pow(m,2)-Math.pow(n,2));
                b = 2*m*n;
                c = (long) (Math.pow(m,2)+Math.pow(n,2));
                outArr.add(new Point(m,n,a,b,c));
            }
        }
    }
    System.out.println(outArr.size()); // 원시 피타고라스 쌍 개수
    // outArr 에 구한 원시 피타고라스 존재
}
static class Point {
    long m; long n; long a; long b; long c;
    public Point(long m, long n, long a, long b, long c){
        this.m=m; this.n=n; this.a=a; this.b=b; this.c=c;
    }
}
```

<br>

**`일차 디오판토스 방정식` 의 개념을 사용한 문제 풀이이며, 문제는 아래 코드 주석에 적혀있다.**

**중요한점은 `확장된 유클리드` 개념도 사용했다는 점이며, 나머지는 아래 사진을 보고 이해할 것.**

<br>

**ax+by=c의 해 존재를 판별하는 방법 => gcd(a,b)|c 성립 유무로 판단**

![image-20230608005314126](/images/2023-01-11-(백준_필수3)알고리즘 템플릿 - java/image-20230608005314126.png)

<br>

**확장 유클리드 알고리즘을 통해서 `gcd(a,b) = a*s+b*t`  의 `s,t,g` 를 구해내고  
아래 그림처럼 k를 구한 후 x, y 정수 해를 구할 수 있다.**

![image-20230608005409155](/images/2023-01-11-(백준_필수3)알고리즘 템플릿 - java/image-20230608005409155.png) 

<br>

**아래는 아래 코드의 문제를 해결하기 위한 아이디어를 나타낸 그림이다.**

![image-20230608005714788](/images/2023-01-11-(백준_필수3)알고리즘 템플릿 - java/image-20230608005714788.png)

<br>

```java
/*
입력
5
2 4 18
1 9 12
4 9 100
4 8 19
3 12 100
출력
5
4
14
-1
-1
 */

/**
 * 세 양의 정수 a, b,c 를 읽은 후, ax+by=c을 만족하는 정수 x, y를 찾되
 * |x|+|y|이 최소가 되도록 하는 값을 구하면 되며, 해를 구할수 없는 경우 -1을 출력한다.
 */
public class 디오판토스_과제물 {

    public static void main(String[] args) throws IOException {
        String file = "./eq.inp";
        FileInputStream fileStream = new FileInputStream(file);
        BufferedReader br = new BufferedReader(new InputStreamReader(fileStream));
        StringTokenizer stk;
        StringBuilder sb = new StringBuilder();
        int T = 0;
        int a, b, c;
        int r, r1, r2, s, s1, s2, t, t1, t2, q, g;
        T = Integer.parseInt(br.readLine());
        for (int i = 0; i<T; i++) {
            //cin >> a >> b >> c;
            stk = new StringTokenizer(br.readLine(), " ");
            a = Integer.parseInt(stk.nextToken());
            b = Integer.parseInt(stk.nextToken());
            c = Integer.parseInt(stk.nextToken());
            r1 = a; r2 = b;
            s1 = 1; s2 = 0;
            t1 = 0; t2 = 1;
            while (r2 > 0) {
                q = r1 / r2;
                r = r1 - q * r2;
                r1 = r2; r2 = r;
                s = s1 - q * s2;
                s1 = s2; s2 = s;
                t = t1 - q * t2;
                t1 = t2; t2 = t;
            }
            g = r1; s = s1; t = t1; // 확장 유클리드 완료

            // 해존재 유무 판별. g|c 가능 여부로 판단.
            if (c % g != 0) {
                sb.append(-1).append('\n');
                continue;
            }
            q = c / g; // c/g 몫 기록
            
            // 초기해 x0, y0 구함
            int x0 = s * q; int y0 = t * q;

            // 증가 방향인지 감소 방향인지 확인
            int x1 = x0 + (b / g) * 0;
            int y1 = y0 - (a / g) * 0;
            int x2 = x0 + (b / g) * 1;
            int y2 = y0 - (a / g) * 1;
            int cur1 = Math.abs(x1) + Math.abs(y1);
            int cur2 = Math.abs(x2) + Math.abs(y2);
            boolean check = false; // false : 증가, true : 감소방향
            if (cur1 < cur2) check = true;
            else check = false;

            int k = 0;
            int x = x0 + (b / g) * k;
            int y = y0 - (a / g) * k;
            int cur = Math.abs(x) + Math.abs(y);
            int prev = cur;
            while (true) { // 2차 방정식
                // update k
                if (check) k--;
                else k++;

                // run
                x = x0 + (b / g) * k;
                y = y0 - (a / g) * k;
                cur = Math.abs(x) + Math.abs(y);

                // break
                if (cur > prev) {
                    break;
                }
                prev = cur;
            }

            sb.append(prev).append('\n');
        }

        FileOutputStream fs = new FileOutputStream("./eq.txt");
        fs.write(sb.toString().getBytes());
//        System.out.println(sb);
    }
```

<br><br>

## 다이나믹 프로그래밍 심화(DP)

**참고 : [DP 정리](https://bh946.github.io/algorithm/(%EA%B0%9C%EB%85%90)-Dynamic_Programming(%EB%8F%99%EC%A0%81%EA%B3%84%ED%9A%8D%EB%B2%95)/)**

* **피보나치**
  * `f[n] = fib[n-1] + fib[n-2]`
* **이항계수**
  * `B[i][j] = B[i-1][j-1] + B[i-1][j]`    
    `B[i][i]=1, B[i][0]=1	,if(j==i || j==0)`
* **격자경로**
  * `P[i][j] = P[i-1,j] + P[i,j-1]`  
    `P[1,j] = P[i,1] = 1`
  * 심화 : 표시된 곳을 2회 지나야 하는 경우? 3차원으로 DP 선언  
    EX : `(표시없는길 개수)/(표시1번 지난길 개수)/(표시2번 지난길 개수)` 
* **거스름돈**
  * `C[i][j] = min( C[i, j–D[i]] + 1, C[i-1, j] )	,if D[i]<=j`  
    `C[i][j] = C[i-1][j]	,if D[i]>j`  
    `C[i][j] = 0	,if j==0`
  * 참고 : D는 Denom 으로써 액면가(화폐 단위 : 1원 10원 등등)을 의미
* **연쇄 행렬곱셈(BOJ11049)**
  * **M\[i][j] = **<img src="/images/2023-01-11-(백준_필수3)알고리즘 템플릿 - java/image-20230609172128684.png" alt="image-20230609172128684" style="zoom: 80%;" />	,**if i<j**
  * **M\[i][j] = 0	,if i==j**
* **LCS(BOJ6251)**
  * `C[i][j] = max( C[i-1][j], C[i][j-1] )	,if A[i]!=B[j]`  
    `C[i][j] = C[i-1][j-1] + 1	,if A[i]==B[j]`  
    `C[i][j] = 0	,if i==0 || j==0`
  * **Find a Longest Common Subsequence** 제일 긴 공통된 부분 문자열을 의미하며,   
    A문자열과 B문자열이 주어졌을때 이들의 LCS를 구한다는 의미이다.
* **OBST(Optimal Binary Search Tree)**
  * <img src="/images/2023-01-11-(백준_필수3)알고리즘 템플릿 - java/DRW00000bc84efc.gif" alt="img"  /> 
  * ''키''의 검색 빈도수(즉, 확률)를 받아서 BST의 최적인 트리를 구하는 것
    * WHY? 빈도수 높은 키값이 루트와 가까울수록 더욱 효율적이기 때문에 사용!
    * 다만, 이와 해당된 문제를 풀어본적이 없어서 **그냥 개념만 이해하고 넘어간다.**
* **0-1 Knapsack(BOJ12865)**
  * `max( P[i-1][w], pi + P[i-1][w-wi] )	,if wi<=w`  
    `P[i][w] = P[i-1][w]	,if wi>w`
* **프리랜서의 일정 정하기(SWEA4052)**
  * `OPT[j] = max ( OPT[j-1], w[j] + OPT[p(j)] )`
    * OPT[j-1] : 일정 j 선택X
    * OPT[p(j)]+w(j) : OPT[p(j)]는 p(j)<j인 일정들 중 젤 큰 index의 최적해(OPT) 값
      * p(j) : 일정 j와 겹치지 않고, j와 가장가까운(큰) 일정을 의미
      * w(j) : 일정 j의 비용
    * BOJ는 없고 **SWEA** 에 **4052** 문제로 존재
      * 참고로 문제에 그림 조금 잘못 그려져 있음.

* **완전정보 게임(coin move game)**
  * Nim 게임을 의미 - [바둑돌 가져가기](https://bh946.github.io/algorithm/(%EA%B0%9C%EB%85%90)-NIM_GAME(%ED%95%84%EC%8A%B9%EA%B2%8C%EC%9E%84)/), [coin move game](https://bh946.github.io/algorithmtest/(%EC%88%98%EC%97%85)Coin-Move-Game/), [coin game](https://bh946.github.io/algorithmtest/(%EC%88%98%EC%97%85)Coin-Game/), [card game](https://bh946.github.io/algorithmtest/(%EC%88%98%EC%97%85)Card-Game/)
  * "바둑돌 가져가기, coin move game" 는 확실히 이해하는것을 권장
* **제한된 비트 스트링의 개수**
  * `S[k] = S[k-1] + S[k-2]`
  * 이건 너무 쉬운 풀이인데, 비트 스트링 개수 세는 아이디어는 기록하면 좋을듯 해서
  * **참고 : [제한된 비트 스트링의 개수](https://bh946.github.io/algorithm/(%EA%B0%9C%EB%85%90)-Dynamic_Programming(%EB%8F%99%EC%A0%81%EA%B3%84%ED%9A%8D%EB%B2%95)/#%EC%A0%9C%ED%95%9C%EB%90%9C-%EB%B9%84%ED%8A%B8-%EC%8A%A4%ED%8A%B8%EB%A7%81%EC%9D%98-%EA%B0%9C%EC%88%98)**
* **최대 공백 정사각형(SWEA4062)**
  * `LES[x][y] = min( LES[x-1][y-1], LES[x][y-1], LES[x-1][y] ) + 1`  
    `LES[x][y] = 1	if 첫번째 행or열이 비었을때`  
    `LES[x][y] = 0	if 비어있지 않다면`
  * LES\[x][y] 는 공백 정사각형 크기이며, [x,y]는 해당 정사각형의 우측하단 좌표를 의미

<br><br>

# 참고

**`set, unordered_set, priority_queue` 의 경우에 무슨 자료구조를 언제 사용할까를 정해두려고 한다.**

* 우선 `set` 을(RBT구조) 우선으로 사용하되 `prev, next, lower_bound` 같은 동작들이 필요없고 `priority_queue` 가 사용하는 동작만 필요하다면 `priority_queue` 를 사용하자.
