---
title:  "[백준_필수4]알고리즘 필수 코드암기"
categories : [Baekjoon]
tag : [백준, 프로그래머스, 알고리즘 문제풀이, 위상정렬, 플로이드, 다익스트라, 프림, 크루스칼, BFS, DFS, 순열, 조합, 부분집합, 완전탐색, 브루트포스]
toc: trues
toc_sticky: true
author_profile: false
sidebar:
   nav: "docs"
typora-root-url: ../../..
---



# Intro

**코드 암기 연습을 위해 작성한다.**

- 위상정렬, 플로이드, 다익스트라, 프림, 크루스칼, BFS, DFS, 순열, 조합, 부분집합

<br><br>

# 연습

**BFS, DFS, 순열, 조합, 부분집합**

```java
```

<br>

**위상정렬, 플로이드, 다익스트라, 프림, 크루스칼**

```java
/**
 * 위상정렬 : 주어진 순서대로 선후관계 위배X 정렬 -> 방향 그래프
 * 반드시 기억 : indegree 0이 큐 삽입시점 -> 최외곽
 */
  public static void topological(){
    int[][] input = {{1, 3}, {2, 3}}; // output:1 2 3
    //...



/**
 * 플로이드 : 모든정점->모든정점 최단경로
 * 반드시 기억 : 3중 for문(k부터) + new 인접행렬
 */
  public static void floyd(){
    int N=4; int M=8; int X=2; // N->X->N 경로의 최단거리 구한후 가장 오래걸리는 학생 비용 구하라
    int[][] input = {{1,2,4},{1,3,2},{1,4,7},{2,1,1},{2,3,5},{3,1,2},{3,4,4},{4,2,3}};
    //...



/**
 * 다익스트라 : 1개정점->모든정점 최단경로
 * 반드시 기억 : 우선순위 큐(도착점, 도착비용) + new 거리배열
 * +++ 최단거리 배열과 현재 도착거리 다르면 PASS(예외)
 */
  public static void dijkstra() {
    int N=4; int M=8; int X=2; // N->X->N 경로의 최단거리 구한후 가장 오래걸리는 학생 비용 구하라
    int[][] input = {{1,2,4},{1,3,2},{1,4,7},{2,1,1},{2,3,5},{3,1,2},{3,4,4},{4,2,3}};
    //...


/**
 * 프림 : MST -> 최소 비용 정점을 선택해 나가는 방식
 * 반드시 기억 : 우선순위 큐 + cnt + visited (중복 방지 필수)
 */
  public static void prim() {
    // 최악경로 비용과 최선경로 비용의 차이를 구하라.
    int N = 4;
    int M = 5;
    int[][] input = {{0, 1, 1}, {1, 2, 0}, {1, 4, 0}, {4, 2, 1}, {3, 4, 1}, {2, 3, 0}};
    //...
      

/**
 * 크루스칼 : MST -> 간선 가중치를 비내림차순 정렬 후 순서대로 선택하는 방식
 * 반드시 기억 : 정렬 + Union find
 */
  public static void kruskal() {
    // 최악경로 비용과 최선경로 비용의 차이를 구하라.
    int N = 4;
    int M = 5;
    int[][] input = {{0, 1, 1}, {1, 2, 0}, {1, 4, 0}, {4, 2, 1}, {3, 4, 1}, {2, 3, 0}};
    //...
```

<br><br>

# 답안

**BFS, DFS, 순열, 조합, 부분집합**

```java

```

<br>

**위상정렬, 플로이드, 다익스트라, 프림, 크루스칼**

```java
/**
 * 위상정렬 : 주어진 순서대로 선후관계 위배X 정렬 -> 방향 그래프
 * 반드시 기억 : indegree 0이 큐 삽입시점 -> 최외곽
 */
  public static void topological(){
    int[][] input = {{1, 3}, {2, 3}}; // output:1 2 3
    //...
    int N = 4; // 1,2,3 까지 범위
    int[] indegree = new int[N];
    int[] outArr = new int[N]; //result
    List<Integer>[] graph = new ArrayList[N];
    for(int i=0; i<N; i++) graph[i] = new ArrayList<>();
    for(int i=0; i<2; i++){
      int parent = input[i][0];
      int child = input[i][1];
      graph[parent].add(child); // 방향 그래프
      indegree[child]++;
    }
    Queue<Integer> qu = new ArrayDeque<>();
    for(int i=1; i<N; i++){
      if(indegree[i]==0) qu.offer(i);
    }
    int idx = 0;
    while(!qu.isEmpty()){
      int node = qu.poll();
      outArr[idx++] = node; //result
      for(int nxt : graph[node]){
        indegree[nxt]--;
        if(indegree[nxt]==0) qu.offer(nxt); // 큐 삽입시점
      }
    }
    System.out.println(Arrays.toString(outArr));
  }

/**
 * 플로이드 : 모든정점->모든정점 최단경로
 * 반드시 기억 : 3중 for문(k부터) + new 인접행렬
 */
  public static void floyd(){
    int N=4; int M=8; int X=2; // N->X->N 경로의 최단거리 구한후 가장 오래걸리는 학생 비용 구하라
    int[][] input = {{1,2,4},{1,3,2},{1,4,7},{2,1,1},{2,3,5},{3,1,2},{3,4,4},{4,2,3}};
    //...
    int[][] floyd = new int[N+1][N+1];
    for(int i=1; i<=N; i++) Arrays.fill(floyd[i], Integer.MAX_VALUE/3); // 원소 더하다가 음수로 안넘어가기 위해 /3
    for(int i=0; i<M; i++){ // 입력정점
      int parent = input[i][0];
      int child = input[i][1];
      int time = input[i][2];
      floyd[parent][child] = time;
    }
    for(int k=1; k<=N; k++){
      for(int i=1; i<=N; i++){
        for(int j=1; j<=N; j++){
          floyd[i][j] = Math.min(floyd[i][j], floyd[i][k]+floyd[k][j]);
        }
      }
    }
    //debug
//    for(int i=1; i<=N; i++){
//      System.out.println(Arrays.toString(floyd[i]));
//    }
    int result = 0;
    for(int i=1; i<=N; i++){
      result = Math.max(result,floyd[i][X]+floyd[X][i]); // N->X->N 경로
    }
    System.out.println(result); //10
  }

/**
 * 다익스트라 : 1개정점->모든정점 최단경로
 * 반드시 기억 : 우선순위 큐(도착점, 도착비용) + new 거리배열
 * +++ 최단거리 배열과 현재 도착거리 다르면 PASS(예외)
 */
  public static void dijkstra() {
    int N=4; int M=8; int X=2; // N->X->N 경로의 최단거리 구한후 가장 오래걸리는 학생 비용 구하라
    int[][] input = {{1,2,4},{1,3,2},{1,4,7},{2,1,1},{2,3,5},{3,1,2},{3,4,4},{4,2,3}};
    //...
    List<Pair>[] graph = new ArrayList[N+1];
    List<Pair>[] graphRev = new ArrayList[N+1];
    for(int i=0; i<=N; i++) graph[i]=new ArrayList<>();
    for(int i=0; i<=N; i++) graphRev[i]=new ArrayList<>();
    PriorityQueue<Pair> pq1 = new PriorityQueue<>();
    PriorityQueue<Pair> pq2 = new PriorityQueue<>();
    int[] dist1 = new int[N+1];
    int[] dist2 = new int[N+1];
    Arrays.fill(dist1, Integer.MAX_VALUE);
    Arrays.fill(dist2, Integer.MAX_VALUE);
    for(int i=0; i<M; i++){ // 입력정점
      int parent = input[i][0];
      int child = input[i][1];
      int time = input[i][2];
      graph[parent].add(new Pair(child, time));
      graphRev[child].add(new Pair(parent, time)); //역방향
    }
    //N->X (역방향!!) X->N 을 구하자
    dist1[X] = 0; // 도착점 비용(시작)
    pq1.offer(new Pair(X, dist1[X])); // 도착점, 도착비용
    while(!pq1.isEmpty()){
      Pair cur = pq1.poll();
      if(dist1[cur.child] != cur.time) continue; // 최단거리 배열과 현재 도착거리 다르면 PASS(예외)
      for(Pair nxt : graphRev[cur.child]) {
        if(dist1[nxt.child] <= dist1[cur.child]+nxt.time) continue;
        dist1[nxt.child] = dist1[cur.child]+nxt.time;
        pq1.offer(new Pair(nxt.child, dist1[nxt.child]));
      }
    }
    //X->N
    dist2[X] = 0; // 도착점 비용(시작)
    pq2.offer(new Pair(X, dist2[X])); // 도착점, 도착비용
    while(!pq2.isEmpty()){
      Pair cur = pq2.poll();
      if(dist2[cur.child] != cur.time) continue; // 최단거리 배열과 현재 도착거리 다르면 PASS
      for(Pair nxt : graph[cur.child]) {
        if(dist2[nxt.child] <= dist2[cur.child]+nxt.time) continue;
        dist2[nxt.child] = dist2[cur.child]+nxt.time;
        pq2.offer(new Pair(nxt.child, dist2[nxt.child]));
      }
    }
    int result = 0;
    for(int i=1; i<=N; i++){
      int sum = dist1[i]+dist2[i];
      result = Math.max(result, sum);
    }
    System.out.println(result);
  }
  static class Pair implements Comparable<Pair> {
    int child; int time;
    public Pair(int child, int time){
      this.child=child; this.time=time;
    }
    @Override
    public int compareTo(Pair o1) {
      return this.time-o1.time; //asc
    }
  }

/**
 * 프림 : MST -> 최소 비용 정점을 선택해 나가는 방식
 * 반드시 기억 : 우선순위 큐 + cnt + visited (중복 방지 필수)
 */
  public static void prim() {
    // 최악경로 비용과 최선경로 비용의 차이를 구하라.
    int N = 4;
    int M = 5;
    int[][] input = {{0, 1, 1}, {1, 2, 0}, {1, 4, 0}, {4, 2, 1}, {3, 4, 1}, {2, 3, 0}};
    //...
    PriorityQueue<Pair2> pq1 = new PriorityQueue<>((o1, o2) -> {
      Pair2 p1 = (Pair2)o1;
      Pair2 p2 = (Pair2)o2;
      return p1.cost-p2.cost; //asc -> 최악경로비용
    });
    PriorityQueue<Pair2> pq2 = new PriorityQueue<>((o1, o2) -> {
      Pair2 p1 = (Pair2)o1;
      Pair2 p2 = (Pair2)o2;
      return p2.cost-p1.cost; //desc -> 최선경로비용
    });
    List<Pair2>[] graph = new ArrayList[N+1];
    for(int i=0; i<=N; i++) graph[i]=new ArrayList<>();
    Pair2[] outArr1 = new Pair2[N+1];
    Pair2[] outArr2 = new Pair2[N+1];
    for(int i=0; i<M+1; i++){ // 입력정점
      int parent = input[i][0];
      int child = input[i][1];
      int cost = input[i][2];
      graph[parent].add(new Pair2(child, cost));
      graph[child].add(new Pair2(parent, cost)); //양방향
    }
    //1.최선경로비용
    boolean[] visited = new boolean[N+1];
    pq1.offer(new Pair2(0, 0)); // 0번 정점부터 시작(cost:0으로써 임의의 시작점일뿐)
    int idx=0;
    while(!pq1.isEmpty()){
      Pair2 cur = pq1.poll();
      if(visited[cur.child]) continue;
      visited[cur.child]=true; // 새로운 정점을 MST에 추가
      outArr1[idx++] = cur;
      for(Pair2 nxt : graph[cur.child]) {
        if(visited[nxt.child]) continue;
        pq1.offer(nxt); // 큐 삽입 시점
      }
    }
    int result1=0;
    for(int i=1; i<idx; i++){
      if(outArr1[i].cost == 1) continue; // 1은 내리막길
      result1 += 1; // 오르막길 개수 추가
    }
    //2.최악경로비용
    visited = new boolean[N+1];
    pq2.offer(new Pair2(0, 0)); // 0번 정점부터 시작(cost:0으로써 임의의 시작점일뿐)
    idx=0;
    while(!pq2.isEmpty()){ // 특히 양방향이라 노드선택 엄격히
      Pair2 cur = pq2.poll();
      if(visited[cur.child]) continue;
      visited[cur.child]=true;
      outArr2[idx++] = cur;
      for(Pair2 nxt : graph[cur.child]) {
        if(visited[nxt.child]) continue;
        pq2.offer(nxt);
      }
    }
    int result2=0;
    for(int i=1; i<idx; i++){
      if(outArr2[i].cost == 1) continue; // 1은 내리막길
      result2 += 1;
    }
    System.out.println((int)(Math.pow(result1,2)-Math.pow(result2,2))); //8
  }
  static class Pair2 {
    int child; int cost;
    public Pair2(int child, int cost){
      this.child=child; this.cost=cost;
    }
  }

/**
 * 크루스칼 : MST -> 간선 가중치를 비내림차순 정렬 후 순서대로 선택하는 방식
 * 반드시 기억 : 정렬 + Union find
 */
  public static void kruskal() {
    // 최악경로 비용과 최선경로 비용의 차이를 구하라.
    int N = 4;
    int M = 5;
    int[][] input = {{0, 1, 1}, {1, 2, 0}, {1, 4, 0}, {4, 2, 1}, {3, 4, 1}, {2, 3, 0}};
    //...

  }
```
