---
title:  "[백준_필수4]알고리즘 필수 코드암기"
categories : [Baekjoon]
tag : [백준, 프로그래머스, 알고리즘 문제풀이, 위상정렬, 플로이드, 다익스트라, 프림, 크루스칼, BFS, DFS, 순열, 조합, 부분집합, 완전탐색, 브루트포스]
toc: trues
toc_sticky: true
author_profile: false
sidebar:
   nav: "docs"
typora-root-url: ../../..
---



# Intro

**코드 암기 연습을 위해 작성한다.**

- 위상정렬, 플로이드, 다익스트라, 프림, 크루스칼, BFS, DFS, 순열, 조합, 부분집합

<br><br>

# 연습

**BFS, DFS, 순열, 조합, 부분집합**

```java
/**
 * BFS : 너비순회
 * 2차원 좌표상에 4방향 BFS 순회 구해보라. (중복방문 방지)
 */
  static int[] dx = {0,1,0,-1}; //오,아,왼,위
  static int[] dy = {1,0,-1,0}; //오,아,왼,위
  static void bfs(int cx, int cy) {
  }
  static class Pair4 {
    int x; int y;
    public Pair4(int x, int y){
      this.x=x;this.y=y;
    }
  }

/**
 * DFS : 깊이순회
 * 생략. -> 아래 순.조.부 를 DFS 재귀형태로 구했기 때문
 */

/**
 * 순열 : "순서(자리)" 가 의미 있게 나열 -> visited 활용(백트래킹)
 * 중복순열 : "+중복" -> visited 없이
 */
  // 순열 nPm
  static int N,M;
  static boolean[] visited;
  static int[] outArr;
  static void perm(int depth) {
  }
  // 중복순열
  static void permDup(int depth) {
  }

/**
 * 조합 : "순서(자리)" 가 의미 없음 -> idx+1 (visited 없이)
 * 중복조합 : "+중복" -> idx
 */
  // 조합 nCm
  static void comb(int depth, int idx) {
  }
  // 참고) 조합 또다른 방식
  //comb(depth+1, idx+1); // 현재 선택 OK 다음 자리 이동
  //comb(depth, idx+1); // 현재 선택 X

/**
 * 부분집합 : nC0+nC1+...+nCn 즉, 조합과 유사 ("있다 or 없다") 경우의 수 -> visited의 T/F 에 재귀 2개
 */
  static void subset(int depth) {
  }
```

<br>

**위상정렬, 플로이드, 다익스트라, 프림, 크루스칼**

```java
/**
 * 위상정렬 : 주어진 순서대로 선후관계 위배X 정렬 -> 방향 그래프
 * 반드시 기억 : indegree 0이 큐 삽입시점 -> 최외곽
 */
  public static void topological(){
    int[][] input = {{1, 3}, {2, 3}}; // output:1 2 3
    //...

  }

/**
 * 플로이드 : 모든정점->모든정점 최단경로
 * 반드시 기억 : 3중 for문(k부터) + new 인접행렬
 */
  public static void floyd(){
    int N=4; int M=8; int X=2; // N->X->N 경로의 최단거리 구한후 가장 오래걸리는 학생 비용 구하라
    int[][] input = {{1,2,4},{1,3,2},{1,4,7},{2,1,1},{2,3,5},{3,1,2},{3,4,4},{4,2,3}};
    //...

  }

/**
 * 다익스트라 : 1개정점->모든정점 최단경로
 * 반드시 기억 : 우선순위 큐(도착점, 도착비용) + new 거리배열
 * +++ 최단거리 배열과 현재 도착거리 다르면 PASS(예외)
 */
  public static void dijkstra() {
    int N=4; int M=8; int X=2; // N->X->N 경로의 최단거리 구한후 가장 오래걸리는 학생 비용 구하라
    int[][] input = {{1,2,4},{1,3,2},{1,4,7},{2,1,1},{2,3,5},{3,1,2},{3,4,4},{4,2,3}};
    //...

  }

/**
 * 프림 : MST -> 최소 비용 정점을 선택해 나가는 방식
 * 반드시 기억 : 우선순위 큐 + cnt + visited (중복 방지 필수)
 */
  public static void prim() {
    // 최악경로 비용과 최선경로 비용의 차이를 구하라.
    int N = 4;
    int M = 5;
    int[][] input = {{0, 1, 1}, {1, 2, 0}, {1, 4, 0}, {4, 2, 1}, {3, 4, 1}, {2, 3, 0}};
    //...
    
  }

/**
 * 크루스칼 : MST -> 간선 가중치를 비내림차순 정렬 후 순서대로 선택하는 방식
 * 반드시 기억 : 정렬 + Union find
 */
  public static void kruskal() {
    // 최악경로 비용과 최선경로 비용의 차이를 구하라.
    int N = 4;
    int M = 5;
    int[][] input = {{0, 1, 1}, {1, 2, 0}, {1, 4, 0}, {4, 2, 1}, {3, 4, 1}, {2, 3, 0}};
    //...
      
  }
```

<br><br>

# 답안

**BFS, DFS, 순열, 조합, 부분집합**

```java
/**
 * BFS : 너비순회
 * 2차원 좌표상에 4방향 BFS 순회 구해보라. (중복방문 방지)
 */
  static int[] dx = {0,1,0,-1}; //오,아,왼,위
  static int[] dy = {1,0,-1,0}; //오,아,왼,위
  static void bfs(int cx, int cy) {
    int level=0; int width=0; // level, width 는 그냥 참고용으로 넣음
    boolean[][] visited = new boolean[5][5];
    Queue<Pair4> qu = new ArrayDeque<>();
    qu.offer(new Pair4(cx, cy));
    visited[cx][cy] = true;
    while(!qu.isEmpty()) {
      int size = qu.size();
      level++;
      for(int s=0; s<size; s++){
        Pair4 cur = qu.poll();
        width++;
        for(int i=0; i<4; i++){
          int nx=cur.x+dx[i];
          int ny=cur.y+dy[i];
          if(nx<0||ny<0||nx>5||ny>5) continue;
          if(visited[nx][ny]) continue;
          qu.offer(new Pair4(nx, ny)); //큐삽입시점 중요
          visited[nx][ny]=true; //방문시점 마찬가지
        }
      }
    }
  }
  static class Pair4 {
    int x; int y;
    public Pair4(int x, int y){
      this.x=x;this.y=y;
    }
  }

/**
 * DFS : 깊이순회
 * 생략. -> 아래 순.조.부 를 DFS 재귀형태로 구했기 때문
 */


/**
 * 순열 : "순서(자리)" 가 의미 있게 나열 -> visited 활용(백트래킹)
 * 중복순열 : "+중복" -> visited 없이
 */
  // 순열 nPm
  static int N,M;
  static boolean[] visited;
  static int[] outArr;
  static void perm(int depth) {
    if(depth == M) {
      // 순열 생성 완료
    }
    for(int i=1; i<=N; i++) {
      if(visited[i]) continue;
      visited[i]=true;
      outArr[depth] = i;
      perm(depth+1);
      visited[i]=false; //backtracking
    }
  }
  // 중복순열
  static void permDup(int depth) {
    if(depth == M) {
      // 중복순열 생성 완료
    }
    for(int i=1; i<=N; i++) {
      outArr[depth] = i;
      permDup(depth+1);
    }
  }

/**
 * 조합 : "순서(자리)" 가 의미 없음 -> idx+1 (visited 없이)
 * 중복조합 : "+중복" -> idx
 */
  // 조합 nCm
  static void comb(int depth, int idx) {
    if(depth == M) {
      // 조합 생성 완료
    }
    for(int i=1; i<=N; i++) {
      outArr[depth] = i;
      comb(depth+1, i+1);
    }
  }
  // 중복조합
  static void combDup(int depth, int idx) {
    if(depth == M) {
      // 중복조합 생성 완료
    }
    for(int i=1; i<=N; i++) {
      outArr[depth] = i;
      comb(depth+1, i); // 이 차이밖에 없음. 한끗차이
    }
  }
  // 참고) 조합 또다른 방식
  //comb(depth+1, idx+1); // 현재 선택 OK 다음 자리 이동
  //comb(depth, idx+1); // 현재 선택 X

/**
 * 부분집합 : nC0+nC1+...+nCn 즉, 조합과 유사 ("있다 or 없다") 경우의 수 -> visited의 T/F 에 재귀 2개
 */
  static void subset(int depth) {
    if(depth == N) {
      // 부분집합 완성
    }
    visited[depth] = true;
    subset(depth+1);
    visited[depth] = false;
    subset(depth+1);
  }

```

<br>

**위상정렬, 플로이드, 다익스트라, 프림, 크루스칼**

```java
/**
 * 위상정렬 : 주어진 순서대로 선후관계 위배X 정렬 -> 방향 그래프
 * 반드시 기억 : indegree 0이 큐 삽입시점 -> 최외곽
 */
  public static void topological(){
    int[][] input = {{1, 3}, {2, 3}}; // output:1 2 3
    //...
    int N = 4; // 1,2,3 까지 범위
    int[] indegree = new int[N];
    int[] outArr = new int[N]; //result
    List<Integer>[] graph = new ArrayList[N];
    for(int i=0; i<N; i++) graph[i] = new ArrayList<>();
    for(int i=0; i<2; i++){
      int parent = input[i][0];
      int child = input[i][1];
      graph[parent].add(child); // 방향 그래프
      indegree[child]++;
    }
    Queue<Integer> qu = new ArrayDeque<>();
    for(int i=1; i<N; i++){
      if(indegree[i]==0) qu.offer(i);
    }
    int idx = 0;
    while(!qu.isEmpty()){
      int node = qu.poll();
      outArr[idx++] = node; //result
      for(int nxt : graph[node]){
        indegree[nxt]--;
        if(indegree[nxt]==0) qu.offer(nxt); // 큐 삽입시점
      }
    }
    System.out.println(Arrays.toString(outArr));
  }

/**
 * 플로이드 : 모든정점->모든정점 최단경로
 * 반드시 기억 : 3중 for문(k부터) + new 인접행렬
 */
  public static void floyd(){
    int N=4; int M=8; int X=2; // N->X->N 경로의 최단거리 구한후 가장 오래걸리는 학생 비용 구하라
    int[][] input = {{1,2,4},{1,3,2},{1,4,7},{2,1,1},{2,3,5},{3,1,2},{3,4,4},{4,2,3}};
    //...
    int[][] floyd = new int[N+1][N+1];
    for(int i=1; i<=N; i++) Arrays.fill(floyd[i], Integer.MAX_VALUE/3); // 원소 더하다가 음수로 안넘어가기 위해 /3
    for(int i=0; i<M; i++){ // 입력정점
      int parent = input[i][0];
      int child = input[i][1];
      int time = input[i][2];
      floyd[parent][child] = time;
    }
    for(int k=1; k<=N; k++){
      for(int i=1; i<=N; i++){
        for(int j=1; j<=N; j++){
          floyd[i][j] = Math.min(floyd[i][j], floyd[i][k]+floyd[k][j]);
        }
      }
    }
    //debug
//    for(int i=1; i<=N; i++){
//      System.out.println(Arrays.toString(floyd[i]));
//    }
    int result = 0;
    for(int i=1; i<=N; i++){
      result = Math.max(result,floyd[i][X]+floyd[X][i]); // N->X->N 경로
    }
    System.out.println(result); //10
  }

/**
 * 다익스트라 : 1개정점->모든정점 최단경로
 * 반드시 기억 : 우선순위 큐(도착점, 도착비용) + new 거리배열
 * +++ 최단거리 배열과 현재 도착거리 다르면 PASS(예외)
 */
  public static void dijkstra() {
    int N=4; int M=8; int X=2; // N->X->N 경로의 최단거리 구한후 가장 오래걸리는 학생 비용 구하라
    int[][] input = {{1,2,4},{1,3,2},{1,4,7},{2,1,1},{2,3,5},{3,1,2},{3,4,4},{4,2,3}};
    //...
    List<Pair>[] graph = new ArrayList[N+1];
    List<Pair>[] graphRev = new ArrayList[N+1];
    for(int i=0; i<=N; i++) graph[i]=new ArrayList<>();
    for(int i=0; i<=N; i++) graphRev[i]=new ArrayList<>();
    PriorityQueue<Pair> pq1 = new PriorityQueue<>();
    PriorityQueue<Pair> pq2 = new PriorityQueue<>();
    int[] dist1 = new int[N+1];
    int[] dist2 = new int[N+1];
    Arrays.fill(dist1, Integer.MAX_VALUE);
    Arrays.fill(dist2, Integer.MAX_VALUE);
    for(int i=0; i<M; i++){ // 입력정점
      int parent = input[i][0];
      int child = input[i][1];
      int time = input[i][2];
      graph[parent].add(new Pair(child, time));
      graphRev[child].add(new Pair(parent, time)); //역방향
    }
    //N->X (역방향!!) X->N 을 구하자
    dist1[X] = 0; // 도착점 비용(시작)
    pq1.offer(new Pair(X, dist1[X])); // 도착점, 도착비용
    while(!pq1.isEmpty()){
      Pair cur = pq1.poll();
      if(dist1[cur.child] != cur.time) continue; // 최단거리 배열과 현재 도착거리 다르면 PASS(예외)
      for(Pair nxt : graphRev[cur.child]) {
        if(dist1[nxt.child] <= dist1[cur.child]+nxt.time) continue;
        dist1[nxt.child] = dist1[cur.child]+nxt.time;
        pq1.offer(new Pair(nxt.child, dist1[nxt.child]));
      }
    }
    //X->N
    dist2[X] = 0; // 도착점 비용(시작)
    pq2.offer(new Pair(X, dist2[X])); // 도착점, 도착비용
    while(!pq2.isEmpty()){
      Pair cur = pq2.poll();
      if(dist2[cur.child] != cur.time) continue; // 최단거리 배열과 현재 도착거리 다르면 PASS
      for(Pair nxt : graph[cur.child]) {
        if(dist2[nxt.child] <= dist2[cur.child]+nxt.time) continue;
        dist2[nxt.child] = dist2[cur.child]+nxt.time;
        pq2.offer(new Pair(nxt.child, dist2[nxt.child]));
      }
    }
    int result = 0;
    for(int i=1; i<=N; i++){
      int sum = dist1[i]+dist2[i];
      result = Math.max(result, sum);
    }
    System.out.println(result);
  }
  static class Pair implements Comparable<Pair> {
    int child; int time;
    public Pair(int child, int time){
      this.child=child; this.time=time;
    }
    @Override
    public int compareTo(Pair o1) {
      return this.time-o1.time; //asc
    }
  }

/**
 * 프림 : MST -> 최소 비용 정점을 선택해 나가는 방식
 * 반드시 기억 : 우선순위 큐 + cnt + visited (중복 방지 필수)
 */
  public static void prim() {
    // 최악경로 비용과 최선경로 비용의 차이를 구하라.
    int N = 4;
    int M = 5;
    int[][] input = {{0, 1, 1}, {1, 2, 0}, {1, 4, 0}, {4, 2, 1}, {3, 4, 1}, {2, 3, 0}};
    //...
    PriorityQueue<Pair2> pq1 = new PriorityQueue<>((o1, o2) -> {
      Pair2 p1 = (Pair2)o1;
      Pair2 p2 = (Pair2)o2;
      return p1.cost-p2.cost; //asc -> 최악경로비용
    });
    PriorityQueue<Pair2> pq2 = new PriorityQueue<>((o1, o2) -> {
      Pair2 p1 = (Pair2)o1;
      Pair2 p2 = (Pair2)o2;
      return p2.cost-p1.cost; //desc -> 최선경로비용
    });
    List<Pair2>[] graph = new ArrayList[N+1];
    for(int i=0; i<=N; i++) graph[i]=new ArrayList<>();
    Pair2[] outArr1 = new Pair2[N+1];
    Pair2[] outArr2 = new Pair2[N+1];
    for(int i=0; i<M+1; i++){ // 입력정점
      int parent = input[i][0];
      int child = input[i][1];
      int cost = input[i][2];
      graph[parent].add(new Pair2(child, cost));
      graph[child].add(new Pair2(parent, cost)); //양방향
    }
    //1.최선경로비용
    boolean[] visited = new boolean[N+1];
    pq1.offer(new Pair2(0, 0)); // 0번 정점부터 시작(cost:0으로써 임의의 시작점일뿐)
    int idx=0;
    while(!pq1.isEmpty()){
      Pair2 cur = pq1.poll();
      if(visited[cur.child]) continue;
      visited[cur.child]=true; // 새로운 정점을 MST에 추가
      outArr1[idx++] = cur;
      for(Pair2 nxt : graph[cur.child]) {
        if(visited[nxt.child]) continue;
        pq1.offer(nxt); // 큐 삽입 시점
      }
    }
    int result1=0;
    for(int i=1; i<idx; i++){
      if(outArr1[i].cost == 1) continue; // 1은 내리막길
      result1 += 1; // 오르막길 개수 추가
    }
    //2.최악경로비용
    visited = new boolean[N+1];
    pq2.offer(new Pair2(0, 0)); // 0번 정점부터 시작(cost:0으로써 임의의 시작점일뿐)
    idx=0;
    while(!pq2.isEmpty()){ // 특히 양방향이라 노드선택 엄격히
      Pair2 cur = pq2.poll();
      if(visited[cur.child]) continue;
      visited[cur.child]=true;
      outArr2[idx++] = cur;
      for(Pair2 nxt : graph[cur.child]) {
        if(visited[nxt.child]) continue;
        pq2.offer(nxt);
      }
    }
    int result2=0;
    for(int i=1; i<idx; i++){
      if(outArr2[i].cost == 1) continue; // 1은 내리막길
      result2 += 1;
    }
    System.out.println((int)(Math.pow(result1,2)-Math.pow(result2,2))); //8
  }
  static class Pair2 {
    int child; int cost;
    public Pair2(int child, int cost){
      this.child=child; this.cost=cost;
    }
  }

/**
 * 크루스칼 : MST -> 간선 가중치를 비내림차순 정렬 후 순서대로 선택하는 방식
 * 반드시 기억 : 정렬 + Union find
 */
  public static void kruskal() {
    // 최악경로 비용과 최선경로 비용의 차이를 구하라.
    int N = 4;
    int M = 5;
    int[][] input = {{0, 1, 1}, {1, 2, 0}, {1, 4, 0}, {4, 2, 1}, {3, 4, 1}, {2, 3, 0}};
    //...
    List<Pair3> edges1 = new ArrayList<>();
    List<Pair3> edges2 = new ArrayList<>();
    Pair3[] outArr1 = new Pair3[N+1];
    Pair3[] outArr2 = new Pair3[N+1];
    for(int i=0; i<M+1; i++){ // 입력정점
      int parent = input[i][0];
      int child = input[i][1];
      int cost = input[i][2];
      edges1.add(new Pair3(parent,child,cost)); //최악경로비용
      edges2.add(new Pair3(parent,child,cost)); //최선경로비용
    }
    Collections.sort(edges1, (o1, o2) -> Integer.compare(o1.cost, o2.cost)); //asc
    Collections.sort(edges2, (o1, o2) -> Integer.compare(o2.cost, o1.cost)); //desc
    //1.최악경로비용
    Arrays.fill(p, -1);
    int idx=0;
    for(Pair3 edge : edges1){
      if(isUnion(edge.parent, edge.child)) continue;
      outArr1[idx++] = edge;
//      if(idx==N) break; //입구 포함이므로(0포함), 간선 개수가 N
    }
    int result1=0;
    for(int i=0; i<idx; i++){ // i=0부터
      if(outArr1[i].cost == 1) continue; // 1은 내리막길
      result1 += 1; // 오르막길 개수 추가
    }
    //2.최선경로비용
    Arrays.fill(p, -1);
    idx=0;
    for(Pair3 edge : edges2){
      if(isUnion(edge.parent, edge.child)) continue;
      outArr2[idx++] = edge;
//      if(idx==N) break; //입구 포함이므로(0포함), 간선 개수가 N
    }
    int result2=0;
    for(int i=1; i<idx; i++){ // i=0부터
      if(outArr2[i].cost == 1) continue; // 1은 내리막길
      result2 += 1;
    }
    System.out.println((int)(Math.pow(result1,2)-Math.pow(result2,2))); //8
  }
  static int[] p = new int[5]; //부모배열 기록
  static boolean isUnion(int u, int v){
    u = find(u); v = find(v); // root노드 찾기
    if(u==v) return true; // 합집합(부모같으니까)
    if(p[u] > p[v]) { // 하나의 집합으로 합치려는 의도일 뿐
      int temp = u;
      u=v; v=temp;
    } // swap
    p[u] += p[v]; // 자식이 많은쪽에 merge
    p[v] = u; // 부모 기록
    return false;
  }
  static int find(int x){
    if(p[x] < 0) return x; //-1은 자신이 부모
    return p[x] = find(p[x]); //root 까지 재귀
  }

  static class Pair3 {
    int parent; int child; int cost;
    public Pair3(int parent, int child, int cost){
      this.parent=parent; this.child=child; this.cost=cost;
    }
  }
```
