---
title:  "[C++]팩토리얼 0의 개수 - 백준1676"
categories : [BaekjoonTest]
tag : [백준, 프로그래머스, 알고리즘 문제풀이]
toc: true
toc_sticky: true
author_profile: false
sidebar:
   nav: "docs"
typora-root-url: ../../..
---



## 문제

* **[팩토리얼 0의 개수(백준1676)](https://www.acmicpc.net/problem/1676)**

<br>

## 풀이

**문제 해석을 하자면,**

* N팩토리얼의 값에서 일의자리 수 부터 0의 개수를 구하되 처음 0이 아닌 숫자가 나올 때까지 0의 개수를 구한다.
  * 예 : 10! = 3628800 이므로 0의 개수는 2개
  * 참고로 500! 은 굉장히 값이 크기 때문에 값을 구해서 개수세면 안되고 다른 방식을 생각해야한다.
  * 결국 구글링을 해버렸다..  => 소인수 분해의 개념을 이용




**소인수 분해란??**

* 참고로 소인수란 주어진 자연수의 약수 중에서 소수인걸 의미
* 소인수 분해는 자연수를 소인수들의 곱으로 표현하는 것!
  * 최소, 최대 공약수 구할때처럼 (물론 여긴 두개의 수를 다루는 공약수, 공배수는 아님)
  * 자연수를 가장 작은 소수부터 나눠주면서 몫이 소수로 끝날때까지 계산!
  * 이때 나온 과정들 값들이 소인수 분해된 값
* 아래 사진을 보고 이해 
  * [출처](https://mathbang.net/200)

![image-20230206184300906](./images/2023-02-24-(C++)팩토리얼 0의 개수 - 백준1676/image-20230206184300906.png)

* **즉, 60 = 2 x 2 x 3 x 5 로 소인수 분해가 된다.**



**풀이**

* 우선 뒤에 0이 나오는 경우는 10이 곱해진 경우로 볼 수 있다는건 자명하다.
* 그렇다면, 10의 거듭제곱으로 곱해지는 개수를 구하면 0의 개수가 될 것이다.
* 그런데 10을 곱할때만 카운트하는건 옳지 않다. 
  * 예로 `10!=1*2*3*4*5*6*7*8*9*10` 에서 10이 한번 곱해져있어서 카운트 1번만 하면 답이 틀리다.
  * `2x5=10` 처럼 소인수분해 개념을 적용해야 10이 곱해지는 개수를 정확히 구할 수 있다.
    * 10의 소인수분해 => 2x5=10

  * 따라서 N! 을 소인수분해 했을 때 나오는 2와 5의 개수를 세서 더 작은 것을 구하면 된다.
    * 왜냐면 2^3 * 5^5 의 경우 당연히 2^3 * 5^3 = 10^3 의 경우로만 나타낼 수 있기 때문이다.

* **2, 5의 개수가 몇개인지 찾는게 핵심이니까 이를 찾는 2가지 방법을 소개한다.**
  * **첫번째 방식은(가장 간단)**
    * 예로 5의 개수를 구할땐? 약수 구할때처럼 그냥 5로 나누어 떨어지면 1개(즉, 나머지=0)
    * 그 값에 또 5로 나누어 떨어지면 1개 추가, 이를 반복... 
    * 안나누어 떨어질때까지(즉, 나머지!=0) 합하면 이때 5의 총 개수가 됨.

  * **두번째 방식은(더 빠름)**
    * 예로 10!의 경우? `10!=1*2*3*4*5*6*7*8*9*10` 이다.
    * 5로 해당 10을 나누어주면?? 1~10 사이의 5가 나온 개수가 출력된다. => 이 특징을 이용!
      * 5의 개수 : 10/5=2, 10/5^2 = 0	=> 총 2개
      * 2의 개수 : 10/2=5, 10/2^2 = 2, 10/2^3 = 1, 10/2^4 = 0	 => 총 8개

    * 참고로 위에서 2나 5의 제곱 수를 고려하고 있는데, 이 원리를 설명하겠다.
      * 예로 25!을 생각해보자. 마지막 25는 25=5*5로써 5가 한개 더 있다.
      * 따라서 5로 25를 나눠주면?? 1~25 사이의 5가 나온 개수가 총 출력되지만 
      * `25(=5*5)`의 경우엔 5가 2개이지만 이때 1개만 카운트 된다  
        => 즉, 1개 카운트가 부족함
      * 이때 25를 `25(=5*5)` 로 또 나누어주면 1~25 사이의 25가 나온 개수가 출력되어서  
        => 위에서 부족한 카운트 1개가 보충 될 수 있다.
      * 해당 원리를 이용한다면?
        * 5의 개수 : 25/5 = 5, 25/25 = 1	=> 총 6개





<br>

## 코드

```c++
#pragma warning(disable:4996)
#include <iostream>
using namespace std;


int main() {
	// 속도 향상
	ios_base::sync_with_stdio(false); // c++로만 작성할 것
	cin.tie(NULL); // 입출력이 많을때 사용해 줄 것(여기선 사실 필요없음)
	cout.tie(NULL);

	int N = 0; int i = 0;
	int count1 = 0; int count2 = 0;

	// input
	cin >> N;
	
	// run
	for (i = 2; i <= N; i*=2) count1 += N / i;
	for (i = 5; i <= N; i *= 5) count2 += N / i;

	// output
	cout << min(count1, count2);;

	return 0;
}
```

<br>

## 느낀점

이 문제는 소인수 분해의 개념을 잊고 있었어서 솔직히 스스로 풀지 못했던 아쉬운 문제이다.
