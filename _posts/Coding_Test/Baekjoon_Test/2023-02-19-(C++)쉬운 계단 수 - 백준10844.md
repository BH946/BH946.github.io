---
title:  "[C++]쉬운 계단 수 - 백준10844"
categories : [BaekjoonTest]
tag : [백준, 프로그래머스, 알고리즘 문제풀이]
toc: true
toc_sticky: true
author_profile: false
sidebar:
   nav: "docs"
typora-root-url: ../../..
---



## 문제

* **[쉬운 계단 수(백준10844)](https://www.acmicpc.net/problem/10844)**

<br>

## 풀이

**문제 해석을 하자면,**

* `45656` 의 숫자를 한자리씩 보면 각각 인접한 수와의 차이가 1이다.
  * 즉, `5-4=1, 6-5=1 ...` 인것처럼 차이가 전부 1이다. 이런 수를 계단 수라고 한다.

* N이 주어질때 길이가 N인 계단 수는 총 몇개인지 구하는 문제이다.
* N이 주어지면 N 길이인 계단 수를 모두 구해야하므로 모든 경우를 따져야한다.
  * 이는 시간오버가 걸리기 때문에 DP 방식으로 풀어봐야한다.




**풀이**

```
N=1
1 2 3 4 5 6 7 8 9 => 9개

N=2
10 12, 21 23, 32 34, 43 45, 54 56 65 67 76 78 87 89 98 => 17개

N=3
101 121 123, 210 212 232 234, 321 323 343 345, 432 434 454 456, ... ,
876 878 898 89x, 987 989 x x
=> 32개

N=4
1010 1012 1210 1212 1232 1234, 2101 2121 2123 2321 2323 2343 2345, 
3212 3210 3232 3234 3432 3434 3454 3456 , ...반복.
```

* **처음 실패한 풀이**

  * 처음엔 각각 1~9 자리수 기준으로 개수가 N이 커질때마다 2배씩 커지는걸 확인했고,

  * 숫자들의 마지막 자리가 0, 9일 때만 해당 0, 9 나오는 개수 제외하면 답이 나온다는걸 손으로 풀때 확인했다.

    ```
    초기값(N=1)
    dpArr[1][1] = 1; dpArr[2][1] = 1; .... dpArr[9][1] = 1;
    endNumArr[9] = 1; 
    
    점화식
    dpArr[j][i] = dpArr[j][i-1]*2; => (if endNumArr[j] == 0)
    dpArr[j][i] = dpArr[j][i-1]*2-endNumArr[j]; => (if endNumArr[j] > 0)
    ```

  * 하지만 이는 마지막 자리가 0, 9 인지 저 많은 숫자들을 구해서 확인해야해서 너무 비효율적이며

  * 당연히 시간오버도 걸릴것이라 판단했다.

* **성공한 풀이(구글링,, 조금 했음 ㅠㅠ)**

  * [참고한 게시글](https://velog.io/@rlafkdud1228/%EB%B0%B1%EC%A4%80-10844-%EC%89%AC%EC%9A%B4-%EA%B3%84%EB%8B%A8-%EC%88%98) 이분의 풀이에서 그림이 있는데 이걸 확인해보면 규칙이 있다는걸 알 수 있다.

    ```
    N=3
    101 121 123, 210 212 232 234, 321 323 343 345, 432 434 454 456, ... ,
    876 878 898 89x, 987 989 x x
    
    N=4
    1010 1012 1210 1212 1232 1234, 2101 2121 2123 2321 2323 2343 2345,
    3210 3212 3232 3234 3432 3434 3454 3456 , ...반복.
    ```

  * 여기서 만약 N=4고, 숫자 기준 3일때 의 값인 `dpArr[4][3]`을 구하고싶은 경우?

    * N=3 의 210 212 232 234, 432 434 454 456 를 보면
    * N=4 의 3210 3212 3232 3234 3432 3434 3454 3456 의 맨앞 3을 제외하면 정확히 동일 하다는 걸 알 수 있다. => 이 규칙을 이용
      * **점화식 : `dpArr[j][i] = (dpArr[j - 1][i - 1] + dpArr[j + 1][i - 1])`**
    * 참고로 숫자 기준 1일때를 풀려면 숫자 기준 0이 필요하므로 계산할땐 0도 같이 계산.
      * **따라서 j==0, j==9 때만 다르게 계산**
    * 마지막에 답을 낼때만 0을 빼고 계산하면 된다.




<br>

## 코드

```c++
#include <iostream>
#define MAXMOD 1000000000;
using namespace std;

int dpArr[10][101];
int result;

int N;
int i, j, k;


int main() {
	// input
	cin >> N;

	// init
	for (i = 0; i <= 9; i++) dpArr[i][1] = 1;

	// run
	for (i = 2; i <= N; i++) {
		for (j = 0; j <= 9; j++) {
			if (j == 0) {
				dpArr[j][i] = dpArr[j + 1][i - 1] % MAXMOD;
			}
			else if (j == 9) {
				dpArr[j][i] = dpArr[j - 1][i - 1] % MAXMOD;
			}
			else {
				dpArr[j][i] = (dpArr[j - 1][i - 1] + dpArr[j + 1][i - 1]) % MAXMOD;
			}
		}
	}

	// output
	for (i = 1; i <= 9; i++) { // 계산때는 숫자 기준 0일때는 제외하고 계산
		result = (result + dpArr[i][N]) % MAXMOD;
	}
	cout << result;

	return 0;
}
```

<br>

## 느낀점

요즘 느끼는거지만 손으로 쭉 풀어서 규칙을 찾는게 되게 중요한것 같다.

구글링은 최대한 참자..
