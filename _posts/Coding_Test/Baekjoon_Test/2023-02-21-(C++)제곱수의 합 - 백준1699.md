---
title:  "[C++]제곱수의 합 - 백준1699"
categories : [BaekjoonTest]
tag : [백준, 프로그래머스, 알고리즘 문제풀이]
toc: true
toc_sticky: true
author_profile: false
sidebar:
   nav: "docs"
typora-root-url: ../../..
---



## 문제

* **[제곱수의 합(백준1699)](https://www.acmicpc.net/problem/1699)**

<br>

## 풀이

**문제 해석을 하자면,**

* `11=2^2+2^2+1^2+1^2+1^2(5개 항)` 과 `11=3^2+1^2+1^2(3개 항)` 처럼 제곱수들의 합으로 자연수 N값을 나타낼 수 있다고 한다.
* 이 표현에서 항의 개수가 최소인 값을 구하는 문제이다.
  * 당장 위의 예시를 봐도 둘중에 최소항은 3개 항인걸 알 수 있고 이것이 답이다.




**풀이**

```
1 = 1^2							dp[1] = 1^2 = 1개
2 = 1^2 + 1^2					dp[2] = dp[1]+dp[1]
3 = 1^2 + 1^2 + 1^2				dp[3] = dp[2]+dp[1]
4 = 2^2							dp[4] = 2^2 = 1개
5 = 2^2 + 1^2					dp[5] = dp[4] + dp[1]
6 = 2^2 + 1^2 + 1^2				dp[6] = dp[5] + dp[1]
7 = 2^2 + 1^2 + 1^2 + 1^2		dp[7] = dp[6] + dp[1]
8 = 2^2 + 2^2					dp[8] = dp[4] + dp[4] => ??
9 = 3^2							dp[9] = 3^2 = 1개
10 = 3^2 + 1^2					dp[10] = dp[9] + dp[1]
11 = 3^2 + 1^2 + 1^2			dp[11] = dp[10] + dp[1]
12 = 3^2 + 1^2 + 1^2 + 1^2 X	dp[12] = dp[8] + dp[4] => ??
=> 2^2 + 2^2 + 2^2				
13 = 3^2 + 2^2					dp[13] = dp[9] + dp[4] => ??
14 = 3^2 + 2^2 + 1^2			dp[14] = dp[13] + dp[1]
15 = 3^2 + 2^2 + 1^2 + 1^2		dp[15] = dp[14] + dp[1]
16 = 4^2						dp[16] = 4^2 = 1개
```

- 위의 식들은 손으로 풀어본 과정이다. 이를 참고!!
- 단순하게 접근해보면 점화식이 `dp[i+1]=dp[i]+1` 라고 먼저 생각이 든다.
  - `dp[i]` 값은 N=i 때 제곱수로 구한 최소항 개수인데 `dp[1]` 은 N=1 때 최소항 개수이다.   
    이는 당연히 1^2 로써 1개이다.
  - 따라서 `dp[i+1]` 값은 N=i+1때 최소항 개수를 의미하니까 N=i 때 값에 +1^2 만 더해주면 N=i+1 로   
    만들 수 있으며 개수는 1만 추가하면 되는 것이다.
- 다만, 반례들을 확인해보면 규칙을 더 찾아야할 것 같다. 이것을 생각못해서 구글링의 힘을 빌렸었다,,
  - 위에 풀이 보면 "??" 부분들이 어떤 규칙인지를 못찾았던것이 문제다.
  - 점화식 : `d[i] = min(d[n-i^2])+1`
    - 제곱수들은 `1^2, 2^2, 3^2, 4^2 ...` 이것들이란 건 이해 될 것이다.
    - 이 제곱수들을 전부 더해보고 젤 min값을 기록하는 방법이다.
    - 생각해보면 처음에 점화식 구했던 식은 1^2 인 제곱수만 고려했다고 볼 수 있다.
    - **이를 확장해서 제곱수들 전부를 고려하면 min값을 제대로 구할 수 있다는게 핵심이다.**
  - 나머지는 코드보면 충분히 이해할 수 있을것이다.




```c++
#include <iostream>
using namespace std;

int dpArr[100005];

int N;
int i, j, k;

int main() {
	// input
	cin >> N;
	
	// init
	dpArr[1] = 1;
	dpArr[2] = 2;
	dpArr[3] = 3;

	// run
	for (i = 4; i <= N; i++) {
		dpArr[i] = 100000000; // init
		for (j = 1; j*j <= i; j++) {
			dpArr[i] = min(dpArr[i], dpArr[i - j*j] + 1);
		}
	}

	// output
	cout << dpArr[N];


	return 0;
}
```

<br>

## 느낀점

아쉽게 규칙을 완벽히 찾아내진 못해서 구글링의 힘을... 빌렸다. ㅜ ㅜ
