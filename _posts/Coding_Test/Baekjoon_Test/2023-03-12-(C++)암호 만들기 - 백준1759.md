---
title:  "[C++]암호 만들기 - 백준1759"
categories : [BaekjoonTest]
tag : [백준, 프로그래머스, 알고리즘 문제풀이]
toc: true
toc_sticky: true
author_profile: false
sidebar:
   nav: "docs"
typora-root-url: ../../..
---



## 문제

* **[암호 만들기(백준1759)](https://www.acmicpc.net/problem/1759)**

<br><br>

## 풀이

**문제 해석을 하자면,**

* 아래 조건 만족하는 암호를 전부 출력하는 문제이다.
  * 암호는 최소 1개 모음, 2개 자음으로 구성. 
  * 그리고 서로 다른 소문자들로 구성.
  * 또한, 알파벳이 암호에서 증가하는 순서로 배열되었을 것


<br>

**풀이**

* 알파벳이 각 암호에서 증가하는 순서로 되어있기 때문에 정렬먼저(오름차순)
* 이후 DFS + 백트래킹
* 다만, 최소 1개 모음, 2개 자음인지 확인하는것도 까먹지 말기


<br><br>

## 코드

```c++
#include <iostream>
#include <algorithm>
using namespace std;

bool dfsBoolArr[20];
char inArr[20];
char outArr[20];
char vowels[5] = { 'a', 'e', 'i', 'o', 'u' };

int L, C;
int i, j, k;

void dfs(int, char);

int main() {
	// input
	cin >> L >> C;
	for (i = 0; i < C; i++) cin >> inArr[i];

	// run
	// 알파벳이 암호에서 증가하는 순서로 배열되었을 것이라고 추측이므로 정렬먼저(오름차순)
	sort(&inArr[0], &inArr[C]);
	dfs(0, '0');


	return 0;
}

void dfs(int depth, char preValue) {
	if (depth == L) {
		// 최소 1개 모음, 2개 자음인지 확인
		int check = 0;
		for (int i = 0; i < L; i++) {
			for (int j = 0; j < 5; j++) {
				if (vowels[j] == outArr[i]) { check++; continue; }
			}
		}
		if (check < 1 || (L - check) < 2) return;

		// 출력
		for (int i = 0; i < L; i++) {
			cout << outArr[i];
		}
		cout << '\n';
		return;
	}

	for (int i = 0; i < C; i++) { 
		if (!dfsBoolArr[i] && preValue < inArr[i]) { // 알파벳 각 한줄 오름차순!!
			dfsBoolArr[i] = true;
			outArr[depth] = inArr[i];
			dfs(depth + 1, inArr[i]);
			dfsBoolArr[i] = false; // backtracking
		}
	}

}
```

<br><br>

## 느낀점

생략
