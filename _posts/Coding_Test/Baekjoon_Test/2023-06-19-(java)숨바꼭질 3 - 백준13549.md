---
title:  "[java]숨바꼭질 3 - 백준13549"
categories : [BaekjoonTest]
tag : [백준, 프로그래머스, 알고리즘 문제풀이]
toc: true
toc_sticky: true
author_profile: false
sidebar:
   nav: "docs"
typora-root-url: ../../..
---



## 문제

* **[숨바꼭질 3(백준13549)](https://www.acmicpc.net/problem/13549)**

<br><br>

## 풀이

**문제 해석을 하자면,**

* 숨바꼭질 4를 풀었던 풀이 게시물을 참고하고, 이번 문제와의 차이점은 2*x일 때 배열에 +1을 하지 않았다는 점이다.

<br>

**풀이**

* 생략
  

<br><br>

## 코드

```java
/**
 * 숨바꼭질4 풀었던거 참고
 * 차이점은 2*X일땐 배열에 +1을 하지않았다는 점이다.
 */

static int N, K;
static int[] dist = new int[200005];

static void bfs() {
    // init
    Arrays.fill(dist,-1); // 방문기록 확인 위해
    Queue<Integer> qu = new LinkedList<>();
    qu.add(N);
    dist[N] = 0;

    while(!qu.isEmpty()) {
        int cur = qu.peek(); qu.remove();
        if(cur < 0 || cur > 200000) continue; // 범위체크
        for(int i=0; i<3; i++) {
            if(i==0) { // 2*X => 0초
                int nxt = cur*2;
                // 범위체크, 방문확인
                if(nxt < 0 || nxt > 200000 || dist[nxt]!=-1) continue;
                dist[nxt] = dist[cur]; // 0초라서 +1 하지말것.
                qu.add(nxt);
            }
            else if(i==1) { // X-1
                int nxt = cur-1;
                // 범위체크, 방문확인
                if(nxt < 0 || nxt > 200000 || dist[nxt]!=-1) continue;
                dist[nxt] = dist[cur] + 1;
                qu.add(nxt);
            }
            else { // X+1
                int nxt = cur+1;
                // 범위체크, 방문확인
                if(nxt < 0 || nxt > 200000 || dist[nxt]!=-1) continue;
                dist[nxt] = dist[cur] + 1;
                qu.add(nxt);
            }
        }
    }
}

public static void main(String[] args) throws IOException {
    // input
    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
    StringTokenizer stk = new StringTokenizer(br.readLine(), " ");
    N = Integer.parseInt(stk.nextToken());
    K = Integer.parseInt(stk.nextToken());

    // run
    bfs();

    // output
    System.out.println(dist[K]);
}
```

<br><br>

## 느낀점

**생략**
