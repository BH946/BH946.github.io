---
title:  "[MySQL]LV 2 문제 모음"
categories : [ProgrammersTest]
tag : [백준, 프로그래머스, 알고리즘 문제풀이]
toc: true
toc_sticky: true
author_profile: false
sidebar:
   nav: "docs"
typora-root-url: ../../..
---



## Intro

SQL 문제들은 많이 없기 때문에 `LV 1 ~ LV 5` 까지 문제들을 레벨별로 모아서 한번에 정리하겠다.

<br><br>

## 문제 1 - datediff, group by, having

* **[자동차 평균 대여 기간 구하기](https://school.programmers.co.kr/learn/courses/30/lessons/157342)**

<br>

### 코드

```mysql
SELECT car_id, round(avg(DATEDIFF(end_date,start_date)+1),1) as average_duration from car_rental_company_rental_history group by car_id having average_duration >= 7 order by average_duration desc, car_id desc;
```

<br>

### 풀이

우선 `round(avg(DATEDIFF(end_date,start_date)+1),1) as average_duration` 를 이해하고 뒤에 그룹으로 나누고, 정렬한 것을 이해해보자.

* `DATEDIFF(end_date,start_date)+1)` 는 두 날짜의 차이를 구해주는 메소드이다.
  * `+1` 은 1일 ~ 10일 일때 9(=10-1)일이 아닌 10일을 빌린것이기 때문
* `round(avg(DATEDIFF....),1) as average_duration` 는 평균, 반올림 그리고 컬럼명 지정이다.
  * **소수점 둘째자리에서 반올림=소수점 첫재짜리까지 반올림 을 의미** 


`group by car_id having average_duration >= 7 order by average_duration desc, car_id desc;`

* `group by` 문법 이후에 `having` 문법으로 해당 그룹에 조건을 줄 수 있다!
  * `where` 문법에는 방금 생성한 필드명인 `average_duration` 을 바로 사용불가
  * `where` 은 그룹화 전을 필터링, `having` 은 그룹화 후 필터링의 차이!!
* `order by` 로 정렬할 때 나열을 해서 여러개 정렬이 가능하다. (정렬 순번은 나열 순서대로 적용)

<br><br>

## 문제 2 - join

* **[조건에 맞는 도서와 저자 리스트 출력하기](https://school.programmers.co.kr/learn/courses/30/lessons/144854)**

<br>

### 코드

```mysql
# 첫번째 방법
SELECT b.book_id, a.author_name, date_format(b.published_date,'%Y-%m-%d') as published_date from book b, author a where b.author_id = a.author_id and b.category = '경제' order by b.published_date;

# 두번째 방법(join)
SELECT b.book_id, a.author_name, date_format(b.published_date,'%Y-%m-%d') as published_date from book b join author a on (b.author_id = a.author_id) where b.category = '경제' order by b.published_date;
```

<br>

### 풀이

`date_format` 사용법과 `A join B on (...)` 사용을 익혀두자!

참고로 두 테이블을 조인할 땐 `b.author_id = a.author_id` 처럼 연결하는 개념이 필수

- inner join : `SELECT * from book b join author a on (b.author_id = a.author_id) where b.category = '경제';`
  - id 컬럼이 중복해서 존재 (즉, id 컬럼 2개 출력 됨) -> 근데 원하는 컬럼명만 선정해서 출력하면 상관없긴 함.

- natural join : `SELECT * from book b natural join author a where b.category = '경제';`
  - id 컬럼의 중복을 제거 (즉, id 컬럼 1개 출력 됨)

따라서 행이 중복되어 나오는건 전혀 join 종류랑은 상관 없는 이야기. 그저 1:N, N:N 이런식의 관계에 join을 하게되면 중복 행이 발생할 가능성이 있는 것이다.   

distinct를 사용해서 제거 필요.  
물론, distinct를 사용하게끔 설계된 것은 잘 못 설계했을 가능성 높다.

<br><br>

## 문제 3 - having절 중복 활용(count(*)>1)

* **[재구매가 일어난 상품과 회원 리스트 구하기](https://school.programmers.co.kr/learn/courses/30/lessons/131536)**

<br>

### 코드

```mysql
SELECT user_id, product_id from online_sale group by user_id, product_id having count(*)>1 order by user_id asc, product_id desc;
```

<br>

### 풀이

문법은 이해가 될 것이고, 왜 그룹과 그룹에 조건을 주면서 해결이 된것인지 설명하겠다.

`group by` 를 `user_id, product_id` 두개를 하게되면 두개를 조합해서 분류되게끔 분류가된다.

* 즉, 복합키 처럼 2개를 조합해서 기본키 형태로 나타낸다는 의미이다.
* 또한, 기본키 성질처럼 그룹 성질상 `1, 2, 3...` 으로 분류가되지 `1, 1, 1, 2, 2, 3...` 으로 중복되게 분류되지 않는다.

* 즉, 중복은 출력하지 않으므로 그룹을 지정할때 `having` 으로 중복 있는지 검사한것이다.
  * **중복 있으면 재구매한 데이터이므로!!!**

<br><br>

## 문제 4 - 언제 join 사용? bit 연산 심화?

* **[부모의 형질을 모두 가지는 대장균 찾기](https://school.programmers.co.kr/learn/courses/30/lessons/301647)**

<br>

### 코드

```mysql
select b.id, b.genotype, a.genotype as parent_genotype from ecoli_data a join ecoli_data b on (a.id=b.parent_id)
where a.genotype & b.genotype = a.genotype order by b.id;
```

<br>

### 풀이

테이블에 id, parent_id 컬럼이 존재하는데, 문제를 잘 보면 parent_id 값과 동일한 id 행을 찾아가서 형질을 비교해야 한다.

-  join을 parent_id = id 로 구하면 해결 가능이다.

bit 연산의 경우 `a.genotype & b.genotype = a.genotype` 를 이해하자.

- 2진수가 만약 a:1011, b:1111 라면 & 연산의 결과는 1011 이 되고, a가 기준이 됨을 알 수 있다.
- 그래서 `= a.genotype` 까지 필요하다.

<br><br>

## 문제 5 - 서브쿼리는 메인쿼리에 종속, SQL 실행 순서

* **[연도별 대장균 크기의 편차 구하기 ](https://school.programmers.co.kr/learn/courses/30/lessons/299310)**

<br>

### 코드

```mysql
select year(differentiation_date) as year, 
(select max(size_of_colony) from ecoli_data where year(differentiation_date)=year)-size_of_colony as year_dev, id
from ecoli_data order by year, year_dev;
```

<br>

### 풀이

서브쿼리는 메인쿼리에 종속 관계이므로 메인쿼리의 year 별칭을 가져다 사용 가능

SQL 실제 실행 순서는 `from -> where -> group by -> select -> order by` 순 이므로 order by 에서 select 절의 결과를 가져다 사용 가능

- **(TMI)여기서 사용자 편의를 위해 MySQL에서는 GROUP BY, ORDER BY, HAVING절에서는 SELECT 절에 정의된 별칭을 사용할수 있다.**
- **(TMI)서브쿼리는 select 절, from 절, where 절에 사용 가능하다. 각각 스칼라 서브쿼리, 인라인 뷰, 서브쿼리라 부른다.**

<br><br>

## 문제 6 - case when 심화, select 별칭 사용

* **[ 분기별 분화된 대장균의 개체 수 구하기](https://school.programmers.co.kr/learn/courses/30/lessons/299308)**

<br>

### 코드

```mysql
select 
(case 
 when month(differentiation_date) >=1 and month(differentiation_date) <=3 then '1Q'
 when month(differentiation_date) >=4 and month(differentiation_date) <=6 then '2Q'
 when month(differentiation_date) >=7 and month(differentiation_date) <=9 then '3Q'
 else '4Q'
 end) as quarter, count(*) as ecoli_count
 from ecoli_data group by quarter order by quarter;
```

<br>

### 풀이

조건문을 여러개 작성할 때 `when ... then` 을 반복한다.

서브쿼리는 메인쿼리에 종속 관계이므로 메인쿼리의 year 별칭을 가져다 사용 가능

SQL 실제 실행 순서는 `from -> where -> group by -> select -> order by` 순

- **(TMI)여기서 사용자 편의를 위해 MySQL에서는 GROUP BY, ORDER BY, HAVING절에서는 SELECT 절에 정의된 별칭을 사용할수 있다.**

<br><br>

## 문제 7 - date_format, having 심화

* **[월별 잡은 물고기 수 구하기](https://school.programmers.co.kr/learn/courses/30/lessons/293260)**

<br>

### 코드

```mysql
select count(*) as fish_count, month(time) as month from fish_info
group by month order by month;

-- date_format(time,'%c') 실패 -> 문제에서 숫자 타입이라 해서
-- having count(month) > 0 생략 가능 -> 어차피 group by에서 없는 값은 출력 안하므로
select count(*) as fish_count, date_format(time,'%c') as month from fish_info
group by month having count(month) > 0 order by month;
```

<br>

### 풀이

`date_format` 를 원래 'Y-%m-%d' 로 보통 쓰고 있었다.

- %c : 월 을 한자리 수로 -> 단, 문자 타입
- %e : 일 수를 한자리 수로
- %y : 년 도를 두자리 수로 -> ex : 2024 라면 24

`having count(month) > 0` 은 값이 없는걸 출력 안하게 할 수 있다.

- group by에서 이미 없는 값은 출력 안하므로 있으나 마나이긴 하다.

<br><br>

## 문제 8 - 숫자 정렬이면 문자 꼭 제외

* **[노선별 평균 역 사이 거리 조회하기](https://school.programmers.co.kr/learn/courses/30/lessons/284531)**

<br>

### 코드

```mysql
-- hint: 내림차순 정렬은 'km'를 제외한 숫자만 정렬할 것

select route, concat(round(sum(d_between_dist),1),'km') as total_distance, concat(round(avg(d_between_dist),2),'km') as average_distance from subway_distance group by route order by round(sum(d_between_dist),1) desc;
```

<br>

### 풀이

문제에서 총 누계 거리를 기준으로 내림차순을 하라고 했는데 숫자이므로 숫자로만 정렬하자.

**즉, 'km'를 붙인 별칭 total_distance 로 정렬하면 실패!**

<br><br>

## 문제 9 - distinct

* **[조건에 맞는 개발자 찾기](https://school.programmers.co.kr/learn/courses/30/lessons/276034)**

<br>

### 코드

```mysql
select distinct id, email, first_name, last_name from developers d, skillcodes s where d.skill_code & s.code = s.code and s.name in("Python", "C#") order by d.id;
```

<br>

### 풀이

`d.skill_code & s.code = s.code` 은 where 절에서 d스킬 코드에 대해 s코드 전체를 순회하면서 &연산을 한다.

이때, Python 따로, C# 따로 중복으로 조건 성립해서 출력되므로 중복 제거를 위해 **distinct 사용**

<br><br>

## 문제 10 - 2연속 join

* **[업그레이드 된 아이템 구하기](https://school.programmers.co.kr/learn/courses/30/lessons/273711)**

<br>

### 코드

```mysql
-- from -> where -> group by -> select -> order by
-- 서브쿼리 여러번 사용 방식 (효율X)
select b.item_id, 
(select item_name from item_info where b.item_id = item_id) as item_name, 
(select rarity from item_info where b.item_id = item_id) as rarity from item_info a join item_tree b on (a.item_id=b.parent_item_id) where a.rarity='RARE' order by b.item_id desc;

-- 조인 2연속 방식 (효율적)
select c.item_id, c.item_name, c.rarity  
from item_info a 
join item_tree b on (a.item_id=b.parent_item_id)  
join item_info c on (b.item_id=c.item_id)
where a.rarity='RARE' order by b.item_id desc;
```

<br>

### 풀이

처음에는 select 절에 서브쿼리를 2개나 작성하는 코드를 구현했는데,

다른 사람들의 힌트를 보니 join으로만 해결한 사람이 있길래 조인을 2연속 하는 방식으로 풀이했다.

- item_info 의 item_id와 item_tree 의 parent_item_id 를 먼저 join 한 후
- 조인된 id값의 item_info 정보를 구하기 위해 한번 더 item_info 와 조인한다.

<br><br>

## 문제 11 - order by 주의점

* **[진료과별 총 예약 횟수 출력하기](https://school.programmers.co.kr/learn/courses/30/lessons/132202)**

<br>

### 코드

```mysql
SELECT mcdp_cd as '진료과코드', count(*) as '5월예약건수' from appointment where year(apnt_ymd)=2022 and month(apnt_ymd)=5 group by mcdp_cd order by 5월예약건수, 진료과코드;
```

<br>

### 풀이

`ORDER BY` 를 사용하는 경우에 MYSQL에서는 따옴표로 감싸면 하나의 컬럼으로 처리하기에 따옴표를 지워서 열의 별칭이나 실제 이름으로 작성하면 됩니다.

- 즉, `order by '5월예약건수', '진료과코드'` 이렇게 작성시 채점 실패

<br><br>

## 문제 12 - floor (버림) + ceil (올림) + truncate (자름)

* **[ 가격대 별 상품 개수 구하기](https://school.programmers.co.kr/learn/courses/30/lessons/131530)**

<br>

### 코드

```mysql
select floor(price/10000)*10000 as price_group, count(*) as products from product 
group by floor(price/10000) order by price_group asc;
```

<br>

### 풀이

0~10000, 10000~20000 등 각 부분들을 0원, 만원, 2만원 이런식으로 그룹핑 해달라고 했는데,

버림을 통해서 0,1,2,3... 으로 그룹핑 했고, 출력은 10000을 곱해서 만원 단위로 나오게 했다.

- 반올림: `ROUND(value, decimals)`
- 버림: `FLOOR(value)`
- 올림: `CEIL(value)` 또는 `CEILING(value)`
- 자르기: `TRUNCATE(value, decimals)`

<br><br>

## 문제 13 - substring (문자 자르기)

* **[ 카테고리 별 상품 개수 구하기](https://school.programmers.co.kr/learn/courses/30/lessons/131529)**

<br>

### 코드

```mysql
SELECT substring(product_code,1,2) as category, count(*) as products from product group by category order by category;
```

<br>

### 풀이

부분 문자열 추출: `SUBSTRING(string, position, length)` 또는 `SUBSTRING(string FROM position FOR length)`

<br><br>

## 문제 14 - 서브쿼리에 group by절 사용, distinct

* **[ 중복 제거하기](https://school.programmers.co.kr/learn/courses/30/lessons/59408)**

<br>

### 코드

```mysql
-- from절에 서브쿼리로 group by 사용하여 count(name)>1 then 1 적용하여 나타냄
-- 메인쿼리엔 전체 개수 세는걸로 마무리
SELECT count(*) as count from 
(select (case when count(name)>1 then 1 else count(name) end) from animal_ins group by name having name is not null) a;

-- 더 쉬운 풀이
SELECT COUNT(DISTINCT NAME) AS COUNT
FROM ANIMAL_INS
WHERE NAME IS NOT NULL;
```

<br>

### 풀이

`count(name)>1 then 1` 부분이 중복 제거!

`COUNT(DISTINCT NAME)` 처럼 distinct를 이렇게도 사용이 가능!

<br><br>

