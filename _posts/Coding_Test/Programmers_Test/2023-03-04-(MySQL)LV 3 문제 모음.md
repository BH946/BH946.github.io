---
title:  "[MySQL]LV 3 문제 모음"
categories : [ProgrammersTest]
tag : [백준, 프로그래머스, 알고리즘 문제풀이]
toc: true
toc_sticky: true
author_profile: false
sidebar:
   nav: "docs"
typora-root-url: ../../..
---



## Intro..

SQL 문제들은 많이 없기 때문에 `LV 1 ~ LV 5` 까지 문제들을 레벨별로 모아서 한번에 정리하겠다.

<br><br>

## 문제 1 - 집계함수 max, date

* **[자동차 대여 기록에서 대여중 / 대여 가능 여부 구분하기](https://school.programmers.co.kr/learn/courses/30/lessons/157340)**

<br>

### 코드

```mysql
-- 날짜비교1 -> date함수 사용
SELECT CAR_ID, max(case when START_DATE<=DATE(20221016) && END_DATE >= Date(20221016) 
then "대여중" else "대여 가능" end) as AVAILABILITY 
from CAR_RENTAL_COMPANY_RENTAL_HISTORY group by car_id order by car_id desc;

-- 날짜비교2 -> date함수 미사용
select car_id, max(
case when (start_date <= '2022-10-16' and end_date >= '2022-10-16') then '대여중'
else '대여 가능' end) as availability 
from car_rental_company_rental_history 
group by car_id order by car_id desc;
```

<br>

### 풀이

`max(case when START_DATE<=DATE(20221016) && END_DATE >= Date(20221016) 
then "대여중" else "대여 가능" end)`

* 중요한 점은 왜??? `max()` 를 사용했냐는 것이다.
  * 위 조건의 결과로 "대여중", "대여 가능" 이 둘다 구해졌을경우?? `max()` 함수는 "대여중" 을 더 큰값으로 보고 출력해준다!!
    * 잘 생각해보면 위 조건문의 경우 동일한 `CAR_ID` 가 여러개 있으므로 "대여중", "대여 가능" 둘다 구해지는 경우가 존재한다!! => 그래서 `max()` 로 "대여중" 을 선택
    * 문자열 비교해보면 "대여 가능"보다 "대여중"이 더 큼
  * 또 다른 방법으로는, 삽입 쿼리문인 `IN 쿼리문` 을 통해서도 간단히 해결할 수 있다.

<br><br>

## 문제 2 - having 서브쿼리? 단일행, 다중행

* **[대여 횟수가 많은 자동차들의 월별 대여 횟수 구하기](https://school.programmers.co.kr/learn/courses/30/lessons/151139)**
* **그룹핑 결과에 조건문 다는건 having**

<br>

### 코드

```mysql
-- having 에 서브쿼리
-- 서브쿼리 종류 -> 단일행, 다중행

select month(start_date) as month, car_id, count(*) as records 
from car_rental_company_rental_history 
group by month, car_id having month >= 8 and month <= 10 and 
car_id in(select car_id from car_rental_company_rental_history 
where month(start_date) >= 8 and month(start_date) <= 10 group by car_id having count(*)>=5)
order by month, car_id desc;
```

<br>

### 풀이

핵심 코드 : `car_id in(select car_id from car_rental_company_rental_history 
where month(start_date) >= 8 and month(start_date) <= 10 group by car_id having count(*)>=5)` 

* 그룹절의 조건문 자리(having)에 IN 쿼리문을 사용했다.
* 총 대여 횟수를 구하기 위해서는 서브쿼리가 필요했다.
  * **다중행의 경우 in, any, all 연산자를 사용**
  * [참고](https://chl9413.tistory.com/40)


<br><br>

## 문제 3 - 서브쿼리 다중행

* **[즐겨찾기가 가장 많은 식당 정보 출력하기](https://school.programmers.co.kr/learn/courses/30/lessons/131123)**

<br>

### 코드

```mysql
select food_type, rest_id, rest_name, favorites from rest_info
where (food_type, favorites) in (select food_type, max(favorites) from rest_info group by food_type) order by food_type desc; 
```

<br>

### 풀이

`where (food_type, favorites) in (select food_type, max(favorites) from rest_info group by food_type)` 이 핵심이다.

- 서브쿼리를 group by 를 활용했으므로 food_type은 중복없이 나오는건 자명하고,
- 다중행이므로 `in` 을 사용하고, 다중 컬럼이라 `(food_type, favorites)` 로 비교했다.

<br><br>

## 문제 4 - 서브쿼리 not in

* **[오랜 기간 보호한 동물(1)](https://school.programmers.co.kr/learn/courses/30/lessons/59044)**

<br>

### 코드

```mysql
select name, datetime from animal_ins 
where animal_id not in (select a.animal_id from animal_ins a join animal_outs b on (a.animal_id=b.animal_id)) 
order by datetime asc limit 3;
```

<br>

### 풀이

`where animal_id not in (select a.animal_id from animal_ins a join animal_outs b on (a.animal_id=b.animal_id)) ` 가 핵심!!

* `in 쿼리문` 에서 `join` 한 값 `animal_id`  이 동일하지 않는(`not in`)것을 조건으로 한다!!

<br><br>

## 문제 5 - having절은 group by 결과를 사용

* **[조건에 맞는 사용자와 총 거래금액 조회하기](https://school.programmers.co.kr/learn/courses/30/lessons/164668)**

<br>

### 코드

```mysql
select b.user_id, b.nickname, sum(a.price) as total_sales from used_goods_board a join used_goods_user b on (a.writer_id=b.user_id) 
where a.status='DONE'
group by b.user_id having total_sales >= 700000 
order by total_sales;
```

<br>

### 풀이

group by 절의 결과를 보면 `b.user_id, b.nickname, total_sales` 이다. 

having 절은 위 결과를 사용한다. 따라서 갑자기 `b.city` 같은 컬럼을 사용하면

**"Unknown column 'b.city' in 'having clause" 에러가 발생한다.**

<br><br>

## 문제 6 - substr과 concat, 1:N 중복 join 해결

* **[조건에 맞는 사용자 정보 조회하기](https://school.programmers.co.kr/learn/courses/30/lessons/164670)**

<br>

### 코드

```mysql
-- substr + concat 조합!
-- 1:N 이다 보니 중복 존재 -> distinct
select distinct b.user_id, b.nickname, concat(b.city,' ', b.street_address1,' ', b.street_address2) as '전체주소', concat(substr(b.tlno,1,3),'-',substr(b.tlno,4,4),'-',substr(b.tlno,8,4)) as '전화번호'
from used_goods_board a join used_goods_user b on (a.writer_id=b.user_id) 
where b.user_id in (select writer_id from used_goods_board group by writer_id having count(*)>=3) 
order by b.user_id desc;

-- 서브쿼리 없이 바로 끝내는 방법 -> 사실 이게 더 효율적 일 듯
select b.user_id, b.nickname, concat(b.city,' ', b.street_address1,' ', b.street_address2) as '전체주소', concat(substr(b.tlno,1,3),'-',substr(b.tlno,4,4),'-',substr(b.tlno,8,4)) as '전화번호'
from used_goods_board a join used_goods_user b on (a.writer_id=b.user_id) 
group by b.user_id having count(*)>=3 
order by b.user_id desc;
```

<br>

### 풀이

`concat` 메소드 사용, 기존 `+` 연산으로는 문자+숫자 인 경우 에러가 발생하므로 `concat`을 추천

`substr` 까지 함께 기억해두자.

두 코드의 차이점은 `in 쿼리문` 을 사용했냐 안했냐의 차이일 뿐 동일하다.

- 물론 group by를 바로 사용한 쿼리는 중복 걱정없이 해결이 된 반면,
- in 쿼리문에 group by를 사용한 쿼리는 1:N 테이블 관계상 중복을 피할 수 없어서 distinct로 해결했다.

<br><br>

## 문제 7 - 단일행 서브쿼리

* **[조회수가 가장 많은 중고거래 게시판의 첨부파일 조회하기](https://school.programmers.co.kr/learn/courses/30/lessons/164671)**

<br>

### 코드

```mysql
select concat('/home/grep/src/',b.board_id,'/',file_id,file_name,file_ext) as file_path from used_goods_board a join used_goods_file b on (a.board_id=b.board_id) 
where a.views = (select max(views) from used_goods_board) 
order by b.file_id desc;
```

<br>

### 풀이

`where a.views = (select max(views) from used_goods_board)` 가 핵심!

* in 쿼리문 뿐만아니라 "=" 으로도 비교 가능하다 (단일행이라서!)

<br><br>

## 문제 8 - not in 활용

* **[업그레이드 할 수 없는 아이템 구하기](https://school.programmers.co.kr/learn/courses/30/lessons/273712)**

<br>

### 코드

```mysql
-- A->B : A가 부모, B가 업데이트 완료상태
-- 최종 업데이트 : 자신을 부모로 가지고 있지 않은 아이템을 찾으면 된다. (not in 활용)

select a.item_id, a.item_name, a.rarity from item_info a join item_tree b on (a.item_id=b.item_id) 
where a.item_id not in (select a.item_id from item_info a join item_tree b on (a.item_id=b.parent_item_id)) 
order by a.item_id desc;
```

<br>

### 풀이

`select a.item_id, a.item_name, a.rarity from item_info a join item_tree b on (a.item_id=b.item_id) ` 처음 from절의 join문은 select의 컬럼을 출력하기 위한 목적이고,

`where a.item_id not in (select a.item_id from item_info a join item_tree b on (a.item_id=b.parent_item_id)) ` 두번째 where절의 join문이 핵심이다.

- 문제를 해석해보면 "최종 업데이트는 자신을 부모로 가지고 있지 않은 아이템" 이다.
- 따라서 오히려 자신을 부모로 가지는 아이템을 join문으로 구하고, 
- 이것을 `not in` 을 통해 자신을 부모로 가지지 않는 아이템을 구한 것이다.

<br><br>

## 문제 9 - 서브쿼리에 group by 활용

* **[물고기 종류 별 대어 찾기](https://school.programmers.co.kr/learn/courses/30/lessons/293261)**

<br>

### 코드

```mysql
-- 코드를 작성해주세요
-- 두 테이블 정보가 필요해서 from 절에서 먼저 join
-- "물고기 종류 별 가장 큰 물고기" 를 조건으로 구해야해서 서브쿼리 활용

select a.id, b.fish_name, a.length from fish_info a join fish_name_info b on (a.fish_type=b.fish_type) 
where (a.fish_type, a.length) in (select fish_type, max(length) from fish_info group by fish_type) 
order by a.id;
```

<br>

### 풀이

`select a.id, b.fish_name, a.length from fish_info a join fish_name_info b on (a.fish_type=b.fish_type)` 처음 from절의 join문은 select의 컬럼을 출력하기 위한 목적이고,

`where (a.fish_type, a.length) in (select fish_type, max(length) from fish_info group by fish_type) ` 두번째 where절의 서브쿼리가 핵심!

- "물고기 종류 별" 라서 group by fish_type를 활용하고,
- "가장 큰 물고리" 라서 max(length)를 활용했다.
- 추가로 fish_type 까지 같이 in 연산자로 비교해줘야 정확하게 매핑 되므로 주의하자.

<br><br>

## 문제 10 - left join

* **[ 대장균들의 자식의 수 구하기](https://school.programmers.co.kr/learn/courses/30/lessons/299305)**

<br>

### 코드

```mysql
select a.id, (case when b.parent_id is null then 0 else count(*) end) as child_count from ecoli_data a left join ecoli_data b on (a.id = b.parent_id) 
group by a.id 
order by a.id;
```

<br>

### 풀이

`(case when b.parent_id is null then 0 else count(*) end) as child_count` 는 select 문에 case when 조건문을 사용해서 null 인 값은 0으로 출력해줬다.

`from ecoli_data a left join ecoli_data b on (a.id = b.parent_id) ` 로 left outer join 을 진행한다. 

- 매핑하는 parent_id 가 null 인 경우가 있어서 이부분은 join이 생략 되기 때문이다.
- 출력은 전체 id가 다 나와야 하므로 a 테이블을 살리기 위해 left join을 진행했다.

<br><br>

## 문제 11 - 시도조차 못함, 백분율 문제(percent_rank,over,with)

* **[ 대장균의 크기에 따라 분류하기 2](https://school.programmers.co.kr/learn/courses/30/lessons/301649)**

<br>

### 코드

```mysql
with perTable as(
select id, percent_rank() over (order by size_of_colony desc) as per 
from ecoli_data
)

select a.id, 
(case when per <= 0.25 then 'CRITICAL' 
when per <= 0.5 then 'HIGH' 
when per <= 0.75 then 'MEDIUM' 
else 'LOW' end) as colony_name 
from ecoli_data a join perTable b on(a.id=b.id) 
order by a.id;

-- with를 사용 안하고도 당연히 가능 -> from 절에 바로!
select a.id, 
(case when a.per <= 0.25 then 'CRITICAL' 
when a.per <= 0.5 then 'HIGH' 
when a.per <= 0.75 then 'MEDIUM' 
else 'LOW' end) as colony_name 
from (select id, percent_rank() over (order by size_of_colony desc) as per 
from ecoli_data) as a
order by a.id;
```

<br>

### 풀이

`with` 란 서브쿼리, 임시 테이블처럼 활용할 수 있는 기능

`percent_rank` 함수는 인수로 지정한 값의 그룹 내의 상대적 위치를 나타내는 백분위수 순위(순위 퍼센트, Percent rank)를 반환한다.

`over` 함수는 윈도우 함수이다. 윈도우 함수는 다양한 계산을 도와준다.

- **PARTITION BY**: 데이터 그룹핑 기준을 정의합니다. 이 기준에 따라 데이터를 나누고 각 그룹 내에서 별도로 계산합니다.
- **ORDER BY**: 윈도우 함수가 적용될 행의 순서를 지정합니다.
- **ROWS 또는 RANGE**: 특정 범위 내의 행을 지정합니다. 이는 더 정교한 윈도우 정의를 가능하게 합니다.
- `over (order by size_of_colony desc)` 를 보면 윈도우 함수를 사용해서 order by를 진행한 모습이다.

<br><br>
