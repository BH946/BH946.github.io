---
title:  "[MySQL]LV 3 문제 모음"
categories : [ProgrammersTest]
tag : [백준, 프로그래머스, 알고리즘 문제풀이]
toc: true
toc_sticky: true
author_profile: false
sidebar:
   nav: "docs"
typora-root-url: ../../..
---



## Intro..

SQL 문제들은 많이 없기 때문에 `LV 1 ~ LV 5` 까지 문제들을 레벨별로 모아서 한번에 정리하겠다.

<br><br>

## 문제 1 - 집계함수 max, date

* **[자동차 대여 기록에서 대여중 / 대여 가능 여부 구분하기](https://school.programmers.co.kr/learn/courses/30/lessons/157340)**

<br>

### 코드

```mysql
-- 날짜비교1 -> date함수 사용
SELECT CAR_ID, max(case when START_DATE<=DATE(20221016) && END_DATE >= Date(20221016) 
then "대여중" else "대여 가능" end) as AVAILABILITY 
from CAR_RENTAL_COMPANY_RENTAL_HISTORY group by car_id order by car_id desc;

-- 날짜비교2 -> date함수 미사용
select car_id, max(
case when (start_date <= '2022-10-16' and end_date >= '2022-10-16') then '대여중'
else '대여 가능' end) as availability 
from car_rental_company_rental_history 
group by car_id order by car_id desc;
```

<br>

### 풀이

`max(case when START_DATE<=DATE(20221016) && END_DATE >= Date(20221016) 
then "대여중" else "대여 가능" end)`

* 중요한 점은 왜??? `max()` 를 사용했냐는 것이다.
  * 위 조건의 결과로 "대여중", "대여 가능" 이 둘다 구해졌을경우?? `max()` 함수는 "대여중" 을 더 큰값으로 보고 출력해준다!!
    * 잘 생각해보면 위 조건문의 경우 동일한 `CAR_ID` 가 여러개 있으므로 "대여중", "대여 가능" 둘다 구해지는 경우가 존재한다!! => 그래서 `max()` 로 "대여중" 을 선택
    * 문자열 비교해보면 "대여 가능"보다 "대여중"이 더 큼
  * 또 다른 방법으로는, 삽입 쿼리문인 `IN 쿼리문` 을 통해서도 간단히 해결할 수 있다.

<br><br>

## 문제 2 - having 서브쿼리? 단일행, 다중행

* **[대여 횟수가 많은 자동차들의 월별 대여 횟수 구하기](https://school.programmers.co.kr/learn/courses/30/lessons/151139)**
* **그룹핑 결과에 조건문 다는건 having**

<br>

### 코드

```mysql
-- having 에 서브쿼리
-- 서브쿼리 종류 -> 단일행, 다중행

select month(start_date) as month, car_id, count(*) as records 
from car_rental_company_rental_history 
group by month, car_id having month >= 8 and month <= 10 and 
car_id in(select car_id from car_rental_company_rental_history 
where month(start_date) >= 8 and month(start_date) <= 10 group by car_id having count(*)>=5)
order by month, car_id desc;
```

<br>

### 풀이

핵심 코드 : `car_id in(select car_id from car_rental_company_rental_history 
where month(start_date) >= 8 and month(start_date) <= 10 group by car_id having count(*)>=5)` 

* 그룹절의 조건문 자리(having)에 IN 쿼리문을 사용했다.
* 총 대여 횟수를 구하기 위해서는 서브쿼리가 필요했다.
  * **다중행의 경우 in, any, all 연산자를 사용**
  * [참고](https://chl9413.tistory.com/40)


<br><br>

## 문제 3 - 서브쿼리 다중행

* **[즐겨찾기가 가장 많은 식당 정보 출력하기](https://school.programmers.co.kr/learn/courses/30/lessons/131123)**

<br>

### 코드

```mysql
select food_type, rest_id, rest_name, favorites from rest_info
where (food_type, favorites) in (select food_type, max(favorites) from rest_info group by food_type) order by food_type desc; 
```

<br>

### 풀이

`where (food_type, favorites) in (select food_type, max(favorites) from rest_info group by food_type)` 이 핵심이다.

- 서브쿼리를 group by 를 활용했으므로 food_type은 중복없이 나오는건 자명하고,
- 다중행이므로 `in` 을 사용하고, 다중 컬럼이라 `(food_type, favorites)` 로 비교했다.

<br><br>

## 문제 

* **[헤비 유저가 소유한 장소](https://school.programmers.co.kr/learn/courses/30/lessons/77487)**

<br>

### 코드

```mysql
# -- 코드를 입력하세요
SELECT id, name, host_id from places where host_id in (select host_id from places group by host_id having count(*)>=2) order by id;
```

<br>

### 풀이

**`where host_id in (select host_id from places group by host_id having count(*)>=2)` 이부분이 핵심인 문제!!**

* 여러가지 방법들이 있겠지만, 필자의 생각에는 `host_id` 가 동일한 튜플을 카운트해서 2이상이면 된다고 생각했다.
  * 카운트는 `host_id`로 그룹핑을 해서 `count(*)` 함수를 사용!!
* 다만, 여기서 출력에는 그룹핑을 하면 안되니까 `in 쿼리문` 으로 따로 구한것!!
  * 마지막으로 `where` 문에 `in 쿼리문` 을 한 이유는 `0 or 1` 로 쿼리문 반환하기 때문에 조건문 자리인 `where` 문에 적용!!

<br><br>

## 문제 8

* **[오랜 기간 보호한 동물(2)](https://school.programmers.co.kr/learn/courses/30/lessons/59411)**

<br>

### 코드

```mysql
-- 코드를 입력하세요
# 보호기간은 outs의 datetime - ins의 datetime
# 눈여겨 볼것은 order by 뒤에 바로 b.datetime-a.datetime!!!
# 또한 limit 2로 상위 2개 튜플 출력!!
SELECT b.animal_id, b.name from animal_ins a join animal_outs b on (b.animal_id=a.animal_id) order by b.datetime-a.datetime desc limit 2;
```

<br>

### 풀이

**`SELECT b.animal_id, b.name from animal_ins a join animal_outs b on (b.animal_id=a.animal_id)` 처럼 적절히 조인문을 사용하는것도 중요!!**

* 애초에 외래키를 알려줬으므로 조인문을 사용해보는것을 바로 떠올렸던 문제이다.
* 또한, `animal_outs` 테이블에 접근해서 칼럼들을 가져오는게 옳다.

**`order by b.datetime-a.datetime desc limit 2;` 개인적으로 이부분이 핵심!!**

* `order by` 부분에 칼럼명에 적는형태를 바로 적을 수 있다는점!!!
* 또한, `limit` 를 통해서 상위 지정된 개수만큼 튜플만 가져올 수 있다!

<br><br>

## 문제 9

* **[오랜 기간 보호한 동물(1)](https://school.programmers.co.kr/learn/courses/30/lessons/59044)**

<br>

### 코드

```mysql
-- 코드를 입력하세요
SELECT a.name, a.datetime 
from animal_ins a
where a.animal_id not in (select a.animal_id from animal_ins a join animal_outs b on a.animal_id=b.animal_id)
order by a.datetime asc limit 3;
```

<br>

### 풀이

**`where a.animal_id not in (select a.animal_id from animal_ins a join animal_outs b on a.animal_id=b.animal_id)` 가 핵심!!**

* `in 쿼리문` 에서 `join` 한 값을 `animal_ins a` 테이블의 `animal_id`  값과 동일하지 않는(not in)것을 조건으로 한다!!

<br><br>

## 문제 10

* **[있었는데요 없었습니다](https://school.programmers.co.kr/learn/courses/30/lessons/59043)**

<br>

### 코드

```mysql
-- 코드를 입력하세요
SELECT a.animal_id, a.name 
from animal_ins a join animal_outs b on a.animal_id=b.animal_id 
where a.datetime > b.datetime order by a.datetime asc;
```

<br>

### 풀이

**이때까지 이전 문제들을 풀어왔다면, 이 문제는 너무 쉽게 느껴지기 때문에 풀이를 생략하겠다**

<br><br>

## 문제 11

* **[없어진 기록 찾기](https://school.programmers.co.kr/learn/courses/30/lessons/59042)**

<br>

### 코드

```mysql
-- 코드를 입력하세요
SELECT animal_id, name from animal_outs
where animal_id not in
(select a.animal_id from animal_ins a join animal_outs b on a.animal_id=b.animal_id)
order by animal_id asc;
```

<br>

### 풀이

**`where animal_id not in
(select a.animal_id from animal_ins a join animal_outs b on ` 이부분만 이해했다면 쉬운 문제이다.**

* 앞에서도 이와 유사한 문제가 있었다. 
* `not in 쿼리문` 을 적절한 위치에서 적절하게 잘 사용하는 연습을 많이 해주자.

<br><br>

## 문제 12

* **[조건에 맞는 사용자와 총 거래금액 조회하기](https://school.programmers.co.kr/learn/courses/30/lessons/164668)**

<br>

### 코드

```mysql
-- 코드를 입력하세요
SELECT b.user_id, b.nickname, sum(a.price) as total_sales from used_goods_board a join used_goods_user b on a.writer_id=b.user_id 
where a.status = "DONE" 
group by b.user_id having sum(a.price) >= 700000 order by total_sales asc;
```

<br>

### 풀이

**`from used_goods_board a join used_goods_user b on a.writer_id=b.user_id ` 이것으로  두 테이블을 조인해서 접근해보았다.**

**`where a.status = "DONE" ` 이 부분도 문제를 잘 읽었다면, 완료된 거래를 의미한다는것을 알 수 있을 것이다.**

**`group by b.user_id having sum(a.price) >= 700000 order by total_sales asc;` 마지막으로 이부분도 중요하다.**

* `having` 부분은 보통 sum같은 함수를 쓰는 것을 사용하도록 하자.

<br><br>

## 문제 13

* **[조건에 맞는 사용자 정보 조회하기](https://school.programmers.co.kr/learn/courses/30/lessons/164670)**
* **`concat` 메소드 기억!@, 기존 `+` 연산으로는 문자+숫자 인 경우 에러가 발생하므로 `concat`을 추천**

<br>

### 코드

```mysql
-- 코드를 입력하세요
SELECT b.user_id, b.nickname, concat(b.city," ", b.street_address1, " ", b.street_address2) as 전체주소, concat(substr(b.tlno,1,3),"-",substr(b.tlno,4,4),"-",substr(b.tlno,8,4)) as 전화번호 
from used_goods_board a join used_goods_user b on b.user_id=a.writer_id 
group by b.user_id having count(*) >=3 order by b.user_id desc;
```

<br>

### 풀이

`b.user_id, b.nickname, concat(b.city," ", b.street_address1, " ", b.street_address2) as 전체주소` 

* `concat` 을 사용해서 연결하였다.

<br><br>

## 문제 14

* **[조회수가 가장 많은 중고거래 게시판의 첨부파일 조회하기](https://school.programmers.co.kr/learn/courses/30/lessons/164671)**

<br>

### 코드

```mysql
-- 코드를 입력하세요
SELECT concat("/home/grep/src/",b.board_id,"/",b.file_id,b.file_name,b.file_ext) as file_path
from used_goods_board a join used_goods_file b on a.board_id=b.board_id 
where a.views in (select max(a.views) from used_goods_board a)
order by b.file_id desc;
```

<br>

### 풀이

**`SELECT concat("/home/grep/src/",b.board_id,"/",b.file_id,b.file_name,b.file_ext) as file_path` 에서 볼것은??**

*  `concat` 함수 사용을 꼭 기억!

**`from used_goods_board a join used_goods_file b on a.board_id=b.board_id `를 해야 두테이블의 연관된 데이터들을 조회 할 수 있는것**

* 어디서 어느 키를 중점으로 join을 하는지 잘 판단

**`where a.views in (select max(a.views) from used_goods_board a)` 이 중요했다**

* 실수로 in 쿼리문에 `()` 를 붙이지 않아서 에러가 발생했었다,,
* 또한 `where` 문에 in 쿼리문을 사용해서 `max` 값을 따로 구해서 사용하는 이런 형태에도 익숙해지자@@

<br><br>

