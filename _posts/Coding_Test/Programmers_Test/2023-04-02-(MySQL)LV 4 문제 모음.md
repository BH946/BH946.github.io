---
title:  "[MySQL]LV 4 문제 모음"
categories : [ProgrammersTest]
tag : [백준, 프로그래머스, 알고리즘 문제풀이]
toc: true
toc_sticky: true
author_profile: false
sidebar:
   nav: "docs"
typora-root-url: ../../..
---



## Intro..

SQL 문제들은 많이 없기 때문에 `LV 1 ~ LV 5` 까지 문제들을 레벨별로 모아서 한번에 정리하겠다.

<br><br>

## 문제 1 - with 심화, right join

* **[입양 시각 구하기(2)](https://school.programmers.co.kr/learn/courses/30/lessons/59413)**

* `with, union, union all, recursive, right join` 이렇게 다양한 함수들을 많이 사용한 문제

  * `with` : CTE(common table expression)을 생성하는 문법

    ```mysql
    WITH [RECURSIVE] TABLE명 AS (
        SELECT - # 비반복문. 무조건 필수
        [UNION ALL] # RECURSIVE 사용 시 필수. 다음에 이어붙어야 할 때 사용
        SELECT - 
        [WHERE -] # RECURSIVE 사용 시 필수. 정지 조건 필요할 때 사용
    )
    ```

  * `union` 은 결합하며 중복제거, `union all` 은 결합하며 중복제거X

  * `right join` 은 오른쪽 테이블의 모든 값을 가져와서 남는게 없도록 함


<br>

### 코드

```mysql
-- 코드를 입력하세요
# 테이블을 만들어서 0~23을 추가한다. 그리고 right join 을 활용하겠다.
with recursive newTable as (
    select 0 as hour 
    union all
    select hour+1 from newTable 
    where hour < 23
)

select b.hour, count(a.animal_id) as count 
from animal_outs a right join newTable b on (hour(a.datetime)=b.hour) 
group by hour order by hour;
```

<br>

### 풀이

`with recursive cts as (...)` 코드로 임시로 테이블을 만든다.

* 테이블을 만들어서 0~23 을 추가하고, 이것을 join 에 사용하게 된다.

`select b.hour, count(a.animal_id) as count 
from animal_outs a right join newTable b on (hour(a.datetime)=b.hour) `

- right join을 활용해서 newTable의 hour(0~23)을 살린다.

`count(*)` 로 안하고 `count(a.animal_id)` 로 하는이유는??

* `count(*)` 로 하면 모든 부분을 따지므로 `b.hour` 부분도 카운트가 되어서 최소 1개 이상이 되기 때문이다.
* 따라서 a쪽 테이블만 개수 세줘야 정상 출력 된다.

<br><br>

## 문제 2 - 서브쿼리, limit

* **[그룹별 조건에 맞는 식당 목록 출력하기](https://school.programmers.co.kr/learn/courses/30/lessons/131124)**


<br>

### 코드

```mysql
select a.member_name, b.review_text, date_format(b.review_date,'%Y-%m-%d') as review_date from member_profile a join rest_review b on (a.member_id=b.member_id) 
where (a.member_id) = (select a.member_id from member_profile a join rest_review b on (a.member_id=b.member_id) 
group by a.member_id order by count(*) desc limit 1) 
order by b.review_date, b.review_text;

-- 최상위 값 구하면 되는거라 limit 1 -> 처음에 max함수만 생각해서 못 풀었다.
# select a.member_id, count(*) as count from member_profile a join rest_review b on (a.member_id=b.member_id) 
# group by a.member_id order by count desc limit 1;
```

<br>

### 풀이

문제에서 리뷰를 가장 많이 작성한 회원의 리뷰들을 조회하는 SQL을 구하라고 하였다.

**서브쿼리를 통해서 해당 회원을 구했는데, 이때 max 함수가 아니라 limit 으로 구하면 된다.**

- max, limit 항상 둘다 생각해보자.

<br><br>

## 문제 3 - count(distinct a.user_id)

* **[그룹별 조건에 맞는 식당 목록 출력하기](https://school.programmers.co.kr/learn/courses/30/lessons/131124)**


<br>

### 코드

```mysql
-- 회원 user_info, 상품판매 online_sale
-- count(distinct a.user_id) 가 핵심

select year(sales_date) as year, month(sales_date) as month, gender, count(distinct a.user_id) as users 
from user_info a join online_sale b on (a.user_id=b.user_id) 
group by year, month, gender having gender is not null 
order by year, month, gender;
```

<br>

### 풀이

위 테이블은 join하면 id부분이 중복이 발생한다.

이를 제거하기 위해 distinct를 사용!

- **count 함수 안에서 사용했다는게 특징**

<br><br>

## 문제 4 - union all

* **[오프라인/온라인 판매 데이터 통합하기](https://school.programmers.co.kr/learn/courses/30/lessons/131537)**


<br>

### 코드

```mysql
-- hint : union all
-- 문제를 읽어보면 join을 생각하는게 아니라 합집합 형태가 필요!

select date_format(a.sales_date,'%Y-%m-%d') as sales_date, a.product_id, a.user_id, a.sales_amount 
from 
(select sales_date, product_id, user_id, sales_amount from online_sale where year(sales_date)=2022 and month(sales_date)=3 
 union all
 select sales_date, product_id, null, sales_amount from offline_sale where year(sales_date)=2022 and month(sales_date)=3 
 ) a
order by a.sales_date, a.product_id, a.user_id;
```

<br>

### 풀이

`ONLINE_SALE` 테이블과 `OFFLINE_SALE` 테이블에서 2022년 3월의 오프라인/온라인 상품 판매 데이터의 판매 날짜, 상품ID, 유저ID, 판매량을 출력하는 SQL문을 작성하라고 했다.

- 두 테이블의 합집합을 구해서 출력하면 되는 문제이다.
- `OFFLINE_SALE`에는 `user_id` 컬럼이 없으므로 null로 출력해서 구한다. (문제에서도 null로 표기하라 했음)

<br><br>

## 문제 5 - timestamp<->date 차이

* **[오프라인/온라인 판매 데이터 통합하기](https://school.programmers.co.kr/learn/courses/30/lessons/131537)**


<br>

### 코드

```mysql
-- timestamp 타입은 date 타입이랑 다르므로 date로 바꿔서 비교 필수

select a.apnt_no, b.pt_name, b.pt_no, a.mcdp_cd, c.dr_name, a.apnt_ymd from appointment a join patient b on (a.pt_no=b.pt_no) join doctor c on (a.mddr_id=c.dr_id) 
where a.mcdp_cd='cs' and a.apnt_cncl_yn='N' and date(a.apnt_ymd) = '2022-04-13' 
order by a.apnt_ymd;
```

<br>

### 풀이

join3개를 했고, date() 함수를 사용했다.

<br><br>

## 문제 6 - join, group by

* **[ 주문량이 많은 아이스크림들 조회하기](https://school.programmers.co.kr/learn/courses/30/lessons/133027)**


<br>

### 코드

```mysql
-- first_half 와 july 테이블은 1:N으로 july 쪽은 sum함수로 구해줘야 한다.
-- 이를 위해 group by 를 활용
select b.flavor from first_half a join july b on (a.flavor=b.flavor) 
group by b.flavor 
order by (sum(b.total_order)+a.total_order) desc 
limit 3;
```

<br>

### 풀이

**7월 아이스크림 총 주문량과 상반기의 아이스크림 총 주문량을 더한 값이 큰 순서대로 상위 3개의 맛을 조회하는 SQL 문을 작성하는 문제이다.**

- 7월 아이스크림 총 주문량은 july 테이블이며 그룹핑을 사용해서 sum 함수를 써야 구해진다.
- 상반기의 아이스크림 총 주문량은 first_half 테이블이며 바로 해당 컬럼을 사용하면 된다.
- 이 둘을 더해서 정렬해야 상위 3개의 맛을 조회할 수 있다.

<br><br>

## 문제 7 - 미친 난이도. 다시. 풀기.

* **[자동차 대여 기록 별 대여 금액 구하기](https://school.programmers.co.kr/learn/courses/30/lessons/151141)**
* **[특정 기간동안 대여 가능한 자동차들의 대여비용 구하기](https://school.programmers.co.kr/learn/courses/30/lessons/157339)**

<br>

### 코드

```mysql

```

<br>

### 풀이

둘다 실패. 못 품..

어렵다..  fee 컬럼 구하는걸 실패한 문제

- with 사용해서 깔끔히 구하는 사람 참고

<br><br>

위 2개 다시 풀고... 나머지... 문제 정리후...

템플릿 만들자. 이후에는 정리한 LV1~4 문제들 다시 풀어보는..! 물론 알고리즘꺼도 풀기 시작해야함.
