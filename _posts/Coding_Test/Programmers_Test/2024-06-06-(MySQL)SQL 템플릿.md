---
title:  "[MySQL]SQL 템플릿"
categories : [ProgrammersTest]
tag : [백준, 프로그래머스, 알고리즘 문제풀이]
toc: true
toc_sticky: true
author_profile: false
sidebar:
   nav: "docs"
typora-root-url: ../../..
---



# SQL 템플릿(MySQL)

너무 기초적인 문법은 생략

SQL 논리적 실행 순서 : `from -> where -> group by -> having -> select -> order by`

MySQL 의 경우 **select의 별칭을 group by, having 에서 사용**할 수 있게 지원 중! (Oracle, SQL Server는 사용 불가)

- **having 절**은 그룹을 나타내는 결과 집합의 행에 조건이 적용, **where 절**은 그룹화 전을 필터링

  - **group by** 절의 결과가 `b.user_id, b.nickname, total_sales` 이고 b.city 컬럼이 b테이블에 존재한다고 가정했을때 **having** 절에 b.city를 사용하면 **"Unknown column 'b.city' in 'having clause" 에러가 발생한다.**
  - 특히 **그룹화 전**에 **여러행의 데이터**를 가지고 있었다면, **그룹화 후**에는 **하나의 행 데이터**를 가지기 때문에 **having** 절에서는 하나의 행 데이터를 비교해야지 여러행의 데이터를 비교할 목적이면 원하는 결과를 얻을 수 없다.
    - **where** 절에서 **여러행의 데이터**를 비교하고 **서브쿼리**로 그룹화 하여 **하나의 행 데이터**를 비교하는 형태로 해결하도록 하자.
    - **having** 절이나 **select** 절에서 **집계함수(max, sum 등)**는 당연히 전체 데이터를 조회해서 구하고, 이 결과가 그룹마다 **하나의 행 데이터**로 나타나는 것이다.

- **인라인뷰(from절 서브쿼리)에 미정의 된 컬럼은 메인쿼리에서 사용 불가**

- **with절**에서 `SELECT *`를 사용할 경우에는 중복된 컬럼명을 명시적으로 처리하지 않으므로 직접 명시를 해줘야 join으로 인한 중복 컬럼 에러를 마주치지 않을 수 있다.

- `최근일 = max(날짜)` 또는 `order by 후 limit 로 상위 n개` 가져오기

  - 햇갈리게 최상위값 구하라 하면 max, limit 둘다 생각해보자

  - ```mysql
    (select a.member_id from member_profile a join rest_review b on (a.member_id=b.member_id) 
    group by a.member_id order by count(*) desc limit 1) 
    ```

- 중복검사 `having절 count(*)>1` 활용, 값의 유무를 확인할 때는 어차피 group by에서 null은 무시하기 때문에 `count(*)>0` 이럴 필요는 없다.  
  추가로 `count(distinct 컬럼)` 이런식으로 select절에서 바로 원하는 컬럼 중복 제거 가능

- **별칭 사용에 주의할 예시** : `concat(round(sum(d_between_dist),1),'km') as a` 라고 해서 a 기준으로 정렬을 하면 문자('km')가 섞여 있어서 원하는 결과를 얻을 수 없고 round() 부분인 숫자 부분만 정렬 해줘야 한다.

- `ORDER BY` 를 사용하는 경우에 MYSQL에서는 따옴표로 감싸면 하나의 컬럼으로 처리하기에 따옴표를 지워서 열의 별칭이나 실제 이름을 작성해야 한다.   
  즉, `SELECT mcdp_cd as '진료과코드'...` 일때 `order by '진료과코드'` 가 아닌 `order by 진료과코드` 로 작성해야 한다.

- 참고)

  - 동일한 car_id가 여러개라서 join 하면 중복으로 여러개 생겨서, 대여 가능 여부(중복 때문에 end_date도 여러개) 판단이 불가능할 때 해결은?

    - 이를 해결하는 핵심코드 : `group by car_id having max(end_date)<'2022-11-01'`
    - 그룹핑으로 car_id 중복을 해결하고, max함수로 end_date 중복을 해결했다.

  - `max(case when START_DATE<=DATE(20221016) && END_DATE >= Date(20221016) 
    then "대여중" else "대여 가능" end)` 처럼 case when 에도 집계함수 사용해 볼 수 있다.

    - "대여중, 대여 가능" 중에서 "대여중"이 더 큰 값으로 출력 해준다.

      - 필터 결과가 여러개면 "대여중", "대여가능" 둘다 성립할 수 있는데 이를 해결해준다.

    - 또 다른 방법으로는 `in 쿼리문` 을 활용해도 된다.  

    - ```mysql
      (case 
       when car_id in (select a.car_id from car_rental_company_rental_history a where a.start_date <= '2022-10-16' and a.end_date >= '2022-10-16') then '대여중' 
       else '대여 가능' 
       end)
      ```

  - **distinct 사용 자세히**

    - `count(distinct 컬럼)` 식으로 집계함수 안에 컬럼에 사용 가능

    - `select distinct 컬럼1, 컬럼2, 컬럼3` 처럼 사용이 기본 사용방식  
      그렇다면 `select * distinct` 와 위 쿼리는 동일하게 동작하는가??

      - 정답은 NO

      - 테이블이 컬럼1~4 까지 있다면 두번째 쿼리는 컬럼1~4 까지 전부 확인해서 중복 행이 있을때 삭제하고, 

      - 첫번째 쿼리는 컬럼1~3 까지만 확인해서 중복 행이 있을때 삭제한다.

      - ```mysql
        -- 1:N join 이다 보니 중복 존재 -> distinct
        -- in 쿼리문 사용 방식
        select distinct b.user_id, b.nickname
        from used_goods_board a join used_goods_user b on (a.writer_id=b.user_id) 
        where b.user_id in (select writer_id from used_goods_board group by writer_id having count(*)>=3) 
        order by b.user_id desc;
        ```

    - `group by` 로 join 중복 해결도 가능

      - ```mysql
        -- group by 로 join 중복 무시 및 having 에 count 써서 해결한 방식
        select b.user_id, b.nickname
        from used_goods_board a join used_goods_user b on (a.writer_id=b.user_id) 
        group by b.user_id having count(*)>=3 
        order by b.user_id desc;
        ```

<br>

**서브쿼리 3가지 종류** : 스칼라 서브쿼리, 인라인뷰, 중첩된 서브쿼리 (select, from, where)

- 특히, **스칼라**는 1행 1열 값을 취급하다 보니 **집계함수**와 콤비가 좋다.

- 인라인뷰는 또다른 하나의 테이블을 만들어 쓴다고 생각해도 좋다.

<br>

**서브쿼리방식**을 구분하자면 2가지 : **동작 방식, 반환 방식**

- 동작 방식 서브쿼리 : 비연관(값) vs 연관(조건)
  - 값 예시 : `(select max(num) from test)`
  - 조건 예시(a는 메인쿼리 from절 테이블 별칭 가정) : `(select id from test where a.id=id)`
- 반환 방식 서브쿼리 : 단일행 vs 다중행 vs 다중컬럼
  - 단일행은 진짜 하나의 튜플 결과가 나오는 것 -> 단일행 내장함수 사용 (젤 간단한거? `=`)
  - 다중행은 여러 튜플 결과가 나오는 것 -> 다중행 내장함수 사용 (`in, any, exists 등`)
  - 다중컬럼은 여러 컬럼으로 결과가 나오는 것
    - 예시 : `...where (a.id, a.type) in (select id, type from test ...)`

**기억할 내장함수 : 단일행 vs 다중행**

- **단일행 : 문자형, 숫자형, 날짜형, 변환형, null**

  - 문자 비교 : `컬럼 like '김%'`

    - 문자열 붙이기 : `concat(컬럼, 'cm')`
      - 기존 `+` 연산으로는 문자+숫자 인 경우 에러가 발생! `concat`을 추천
    - 부분 문자열 추출: `SUBSTRING(string, position, length)` 

  - 첫번째 자리에서 반올림 : `round(컬럼, 0)`

  - null 비교 : `is null or is not null` -> '=' 사용 불가

    - null 연산 결과는 null -> ex: 10000-null = null

  - bit 연산 : `9 & 8 = 1001 & 1000` 의 결과는 `1000` 이다. (&는 and 비트 연산자)

    - `a.skill_code & b.code = b.code` 이런식으로 사용 하는 편이다.
    - 보통 하나만 맞으면 되는 조건들이 많아서 비교할 기준이 되는 비트에는 `sum(code)` 이런식으로 sum 함수로 비트 값을 전부 더해서 비교에 사용하는 아이디어도 있다.
    - 서브쿼리를 활용해도 좋다. `0 < any (select skill_code & a.code from skillcodes a where category = 'front end')` 참고로 category가 front end 인 튜플이 여러개라 가정

  - 날짜형 비교 : `year, month, day, date, date_format, datediff`

    - date 함수는 타입을 date 로 바꾼다 보면 됨.   
      date 함수 없이 '2022-10-16' 이런 형태로 바로 사용해도 잘 동작함.

      - timestamp 타입은 date 타입이랑 다르므로 date로 바꿔서 비교 필수

    - `AND TIME >= date("2021-01-01") AND TIME <= date("2021-12-31")`

      - between 으로 주로 사용 -> 아래는 created_date 컬럼이 date 타입이라 가정
      - `created_date between '2022-10-01' and '2022-10-31'`
      - **주의 : 단 9월은 30일 까지 있는데 31일로 표기 할 시 제대로 동작 안함.**

    - **date_format 사용 방식? -> 소문자 대문자 차이**

      - `date_format(created_date, '%Y-%m-%d')` -> 2022-02-01
      - `date_format(created_date, '%Y-%M-%D')` -> 2022-October-2nd
      - `date_format` 를 원래 'Y-%m-%d' 로 보통 쓰지만 아래도 기억해두자.
        - %c : 월 을 한자리 수로 -> 단, 문자 타입
        - %e : 일 수를 한자리 수로
        - %y : 년 도를 두자리 수로 -> ex : 2024 라면 24

      **datediff(end_date,start_date) ?? -> 날짜 차이 계산 함수**

      - `(case when datediff(end_date,start_date)+1 >= 30 then '장기 대여' else '단기 대여' end) as rent_type`
      - 중요 : 날짜 차이에 **+1 까지** 해줘야 정확한 대여일이 구해 진다.  
        - 2022-01-01 ~ 2022-01-02 차이값을 1로 나타내기 때문이다. 
        - 보통 우리가 보는 기준으로는 차이값이 2가 옳다.

  - 조건 함수 : `case when ... then ... when ... then 반복... else ... end`

  - 반올림, 버림, 올림, 자름 함수 : `round, floor, ceil, truncate`  
    round, floor, ceil 정도만 알아두자.

    - 반올림: `ROUND(value, decimals)`
    - 버림: `FLOOR(value)`
    - 올림: `CEIL(value)` 또는 `CEILING(value)`
    - 자르기: `TRUNCATE(value, decimals)`

- **다중행 : 집계 함수, 그룹 함수, 윈도우 함수** -> "데이터 분석 함수" 라고도 함  
  그룹함수랑 윈도우 함수는 우선 참고 정도만..

  - 집계함수 : `count, sum, max, avg` -> 집계함수는 null 자동 제외
    - 단, count(*) 는 null 값을 포함
    - count(column) 은 null 값 자동 제외
    
  - 그룹함수 : `rollup, cube, grouping sets`
  
  - 윈도우 함수 : `select window_fuction(Arguments) over ([partition by order by windoing])`
  
    - 예시1 : `select rank() over (partition by job order by sal desc) from emp`
  
      - partition by 를 group by 로 생각해도 좋다.
  
    - 예시2 : `select percent_rank() over (order by size_of_colony desc)` 
  
      - ```mysql
        -- 사이즈 내림차순 했을 때의 랭크(%)를 분류하라.
        with perTable as(
        select id, percent_rank() over (order by size_of_colony desc) as per 
        from ecoli_data
        )
        
        select a.id, 
        (case when per <= 0.25 then 'CRITICAL' 
        when per <= 0.5 then 'HIGH' 
        when per <= 0.75 then 'MEDIUM' 
        else 'LOW' end) as colony_name 
        from ecoli_data a join perTable b on(a.id=b.id) 
        order by a.id;
        ```

<br>

**일반 집합 연산자** : union, intersect, except, cross join -> 합집합, 교집합, 차집합, product

- **합집합(union, union all) 정도만 기억** -> union all 은 중복도 포함
  - ex) `ONLINE_SALE` 테이블과 `OFFLINE_SALE` 테이블에서 2022년 3월의 오프라인/온라인 상품 판매 데이터의 판매 날짜, 상품ID, 유저ID, 판매량을 출력하는 SQL문을 작성하라.

**순수 관계 연산자** : where, select, 다양한 join

- 다양한 join -> `(inner) join on 과 (outer) join on` 정도만 기억

  - inner join 예시 (공통 키인 튜플만! 즉, true 행만) 
    - `컬럼1 a join 컬럼2 b join on (a.key=b.key)` 

  - outer join 예시 (매칭 안되는 튜플도 다 포함! 즉, true 아닌 행도 포함)

    - `컬럼1 a join 컬럼2 b left join on (a.key=b.key)` : 왼쪽 테이블 기준

    - `컬럼1 a join 컬럼2 b right join on (a.key=b.key)` : 오른쪽 테이블 기준

    - `컬럼1 a join 컬럼2 b full join on (a.key=b.key)` 

    - **outer join 활용 예시**  

      ```mysql
      -- parent_id 에 null 이 있다고 가정했을때 inner join은 null을 무시하므로 a.id를 전부 살릴 수 없다.
      -- 반면 outer join은 null을 무시하지 않기에 a.id를 전부 살릴 수 있다.
      -- 단, count(*)는 null을 무시하지 않아서 null도 카운트 하고,
      -- count(b.parent_id)같이 컬럼있으면 해당 컬럼의 null은 무시해서 카운트 한다.
      select a.id, count(b.parent_id) as child_count from ecoli_data a left join ecoli_data b on (a.id = b.parent_id) 
      group by a.id 
      order by a.id;
      ```

**중요한 점은 join 이 되었을 때 어떤 식으로 테이블 구조를 이루는지 머리 속에 그려봐야 한다.**

- **animal_id** 를 기준으로 **inner join**한 모습이며, a테이블과 b테이블이 합쳐서 컬럼이 추가된 모습을 알 수 있다. (자연조인이나 using 같은 걸 사용하면 animal_id 컬럼 두개있는 중복을 한개로 바꾼다던지 이런 차이가 있긴 함)
- ![image](https://github.com/BH946/bh946.github.io/assets/80165014/33226ff4-7636-4af1-afef-034cab136ce5) 

- 위 처럼 1:1 로 정확히 매핑 되는것이 아닌 **1:N** 구조로 매핑되는 join 구조를 보기위해 **animal_type** 을 기준으로 **inner join** 해본다. (굉장히 많은 매핑으로 원하던 결과 1 이 아닌 N으로 출력된다.)  
  임의로 만든 test 테이블은 Cat, Dog 으로 2개의 튜플을 가졌었다. 그러나 join 의 결과는 2개의 튜플이 아닌 N개의 튜플이 되었다.
- ![image](https://github.com/BH946/bh946.github.io/assets/80165014/4af16a5f-acff-46f5-886c-b925d05a49ad)  

- null 신경 안 써도 되면 (outer) left join 으로 왼쪽 테이블(주테이블)을 기준으로 출력해서 좀 더 깔끔한 출력을 볼 수도 있다.
- ![image](https://github.com/BH946/bh946.github.io/assets/80165014/46a07e8d-898f-4157-8182-71d13b42604a) 

<br>

**계층형 질의** : self join 인데, CTE의 재귀 성질을 활용하기도 한다.

- CTE(Common Table Expression) 형태

  - ```mysql
    WITH [RECURSIVE] TABLE명 AS (
        SELECT - # 비반복문. 무조건 필수
        [UNION ALL] # RECURSIVE 사용 시 필수. 다음에 이어붙어야 할 때 사용
        SELECT - 
        [WHERE -] # RECURSIVE 사용 시 필수. 정지 조건 필요할 때 사용
    )
    -- ex : 0~23 추가
    with recursive testCTE as (
        select 0 as hour 
        union all
        select hour+1 from testCTE 
        where hour < 23
    )
    
    -- right join 으로 해당 0~23 값을 활용할 수도 있다.
    select b.hour, count(a.animal_id) as count 
    from animal_outs a right join testCTE b on (hour(a.datetime)=b.hour) 
    group by hour order by hour;
    ```

  - `with` : CTE(common table expression)을 생성하는 문법

  - `union` 은 중복제거 제공, `union all` 은 중복제거X
