---
title: "외부 API 호출한 것 React.js로 디자인까지"
categories : React_JS
tag : [Javascript, 리액트, AJAX, fetch API, concat, filter, map]
toc: true
toc_sticky: true
author_profile: false
sidebar:
  nav: "docs"
typora-root-url: ../../..

---



## 초기 폴더 구성

**git bash**로 **npx create-react-app** 폴더명 으로 설치

```bash
npx create-react-app react_project
```

폴더 구성에서 **src 폴더 하위에 새로운 코드들 작성**할것. 

* import시 **src 폴더를 기본으로 경로** 잡기 때문

public 폴더에는 이미지 등 정적 파일들 작성할 것.

<br>

## `Material UI` 라이브러리 `@mui/material` 설치

- 간단하게 `Material UI`를 사용할 수 있게 해주는 라이브러리로, `@emotion`를 정식 지원함.
- `@mui/material`과 `@emotion`을 설치.

```shell
npm install @mui/material @emotion/react @emotion/styled
```

또는

```shell
yarn add @mui/material @emotion/react @emotion/styled
```

<br>

## 외부 `API` 요청을 위해 네이버 개발자 센터 등록 및 키 발급

- [네이버 개발자 센터](https://developers.naver.com/main/)
- [네이버 영화 검색 API 문서](https://developers.naver.com/docs/search/movie/)

<br>

## `API` 키를 저장하는 방법

- `/.env`

  - 프로젝트의 환경 변수 등 민감한 정보를 저장하는 파일
  - `REACT_APP_`으로 시작하는 변수를 사용할 수 있음
  - [/.gitignore](../.gitignore)과 같이 저장소에 업로드 되지 않는 방법을 사용하여 관리
  - `React`에서는 `process.env.REACT_APP_이름`으로 접근할 수 있음 (보통 이름 대문자)
  - 해당 파일에 다음 내용 작성

  ```
  REACT_APP_NAVER_CLIENT_ID="<Client ID>"
  REACT_APP_NAVER_CLIENT_SECRET="<Client Secret>"
  ```

  - `<Client ID>`와 `<Client Secret>`에 네이버 개발자 센터에서 발급받은 키 입력

<br>

## `CORS` 문제를 임시로 해결하기 위한 방안

**서버가 아닌 클라이언트에서 데이터 요청시 자동으로 차단당하는 경우가 CORS 문제이다.**

- `http-proxy-middleware` 모듈을 사용하여 해결할 수 있음

```shell
npm install http-proxy-middleware --save-dev
```

또는

```shell
yarn add -D http-proxy-middleware
```

- 모듈 설치 후 [`/src/setupProxy.js`](./src/setupProxy.js) 파일 생성 후 코드 작성
- 개발 서버 재실행

### setupProxy.js

* **이번 API호출에서도 CORS문제가 발생하기 때문에 이부분 추가해서 임시로 사용하자**

```javascript
// "/api"로 접근시 https://openapi.naver.com/api.. 로 호출하게 된다.
// 따라서 url을 fetch로 접근할 때 /api/v1/... 이런식으로 입력하면 된다는 것이다.
const { createProxyMiddleware } = require("http-proxy-middleware");

module.exports = function (app) {
  app.use(
    "/api",
    createProxyMiddleware({
      target: "https://openapi.naver.com",
      changeOrigin: true,
      pathRewrite: { "^/api/": "/" },
    })
  );
};
```

<br>

## 배열을 상태로 관리할 때 응용하기 좋은 내장 함수

- 추가: `Array.prototype.concat`
  * 배열을 합침
- 변경: `Array.prototype.map`
  * 산술된 인자를 받아 배열을 만듬
- 삭제: `Array.prototype.filter`
  * 불리언이 true인 값만 가지고 배열을 만듬
- 그 외 추가 계산을 위한 함수
  - `Array.prototype.reduce`, `Array.prototype.every`, `Array.prototype.some` 등

<br>

## 컴포넌트 스타일링

### 디자인 초안확인

![image-20220704164612149](/images/2022-07-03-외부 API 호출한 것 React.js로 디자인까지/image-20220704164612149.png)



#### RequestTest.jsx(API 호출 테스트용)

단순히 API 호출 테스트를 위해서 지원하는 여러가지 **Tool(도구)**를 이용해도 되지만 여기선 **간단히 코드 작성**해서 요청에 응답을 받아 보겠다.

* **테스트 방법** : 단순히 App.js에서 RequestTest태그를 추가해서 test하면 된다.
  * 테스트 중 **index.js**에 **<React.StrictMode>**를 사용해서 useEffect를 써도 console 두 번 찍히는 문제 발견했으며, 해당 태그 지우면 해결된다.

```jsx
// RequestTest.jsx
import { useCallback, useEffect, useState } from "react";

const URL = "/api/v1/search/movie.json?query=어벤져스";
// https://openapi.naver.com/v1/search/movie.json?query=어벤져스
// => API 요청할 주소이다.
// 참고로 cors 문제 임시로 해결. 따라서 /api/로 접근.

// API 요청 테스트하는 컴포넌트
const RequestTest = () => {
  // fetch API 요청 test(async/await으로 비동기 요청을 동기처럼 사용)
  const callApiFetch = async () => {
    const response = await fetch(URL, {
      headers: {
        "Content-Type": "application/json",
        "X-Naver-Client-Id": process.env.REACT_APP_NAVER_CLIENT_ID,
        "X-Naver-Client-Secret": process.env.REACT_APP_NAVER_CLIENT_SECRET,
      },

    })
    console.log(response)
    const data = await response.json();
    console.log(data.items)
  }
  useEffect(() => {
    // mount 시 API 요청
    callApiFetch();
    console.log("rendering~")
  }, []);

  return (<></>);
}

export default RequestTest;
```

![image-20220706235423572](/images/2022-07-03-외부 API 호출한 것 React.js로 디자인까지/image-20220706235423572.png)



### 컴포넌트 뼈대 구성

**배치를 위해 요소를 우선 설계**

#### /apis/fetch.js

* API 호출이 잘되는건 알았기 때문에 **fetch.js로 api호출은 따로 분류해서 관리**하자

```js
import qs from "qs";

const URL = "/api/v1/search/movie.json";
// https://openapi.naver.com/v1/search/movie.json
// API를 요청할 주소
// 참고로 cors 문제는 임시로 해결

// offset : 데이터 시작 위치, limit : 데이터 개수 제한
export const requestGetMovieList = async (offset =1, limit = 5) => {
  const query = qs.stringify({
    query: "어벤져스",
    start: offset,
    display: limit,
  })
  const URI = `${URL}?${query}`;

  const response = await fetch(URI, {
    headers: {
      "Content-Type": "application/json",
      "X-Naver-Client-Id": process.env.REACT_APP_NAVER_CLIENT_ID,
      "X-Naver-Client-Secret": process.env.REACT_APP_NAVER_CLIENT_SECRET,
    },
  });

  return await response.json();
};
```



#### components/Movie.jsx

* **컴포넌트 단위**로 구분하기 위해 따로 분류해서 관리하자

```jsx
import {memo} from "react";

// 최적화
// 지정한 props의 변화 외의 불필요한 컴포넌트 재렌더 방지하는 memo() 사용

const Movie = ({ title, subtitle, image, link, director}) => {
    return (
        <div>
            <div>
                <img src={image} alt="movie-thumbnail"></img>
            </div>
            <div>
                <a href={link}>
                    <h3>{title}</h3>
                    <h4>{subtitle}</h4>
                    <p>감독 : {director}</p>
                </a>
            </div>
        </div>
    );
}

const MovieList = ({movieList}) => {
    return (
        <div>
            {movieList.map((movieItem) => {
                return(
                    <Movie 
                    key={movieItem.title} // key도 보내줘야 안전
                    {...movieItem}>
                    </Movie>
                )
            })}
        </div>
    )
}

export const Movies = memo(MovieList);
// memo 함수를 통해 불필요한 컴포넌트 재렌더 방지
// movieList 이외의 다른 값이 변경되어도 렌더링에 영향을 주지 않음

export default Movie; // 기본값
```



#### containers/MovieContainer.jsx

* **컴포넌트의 모음으로 컨테이너**로 구분해서 분류해서 관리하자
* 뒤에 추가버튼, 체크박스 버튼 등등 기능 추가하게 되면 당연히 이 코드에서 더 수정이 될 예정이다

```jsx
import { useState, useCallback, useEffect } from "react";

import { requestGetMovieList } from "../apis/fetch";
import { Movies } from "../components/Movie";

// 최적화
// movieList가 변할때만 함수 새로 생성하기 위해 useCallback() 사용
// 재렌더마다 API 요청이 아닌 mount 시에만 API 요청하기 위해 useEffect() 사용

const MovieContainer = () => {
    const [movieList, setMovieList] = useState([]);
    
    const callApiGetMovieList = useCallback(async () => {
        const data = await requestGetMovieList()
        // data.items => [{},{},...] 로 구성
        setMovieList(data.items)
        console.log(data.items)
    }, [movieList])

    useEffect(() => {
        // mount 시에만 API 요청
        callApiGetMovieList();
    }, [])

    return (
        <div>
            <Movies movieList={movieList}></Movies>
        </div>
    );
}

export default MovieContainer;
```

![image-20220707013003821](/images/2022-07-03-외부 API 호출한 것 React.js로 디자인까지/image-20220707013003821.png)



### 컴포넌트 스타일 요소 구성

**HTML 뼈대를 보고 태그에 이름을 붙이는 단계**







