---
title:  "[개념] Dynamic_Programming(동적계획법)"
categories : Algorithm
tag : [알고리즘, DP조건, 피보나치의 수, 이항계수, 격자경로, Coin Changing Using DP, 연쇄 행렬곱셈(Matrix-chain Multiplication), 최단거리(Floyd), LCS(Find a Longest Common Subsequence), OBST(Optimal Binary Search Tree), 0-1 Knapsack]
toc: true
toc_sticky: true
author_profile: false
sidebar:
  nav: "docs"
typora-root-url: ../../..
---



## Intro..

**기존 분할정복식(하향식:TopBottom)은 중복계산이 단점**

* 발전 시킨 방식이 **TopBottom:Memoization** 방식이며 중복계산을 없앰 => DP로 분류
* 다만, 하향식 방식들은 재귀 리턴 오버헤드가 아쉽다.

<br>

**반면, 동적계획법(상향식:BottomTop)은 중복계산이 없음**

* 분할해서 나누어진 부분들 문제들을 먼저 풀면서 점점 상향으로 올라가는 방식
* 추가 메모리 사용(배열에 기록 등등), 보통 for문이 제일 흔한 방법
* 다만, 필요없는 값도 계산한다는 점이 아쉽다.

<br>

그럼 언제 분할정복식을 쓰고, 언제 동적계획법을 쓰는게 좋은지 궁금증이 생긴다.

보통 `분할정복식`은 **상관관계 없을 때** 좋다고 하고, `동적계획법`은 **상관관계 있을 때** 좋다고 한다.

<br>

## 동적계획법(DP) 이용한 알고리즘들

### **피보나치의 수**

* top-bottom(MEMOIZATION) 방식 : `f[n] = fib(n-1) + fib(n-2);` 코드가 핵심이다.
* 기존 알고리즘에서 f[n] 배열을 따로 추가해서 배열에 기록을 해서 재사용을 해나가는게 핵심인 것!
* 기존 알고리즘은 다른 게시물에 있으니 참고!

<br>

### **이항계수**

* 기존엔 팩토리얼로 공식을 이용해서 풀었을 텐데, 여기선 아래 식을 활용하자.

  *   ![img](/images/2022-12-30-(개념) Dynamic_Programming(동적계획법)/DRW000019e872e8-16723248987111.gif)  

* 코드를 보는게 이해하기 훨씬 편할테니 바로 코드를 보자.

* **BottomTop 방식 코드**

  <img src="/images/2022-12-30-(개념) Dynamic_Programming(동적계획법)/image-20221229234303945.png" alt="image-20221229234303945" style="zoom:80%;" />

  * 배열에 채워지는 모습은 아래 그림을 통해 이해하자.


​						  <img src="/images/2022-12-30-(개념) Dynamic_Programming(동적계획법)/image-20221229235007320.png" alt="image-20221229235007320" style="zoom:80%;" />

<br>

  * **TopBottom 방식 코드**

<img src="/images/2022-12-30-(개념) Dynamic_Programming(동적계획법)/image-20221229234538342.png" alt="image-20221229234538342" style="zoom:80%;" />

<br>

### **격자경로**

* **너무나도 유명한 격자경로를 정리해보겠다(기본형태)**

  <img src="/images/2022-12-30-(개념) Dynamic_Programming(동적계획법)/image-20221230172551780.png" alt="image-20221230172551780" style="zoom:80%;" />

  * 참고로 식에 P(j,1)은 오타이고 P(i,1)로 봐야한다.

  * 보통 격자경로는 이런 그림의 형태를 가지며, S->T로 가는 최단경로의 개수를 구하는게 목표이다.

  * 또한, S에서 출발해서 오른쪽과 아래로만 이동을 할 수 있다.

  * 여기서 특징이 nCk로 조합을 이용해서 한번에 구할수도 있다.
    * 최대로 오른쪽과 아래로 가서 총 움직이는 수는? 12이다. 이를 n으로 보자.
    * **12번 움직이고 4번 아래로가는 서로다른 최단 경로개수? `12C4`**
    * 12번 움직이고 8번 오른쪽가는 ..? `12C8`
    * `12C4=12C8` 이란것은 수학적으로 자명하기 때문에, `12C4`로 바로 값을 구할 수 있다.
    
  * 앞서 정리한 이항계수 알고리즘처럼 여기서도 유사하게 DP로 풀면 된다.
    * `P(i,j)=P(i-1,j) + P(i,j-1)`  가 핵심 알고리즘이다.
    
    * 그림을 보고 이해하자면, `(i,j)`자리에 그 왼쪽인 `(i,j-1)`자리와 그 위인 `(i-1,j)` 자리를 더해서 2, 3, 4, 5... 이런식으로 구해가고 있다는걸 이해하면 충분히 이 문제는 이해할 수 있다.
    
  

<br>

* **이번엔 기본형태의 조금 응용버전인 표시된 곳은 못지나가는 경우에 구하는 것을 보겠다.**

  <img src="/images/2022-12-30-(개념) Dynamic_Programming(동적계획법)/image-20221230174030582.png" alt="image-20221230174030582" style="zoom:80%;" />

  * 마크가 되어있는곳의 경우 **0**으로 두고, 아닌경우 기존방식 그대로 사용 시 해결할 수 있다.

  * 이유를 생각해보면, 표시된 곳은 지나갈 수 없기 때문에 경로가 아예 없는것이다.

  * 따라서 기존방식에선 `(i-1,j), (i,j-1)` 위치의 값을 더해서 구하기 때문에, 이때 표시된 곳이  
    만약 `(i-1,j)` 였을 경우 **0**으로 설정해뒀으면 더해도 `(i-1,j)` 위치의 값은 안더한거나 마찬가지이게 되는 것이다.


<br>

* **여기서 또 응용된 버전으로 표시된곳을 오히려 b(1<=b)번 이상 지나가야 하는 경우를 보겠다.**

  <img src="/images/2022-12-30-(개념) Dynamic_Programming(동적계획법)/image-20221230174758217.png" alt="image-20221230174758217" style="zoom:80%;" />

  * **이 예제는 b=2인 경우로 3차원 배열에 b=0, b=1, b=2인 경우들 최단경로 개수를 기록해 나간다.**
    * `(표시없는길 개수)/(표시1번 지난길 개수)/(표시2번 지난길 개수)` 로 볼 수 있다.
  * 구해나가는 방법은 우선 표시(mark)가 없다고 가정해서 표시있는 구역에서 기존과 동일하게 구한다.
  * 다음으로 표시가 있는지 확인 후 있다면 선언했던 3차원 배열에서 각 차원들 값을 다음 차원들로 각각 옮겨준다. 
    * 물론, b=2라서 3차원이니까 3차원 이상으로 넘어가는건 무시하고 계속 3차원에서 같이 합해준다.
  * 그림을 보면, T까지 다구한것은 아닌데 그 위의 점까지 구한 결과는 **44**라는것을 확인 할 수 있다.

<br>

### **Coin Changing Using DP – 물건을 구매하고, 거스름돈 교환**

* 이 문제는 물건을 살때 지페를 내고 거스름돈으로 동전을 돌려받는 문제인데,   
  **돌려주는 잔돈(동전)의 개수를 최소화 하는 알고리즘을 의미한다.**

  * 이 알고리즘에서 생각해야할 점이 있다.

  * 만약 동전이 `1원, 7원, 10원`이 존재하며 이때 `14원`을 거스름돈으로 돌려줘야 하는경우를 생각해보자.

    * 정말 간단히 그리디(탐욕적)방법으로 생각하면 `10x1 + 1x4 = 14` 로 총 `5개` 동전을 거슬러준다.
    * 그런데, 이는 최적의 답이 아니다. 실제로는 `7x2 = 14` 로 총 `2개`의 동전만 거슬러주면 된다.
    * 따라서 이런 경우가 있다는것을 잘 이해하고 넘어가야한다.

    <img src="/images/2022-12-30-(개념) Dynamic_Programming(동적계획법)/image-20221230180254294.png" alt="image-20221230180254294" style="zoom:80%;" /> 

  * 이 알고리즘을 DP로 푸는 방식을 나타낸 그림이다.

  * 아래 공식을 이해하기전 위 코드들이 사용된 구조를 이해하자.

    * `denom`은 액면가(주어진 동전 종류인 1원, 10원, 100원 등등 의미)를 나타낸 배열이다.
    * 위 그림은 `C배열`을 나타낸것이며 DP 방식을 사용해서 채워나간 배열이다.
    * C배열의 `i`는 3개인데, denom[1~3]으로 3개의 액면가가 있다고 이해할 수 있다.
    * `j`는 총 잔돈으로 거슬러 줄 가격을 의미한다.
    * 마지막으로 `내부의 요소`들은 거슬러 준 동전의 개수를 의미하는 것이다.

  * 아래 공식의 의미를 이제 이해해보자.

  * 먼저, `0, if(j=0)` 이것의 의미는?

    * j가 0이면 거슬러줄 돈이 0원이란건데, 그럼 당연히 거슬러줄 때 필요한 동전개수는 0이다.

  * `c[i-1][j], if(denom[i]>j)` 이것의 의미는?

    * 액면가(denom[i])가 j(거슬러줄 총값)보다 크다는것은 해당 액면가(denom[i])는 현재 거슬러줄 수 없다는 것이기 때문에, 이전의 값인 `c[i-1][j]` 값을 그대로 사용한다는 의미이다.

  * `min(c[i-1][j], 1+c[i][j-denom[i]]), if(denom[i]<=j)` 의 의미는?

    * 액면가가 거슬러줄 총값보다 작거나 같다는 것은 해당 액면가를 사용할 수 있다는 것이다.
    * 따라서 이전의 값과 현재 액면가를 사용한 값을 비교해서 최소값(min)을 사용한다.
    * 참고로 `1+..` 는 현재 액면가를 쓰는걸 가정해서 동전 1개를 추가한것이고,
    * `j-denom[i]` 는 현재 액면가를 더하면 정확히 j(거슬러줄 총값)값과 같게 만들어줄 위치로 이동시켜준다.
      * 이부분 이해가 안가면 그림보고 손으로 해보면 바로 이해가 될것이다.
      * 참고로 i=1인 c배열 부분들은 현재 이 조건으로 생성이 된다는걸 이해하면 완벽하다.

  * 따라서 여기서 최종 해답인 동전개수는 `c[3][12]` 의 위치인 **2개** 가 최종 답이 된다.


<br>

* **물론, 이렇게 구했을때 무슨 동전들을 선택한건지도 역추적으로 간단히 구할 수 있다.**

  <img src="/images/2022-12-30-(개념) Dynamic_Programming(동적계획법)/image-20221230182438724.png" alt="image-20221230182438724" style="zoom:80%;" />

  * 또다른 예제인 이 그림을 보면 역추적을 통해서 `1원 3개, 7원 1개, 15원 1개` 라고 구한 모습이다.
  * 정말 간단한 원리이다.
    * 맨 마지막 위치인 `c[3][25]`에서 위에값이 내려온건지 왼쪽의 값이 온건지 판단하면 된다.
    * 만약, 위의 값과 현재위치 값이 다르다?? 왼쪽의 값을 추적하면 된다.
      * 이때 왼쪽값 추적은 현재 위치가 (i,j)라 하면 j(거스름돈 총값)에서   
        현재 액면가(denom[i])를 빼주면 된다. => 즉,  `j-denom[i]` 로 인덱스 추적하면 된다.
      * 결론은 왼쪽값 추적할땐 해당 위치의 액면가(denom[i])인 동전 1개를 사용했다는 의미이다.
    * 그리고 위의 값과 현재위치 값이 같다?? 바로 위의 값으로 추적(이동)하면 된다.

<br>

### **연쇄 행렬곱셈(Matrix-chain Multiplication)**

어떤 행렬곱셈을 먼저 수행하느냐에 따라 `곱셈 횟수`가 달라짐  

4개의 행렬곱셈만 해도 5가지 곱셈 방법이 존재 및 각각 값이 다름

* `A1(100x2) * A2(2x50) * A3(50x3) * A4(3x10)` 이 4개의 행렬을 곱하는 곱셈 횟수를 구해보겠다.

  * **연쇄행렬에선**   ![img](/images/2022-12-30-(개념) Dynamic_Programming(동적계획법)/DRW00000bc84ef0.gif)   **차원을**   ![img](/images/2022-12-30-(개념) Dynamic_Programming(동적계획법)/DRW00000bc84ef2.gif)   로 나타낼 수 있음
    * 따라서 위 행렬에서 A1의 차원은 `100*2` 라는 의미

  * 4개의 행렬곱셈은 총 5가지 곱셈 방법이 존재하며 이중에서 2개만 보이겠다.
  * `(((A1*A2)*A3)*A4) 의 곱셈 횟수` : `100*2*50 + 100*50*3 + 100*3*10 = 28000`
  * `(A1*((A2*A3)*A4)) 의 곱셈 횟수` : `100*2*10 + ((2*50*3) + 2*3*10) = 2360`
  * 이처럼 2가지만 봐도 곱셈횟수가 많이 차이난다는 것을 알 수 있다.
  * 그렇다면, 이를 DP방식으로 최적의 행렬곱셈 횟수를 구하는 방법은 무엇일까?

* **DP방법 => 대각선으로 구해나가면서 배열이 채워지게 됨**

  ![image-20230101190759141](/images/2022-12-30-(개념) Dynamic_Programming(동적계획법)/image-20230101190759141.png)

  * 이 그림은 `M[4][6]` 을 구하는 모습을 나타낸 그림이다.

  * `M[i][j]`는 `Ai~Aj`까지 행렬 곱하는 **곱셈의 최소 횟수**를 의미

  * 구하는 공식을 먼저 이해하자
    * **if i=j, M\[i][j] = 0**
    * **if i<j, M\[i][j] = ![img](/images/2022-12-30-(개념) Dynamic_Programming(동적계획법)/DRW00000bc84ef8.gif)**  


  * **if i=j, M\[i][j] = 0** 은 예로 ![img](/images/2022-12-30-(개념) Dynamic_Programming(동적계획법)/DRW00000bc84ef6.gif) 이 차원이 `2x3, 2x3` 이면 행렬 곱이 불가해서 `0`이다.
    * **if i<j, M\[i][j] = ![img](/images/2022-12-30-(개념) Dynamic_Programming(동적계획법)/DRW00000bc84ef8.gif)** 의 의미는??
      * `A1*A2*A3` 를 구한다고 가정한다면? `A1 (A2 A3) , (A1 A2) A3` 처럼 2가지 곱셈 방법이 있다.
      * 각각 64와 90의 곱셈수가 나오며 여기서 더 min 값은 64이므로 64가 `M[1][3]`자리에 채워진다.
      * **이 과정을 위의 해당 공식을 사용하면 구할 수 있다.**

  * 이것을 이해했다면 **최종 A1 ~ A6까지** 연쇄 행렬곱의 최소 횟수는 `M[1][6]`이라는 것을 이해할 수 있다.

    * 따라서 이를 구하기위해 대각선으로 구해나가면서 `M[1][6]` 까지 배열을 채워나가는 것이다.

  * **아래는 참고 코드**

    <img src="/images/2022-12-30-(개념) Dynamic_Programming(동적계획법)/image-20230101192821477.png" alt="image-20230101192821477" style="zoom:80%;" /> 

<br>


* **또한, k를 P\[i][j]에 기억해서 최적 순서를 구할 수 있음 => 즉, 괄호를 씌울수 있음**

  ![image-20230101191946366](/images/2022-12-30-(개념) Dynamic_Programming(동적계획법)/image-20230101191946366.png) 

  * 최적 곱셈수로 곱하는 순서를 괄호를 씌워서 나타내는 방법을 알려주는 그림이다.

  * `M[i][j]`를 최종 구할때 사용한 `k`값을 `P[i][j]`에 기억해서 순서를 알 수 있다.

    * 해당 P배열 안의 숫자는 어디서 잘랐는지 위치를 알려줌.   
    * **즉, A1~A6에서 `P[1][6]=1`은 A1에서 잘랐다는것이고,     **
      **A2~A6인 `P[2][6]=5`는 A5에서 잘랐다는것을 의미한다.**

  * 최적 분해를 구하는 예시를 직접 해본다면?

    * 먼저 `P[1][6]` 부터 시작하면 => (A1 (A2 A3 A4 A5 A6))
    * 이후는 당연히 `P[2][6]` 차례 => (A1 ((A2 A3 A4 A5) A6))
    * 다음은 `P[2][5]` 차례 => (A1 (((A2 A3 A4) A5) A6))
    * 다음은 `P[2][4]` 차례 => (A1 ((((A2 A3) A4) A5) A6))

  * **아래는 참고 코드**

    <img src="/images/2022-12-30-(개념) Dynamic_Programming(동적계획법)/image-20230101192907787.png" alt="image-20230101192907787" style="zoom:80%;" /> 

<br>

### **최단거리(Floyd)**

식도 중요하겠지만 아래 3개인 `Floyd, LCS, OBST` 는 그림 위주로 보면 동작을 이해하기가 편했다.

그림으로 보자.

![image-20230101194524369](/images/2022-12-30-(개념) Dynamic_Programming(동적계획법)/image-20230101194524369.png)

* 이처럼 **W행렬**은 오른쪽의 가중치 방향 그래프를 **인접행렬**로 나타낸 모습이다.

  * 이음선(연결선)이 없으면 경로가 없는것이라 무한대로 표시하였다.

  * 이음선이 있으면 경로가 있는것이기 때문에 그때의 가중치를 표시하였다.
  * `i=j 처럼 v1->v1`이면 자기자신으로 가는경우라서 필요가 없기때문에 가중치를 0으로 표시하였다.

* **D행렬**이 각 정점들 사이의 **최단거리**들을 표시해둔 행렬이 될것이고,

  * 맨 초기인 D^(0)는 W행렬(인접행렬)과 동일하다.
  * 최종 결과인 D^(n)는 최종 구할 D행렬이 된다.
  * 이부분이 이해가 가지 않는다면, 아래를 먼저 계속 볼 것.

![image-20230101195526860](/images/2022-12-30-(개념) Dynamic_Programming(동적계획법)/image-20230101195526860.png)

* 이부분도 대충보고 아래 그림을 통해 이해를 하자.
  * 위 그림은 코드 작성할때 사용하게될 식을 보여주려고 나타냈을 뿐

![image-20230101195640475](/images/2022-12-30-(개념) Dynamic_Programming(동적계획법)/image-20230101195640475.png)

* 이 그림만 이해한다면?? Floyd 알고리즘을 이해한것과 마찬가지이다.
  * 앞서 얘기했듯이 D^(0)는 맨 초기상태인 W(인접행렬)과 동일하다.
  * **이때 v1정점을 경유하는 경우와 기존 경로의 경우의 거리 중 min값을 적용하는 모습이다.**
  * 예로 빨간 동그라미 14의 경우? 
    * v2->v5가 무한대였는데 v2->v1->v5 경로는 9+5=14로 무한대보다 min값이다.
* 참고로 **P행렬**은 어느 노드(정점)을 경유했는지를 기록하기 위한 행렬이다.
  * 위 예에선 **v1노드를 경유하는 상태라서 1들이 기록**이 된 것이다.

![image-20230101200205941](/images/2022-12-30-(개념) Dynamic_Programming(동적계획법)/image-20230101200205941.png)

* 이번엔 다음 단계인 **v2노드를 경유하는 경우**를 적용해보는 그림이다.

  * **여기서 중요한점은 이렇게 그림으로 구할땐 편하게 구하는 법이있다.**
  * 우선 빨간 네모 부분은 v2노드이므로 경유하는게 아니므로 당연히 값이 변동되지 않는다.
  * 다음으로 동그라미친 3을 잘 보면 가로, 세로방향의 빨간 네모안의 숫자와 줄이 그어져있다.  
    이는 14+무한대와 현재 기록되어있는 3을 비교하는 모습이다.
  * 이런식으로 비교할 자리의 숫자와 가로, 세로 방향의 빨간 네모안의 숫자의 합과 비교하는 것이다.

  * 예를 들어 `D[1][3]` 의 자리의 경우??
    * 기존 기록된게 무한대이고, 빨간 네모의 가로 세로 숫자 합은 1+3=4이다.
    * 이를 비교하면 무한대>4 이므로 min 값은 4로 결정 되는것이다.

![image-20230101200731139](/images/2022-12-30-(개념) Dynamic_Programming(동적계획법)/image-20230101200731139.png)

* v3, v4노드까지 경유했다고 가정하고 **최종 v5를 경유하는 마지막 모습**이다.

  * 이처럼 Floyd 알고리즘은 총 n번(=v노드 개수)을 전체적으로 반복한다.
  * 물론 내부적으로 행렬의 숫자들을 비교하는건 n^2이다.
  * 따라서 n*n^2=n^3으로 복잡도를 알 수 있다.

* **아래는 참고 코드**

  <img src="/images/2022-12-30-(개념) Dynamic_Programming(동적계획법)/image-20230101201100888.png" alt="image-20230101201100888" style="zoom:80%;" /> 

  * 1번째 알고리즘 : **최단경로의 길이**만 구하는 알고리즘

  <br>

  <img src="/images/2022-12-30-(개념) Dynamic_Programming(동적계획법)/image-20230101202006606.png" alt="image-20230101202006606" style="zoom:80%;" /> 

  * 2번째 알고리즘 : **최단경로 길이 + 최단경로**까지 구하는 알고리즘

  <br>

* **아래는 최단경로(앞에서 구한 P활용) 구하는 코드**

![image-20230101202147216](/images/2022-12-30-(개념) Dynamic_Programming(동적계획법)/image-20230101202147216.png)

<br>

### **LCS**(Find a Longest Common Subsequence)

이것에 대한 의미를 먼저 이해해보자.

subsequence란 ABCDE..에서 BCD 이런식으로 가져온것  
common subsequnce는 여러 subsequnce에서 또 공통된 거를 의미   
longest ... 란 이 공통된것 중에서 젤 긴것을 구하는 것.

**즉, A문자열과 B문자열 이렇게 주어졌을때 이것들의 LCS를 구한다는 의미이다.**

![image-20230101202626997](/images/2022-12-30-(개념) Dynamic_Programming(동적계획법)/image-20230101202626997.png)

* `c(n,m)`은 가장 긴 공통 값을 의미  
* `i=0 or j=0`이면? 문자가 없는거니까 당연히 0   
* `a[i]==b[j]`라면? 그 전인 `c[i-1,j-1]`가 남고, `a[i]==[bj]`니까 +1   
  * 이는 당연히 A문자열과 B문자열에서 각각 V, V가 나왔다고 한다면 문자가 같으니까 +1을 하는것.
* `a[i]!=b[j]`라면? c배열의 왼쪽과 위의 값 중에서 제일 긴(max) 값으로  적용
  * 같은 문자가 나오지 않았으니 이전의 값들 중 긴(max) 값으로 사용한다는 것을 의미.
* 예로 표에 줄그은부분 해석하자면?  
  * A:GVCE, B:GDV => 동일 : GV로 2개
* 위 식대로 진행한다면 오른쪽 배열처럼 나타낼 수 있는것.

![image-20230101203602553](/images/2022-12-30-(개념) Dynamic_Programming(동적계획법)/image-20230101203602553.png)

* 마지막으로 이렇게 서로 다른 LCS를 어떻게 카운트하며 경로를 찾느냐가 문제이다.
  * 그래프 경로 구하던 알고리즘처럼 간단히 구할 수 있다.
  * 모서리 부분은 꼭 왼쪽 위에서 와야하지 바로 위나 바로 왼쪽에선 못온다. 
    이성질을 이용하면, 위 그림처럼 경로를 찾을 수 있다.
  * **이렇게 전부 찾게 되면 총 2개의 LCS를 구했다는걸 카운트 할 수 있다.**

<br>

**실제로 사용(응용)하는 문제**

![image-20230101203849819](/images/2022-12-30-(개념) Dynamic_Programming(동적계획법)/image-20230101203849819.png)

* **문제를 해석해보면, 키 증가하면서 IQ 감소를 찾아야 한다.**

<br>

![image-20230101204007861](/images/2022-12-30-(개념) Dynamic_Programming(동적계획법)/image-20230101204007861.png)

* **총 2개의 정답이 나온다.**
* 여기서 키 값이 같은, IQ가 같은 이런 경우들도 있는데 잘 처리해야한다.
  * 동일 키의 경우 IQ가 상승(감소가 아닌)으로 정렬을 해야만 정확한 값을 얻을 수 있음

<br>

### **OBST**(Optimal Binary Search Tree)

**이진검색트리는 `순서가능집합` 에 속한 item으로 구성된 이진 트리이고, 다음 조건을 만족한다.**

* 각 마디는 하나의 키만 가짐
* 주어진 마디의 왼쪽 서브트리는 그 마디의 키보다 작거나 같다.
* 주어진 마디의 오른쪽 서브트리는 그 마디의 키보다 크거나 같다.

<br>

**최적 이진 검색 트리를 구하는것이 목적이다.**

* 이진 검색 트리가 여러가지 모양으로 나올 수 있는데, 이때 각 값들의 검색이 최적인 경우의 트리를 구하는 것이다.
* 따라서 각 키들의 검색 확률(즉, **검색 빈도수** 느낌)을 받아서 이를 이용해 DP로 구한다.

![image-20230101204311386](/images/2022-12-30-(개념) Dynamic_Programming(동적계획법)/image-20230101204311386.png)

* 여기선 공식이 핵심이다.
*   ![img](/images/2022-12-30-(개념) Dynamic_Programming(동적계획법)/DRW00000bc84efc.gif)  

<br>

![image-20230101205111311](/images/2022-12-30-(개념) Dynamic_Programming(동적계획법)/image-20230101205111311.png)

* R은 루트를 표시한것, `A[i][i]`때 값 넣은 상태

<br>

![image-20230101205250313](/images/2022-12-30-(개념) Dynamic_Programming(동적계획법)/image-20230101205250313.png)

* 예로 `A[1][2]`는 K1이나 K2 둘다 확률 같아서 루트를 뭐로 두든 상관없고,  

* K1 루트시 K2인 `A[2][2]`값과 한단계 아래니까 +3/8을하고 K1인 3/8더하면 됨.

* 2개때는 K1,K2나 K2,K1 구조인 2경우만 생각. 그리고 더 간단히 생각가능.   
* 예로 2개땐 무조건 확률이 큰값이 루트인게 젤 최적 검색이 될테니까.   
* 다만, 3개때부턴 3가지경우 다 비교를 해줘서 제일 최소값을 구해줘야죠.

<br>

![image-20230101205450832](/images/2022-12-30-(개념) Dynamic_Programming(동적계획법)/image-20230101205450832.png)

* 3개일땐 루트가 K1~K3일때로 나눠서 하면됨.(3개때임)

<br>

![image-20230101205505752](/images/2022-12-30-(개념) Dynamic_Programming(동적계획법)/image-20230101205505752.png)

* **최종 모습**

<br>

### 0-1 Knapsack(DP)

**0-1 Knapsack란 배낭을 빈틈없이 채우는데 품목(item)은 쪼갤 수 없는 알고리즘이다.   
여러 품목(item)들 중에서 정해진 무게(W)만큼 채워서 최대한 많은 이득을 취할 수 있는 문제를 다룬다.**

무게 큰거부터 차례로 넣어가고, 남은건 쪼개서 담으면 되기때문에 탐욕(그리디)방법으로 풀 수 있다.   
**하지만 물건을 쪼갤수 없는 상태면?? `0-1 Knapsack`의 문제가 되는것이다.**    
`Fractional Knapsack`과 `0-1 Knapsack`을 구별할 것

* **Greedy는 `Fractional Knapsack` 가능, `0-1 Knapsack` 불가**
* **따라서 `0-1 Knapsack`은 DP로 구현**

<br>

![image-20230103020741484](/images/2022-12-30-(개념) Dynamic_Programming(동적계획법)/image-20230103020741484-16726800286511.png)

* `P[n][W]` = 최종 우리가 구할 값(n:전체 품목, W:주어진 전체 무게)
* ![img](/images/2022-12-30-(개념) Dynamic_Programming(동적계획법)/DRW00000d985f75-16726800286512.gif)   : i번째 물건의 무게가 가방 여유 w무게 보다 큰 경우(즉, 물건 못 넣음)
* ![img](/images/2022-12-30-(개념) Dynamic_Programming(동적계획법)/DRW00000d985f77-16726800286513.gif)   : i번째 물건의 무게가 가방 여유 w무게 보다 같거나 작은 경우(즉, 물건 넣을 수도 있음)

* **위 공식으로 P배열을 채워나간다.**
  * 중요한점은 너무 쓸데없는 값들도 배열에 연산해서 저장을한다는 점이다.
  * 따라서 아래 그림을 보면 훨씬 연산량을 단축 시키는 방법이 있다.

<br>

![image-20230103021630131](/images/2022-12-30-(개념) Dynamic_Programming(동적계획법)/image-20230103021630131-16726800286514.png)

* 모든 배열 값을 구할필요가 없으니까 필요한것만 구하자는 의미

<br>

### 프리랜서의 일정 정하기





<br>

### 완전정보 게임



<br>

### 제한된 비트 스트링의 개수



<br>

### 최대 공백 정사각형(Largest Empty Square)





<br><br>

## DP가 불가능한 경우는?

DP가 불가능한 경우는 무엇일지가 궁금했는데 DP에는 **최적의 원칙(the principle of optimality)** 이란게 있다.  
**최적의 원칙이 적용이 되어야 DP가 가능하다는 것이다.**

<br>

**예를들어 경로의 문제를 생각해보면**

* vi->vj로 문제?, vk를 경유한다면 vi->vk로 가는 최단경로를 사용해서 vi->vk->vj   
  vi->vk로 가는 문제였다면? vi->vk에 경유지는 없고 바로 최단경로로 끝.   
* 근데, v->vk와 vi->vk->vj에서의 vi->vk가 서로 경로가 다르면 안된다는것.   
  그렇게되면 최적의 원칙이 적용된다고 할 수 없다는 것.
* 최적의 원칙이 적용이 안되는 예들 중에 하나는 **최장경로**의 문제가 있다.

