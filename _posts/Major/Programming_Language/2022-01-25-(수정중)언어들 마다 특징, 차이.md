---
title:  "[수정중]언어들 마다 특징, 차이"
categories : [Programming_Language, Revise, Knowledge]
tag : [language, java, c, c++, python]
toc: true
toc_sticky: true
author_profile: false
sidebar:
  nav: "docs"
---



# C, C++, Python, Java 등 언어차이 정리

* 계속 수정... (내용 부실)

<br><br>

## 1. 문자열 비교?

* **`if(singer == elvis)` 가능 : C++, Python**
* **불가능 -> equals() 같은 비교함수 사용 : C, Java**
  * C는 char[] 형태 문자열이므로 "주소" 사용
  * **자바 또한 "주소"** 사용
    * 단, 자바에서 햇갈릴 수 있는 문자열 리터럴 조심!!
    * `String a = "HI" 와 String b = "HI"` 는 동일한 "HI" 리터럴 주소를 가진다.
    * 자세한 것은 아래 그림 참고

![image](https://github.com/BH946/bh946.github.io/assets/80165014/24a656ce-4d72-42d4-895a-8519c8f3cba7) 

<br><br>

## 2. 지역, 전역, 정적, 멤버 변수들?

**클래스(class)에서 선언한 변수를 멤버변수라 하자.**

**자바는 모든게 클래스이다.** 따라서 멤버변수(전역), 지역변수 이렇게 구분하자.  
**C**는 전역 객체 생성시 자동으로 **static**이 붙는것이다.

* C언어 전역 = 0, 지역 = 쓰레기값 -> int로 예시
* C++ 전역 = 0, 지역 = 쓰레기값
* 자바 전역(멤버) = 0, **지역 = 에러 !!** => 지역변수 초기화 안된건 그냥 가능성 자체를 차단시켜 버리는것.
* C++ 멤버변수 자동초기화 안해서 쓰레기값 => 자바와 혼동X
* **=> 참고만 하기. 자세히 파고들면 더욱 복잡.**

<br>

**Switch문을 활용한 비교**

* switch문에 자바는 문자열도 가능 (C/C++안됨)
* 특히, 자바는 지역변수 초기화 안하면 오류니까 default: salary=1;이라고 스위치문에 함께 사용시 오류 예방

<br><br>

## 3. 자바 다중 상속X, C++ 다중 상속O(양쪽으로 상속)

**하지만 자바에서 클래스말고 인터페이스는 다중상속 가능!!**

<br><br>

## 4. 메모리할당?

**C의** 경우 maloc을 이용. (메모리 관리가 매우 복잡)  
**C++의** 경우 maloc, new객체 생성 둘다 이용. new하면 꼭 delete!! (이 또한 메모리관리 쉽지않음)  
반면 **파이썬은** List가 "동적할당"을 제공. (메모리 관리는 매우 쉬움) 다만 속도면에선 느리다.  
**코틀린은** List가 있지만 정적이며, mutuablelist가 동적할당을 제공해준다.

**C, JAVA 좀 더 자세히**

* 자바는 C처럼 메모리에 직접 접근 불가. 메모리 관리도 GC(가비지 컬렉션)이 도움

* C 메모리구조 : Code(기계어) / Data / Heap / Stack
  * Code : 소스코드(바이너리 형태) 저장
  * Data : 전역, 정적변수
  * Heap : 동적 할당
  * Stack : 지역, 매개변수
* 자바 메모리구조 : Method / Stack / Heap
  * Method : 소스코드, static, 런타임 상수 풀(여러 종류의 상수들)
    * 프로그램 시작전 로드 -> 프로그램 종료시 소멸
  * Stack : 지역, 매개변수
  * Heap : 동적 할당(객체1, 객체2...)

<br><br>

## 5. 자바, C언어 배열 (+메모리 할당)

### 자바

**배열 선언은 정적이고, 배열 크기가 동적이며 힙에 할당한다.**

따라서 선언은 컴파일러, 크기는 인터프리터의 역할이다.

* 인터프리터는 실행때 동작하니까 크기를 알 수 있는것!
* 정해진 크기도 동적으로 더 키우고 줄이는 ArrayList를 제공
* **new로 생성**하니까 **힙**에 동적으로 할당
* **int[] data;** 같이 선언한 변수 data는 **스택**에 주소 저장

<br>

**예시**

```java
int size = 50;
int arr[] = new int[size]; // 가능(실행때 크기지정하니까 size로 선언 가능)
arr = new int[50]; // 가능(새로운 배열임)
arr[60] = 3; // 이건 에러. 하지만 ArrayList는?
ArrayList<Integer> arr = new ArrayList<Integer>(); // 크기 0으로 생성
arr.add(3); // 크기 0이였는데 동적으로 삽입
arr.get(0); // 값 출력 잘 나옴
```

<br>

#### C언어

**배열 선언은 정적이고, 배열 크기도 정적이다.**

컴파일 시간에 타입검사를 하는데 값은 알 수 없다고 앞에서 설명했었다.

자바처럼 ArrayList 같은 동적 배열도 없다.

* **malloc** 으로 동적 할당은 가능하다.
* 단, 반드시 **free();** 로 해제 필수!! 자바는 가상머신이 알아서 관리!!

<br>

**예시**

```C
int size = 50;
int arr[size]; // 에러(컴파일때 size 타입만 알고있음)
int arr[30]; // 가능
arr[31] = 3; // 에러(동적으로 크기 못 키움)

int* data = NULL; // STACK에 변수 등록 (동적 배열 역할을 수행할 것임)
int dataSize = 20;
data = (int*)malloc(sizeof(int)*dataSize); // 20크기 배열로 힙에 메모리 동적할당
printf("%d\n", *(data+1)); // data[1] 값은 쓰레기값 출력
memset(data, 0, _msize(data)); // memset 함수 활용해서 0으로 초기화
printf("%d\n", *(data+1)); // data[1] 값은 0 출력
free(data); // Heap에서 메모리제거 (필수!!)
data = NULL; // STACK에 등록한 변수 주소도 초기화 (필수 아니여도 안쓰는 변수니까 하는게 좋.)
```

<br><br>

## 6. 자바, 파이썬 예외처리

**예외처리 문법**

* python : try, except, finally, raise
* Java와의 차이점 : except -> catch, raise -> throw

<br>

**예외 검사** – 예외처리 구문이 있는지 `컴파일 시간`에 미리 검사하자라는 뜻

* try-catch 문으로 처리될 수 있는가를 검사

* 추가로 자바의 경우 메소드 헤더에 throws로 선언되었는가로도 검사가 가능

<br><br>

## 7. 정적 변수 및 정적 메소드 - static

**변수?**

* **실체 변수(=객체 변수)** – 각 객체마다 기억공간이 할당됨(`인스턴스 내`에 변수)

  * 자바 - 선언해서 바로 사용


  * 파이썬 - 선언하지 않고 바로 사용(타입 지정을 안하다보니)


* **정적 변수(=클래스 변수)**

  * 자바 - static으로 선언된 변수(`클래스 내`에 기억공간 생성)

  * 파이썬 - 그냥 바로 초기화가 됨. 대신 사용은 자바처럼 `클래스명.변수명` 으로 동일

* **전역 변수(=객체변수 + 클래스변수)** - `어디서든 호출 가능`. 즉, 클래스 내에서 or 객체들 내에서 사용가능한 변수

  * 자바 - 전역에서 사용 가능

  * 파이썬 - 전역에서 사용 가능(다만, **global 선언**이 필요할 때가 있음)

    * global 선언은 **다른 클래스**에서도 전역으로 사용하게 해줌. 근데 **그냥 해도 사용**됨.

    * 다만 **함수에선** 지역변수로 자동 생성(실체변수)되므로 **global 선언 꼭 해**줘야 전역 변수를 바인딩함.

<br>

**메소드?**

* **실체 메소드(=객체 메소드)** - `객체 생성 후` 사용가능, 해당 인스턴스내 메소드

* **정적 메소드(=클래스 메소드)** – static으로 선언된 메소드(`객체 생성 X` => 따라서 실체 변수 사용 못함)

<br><br>

## 8. 클래스?

### 1-1. Java 클래스

**중요) 클래스에서 타입 캐스팅은 부모-자식 관계여야 가능**

class 클래스 이름 {...} 내부에 3가지를 **"클래스 멤버"**라 칭한다.

* 3가지 : 필드 **변수** 선언, **생성자** 선언, **메소드** 선언

<br>

**객체 참조 변수 선언** – 객체 생성(동적할당)된 것 아님(그러나 C++은 생성. 정적 바인딩)

**객체 생성** – new 연산자로 객체 생성된 것(동적 바인딩)

* 스택에 acc1(즉, 변수명), 힙에 객체(instance)할당 => acc1이 힙에 객체를 가리킴

* 스택에 acc1이 제거되면? 
  * 힙에 객체는 자바의 경우 GC가 제거해주고, C언어는 free()로 직접 반환
  * 자바는 C처럼 메모리에 직접 접근 불가하기 때문

<br>

#### 1-2. 제네릭

**제네릭 프로그래밍 – `매개변수 다형성`**

* **제네릭 클래스** – `타입 매개변수(type parameter)`를 받는 클래스

  * `ArrayList<Integer>...`


  * `public class Box<T> { }`

* **제네릭 메소드** – `타입 매개변수(type parameter)`를 받는 메소드

  * `public static <T> Box<T> boxing(T t) {...}` (참고로 `Box<T>`는 실제 클래스 타입이다!

* **호출 방법** - 클래스는 뒤에, 메소드는 앞에 `<>`

  * `Box<String> box1 = TestBox.<String>boxing(“test”);`   
    참고로 TestBox클래스의 메소드인 boxing() 을 호출 한 것


<br><br>

### 2-1. python 클래스

`class 클래스명:` 으로 클래스를 선언한다.

* **생성자** : `def __init__(self, 매개변수):` 
* **소멸자** : `def __del__(self, 매개변수):`

<br><br>

### 3-1. C++ 객체 및 클래스

**특징은 `this->name`이다.** 

* this가 자바나 파이썬도 주소지만(당연히 모든 변수는 주소) 객체를 저장한 메모리 주소이고, 

* C는 그 객체 저장한 메모리 주소를 저장한 메모리를 가리키는 주소라 차이가 있는 것이다(

<br>

**객체 변수 접근**은 `this->balance 와 balance` 둘다 가능

**객체 생성 방식 2가지**(자바랑 구분, 자바는 애초에 new로 생성해도 `.`으로 접근함)

1. **클래스 타입으로 변수를 선언(정적) - 스택**
   * `int a=0;` - 스택
   * `a;` - 주소가 아닌 **값**
   * 클래스 타입으로 선언한 acc1도 주소가 아닌 **값**으로 접근
   * 따라서 `acc1.메소드`로 사용가능
2. **new 연산자를 이용한 동적 객체 생성 - 힙**
   * `(*p).메소드명`  또는
   * `p->메소드명` 으로 접근이 가능
   * new를 통해 주소를 저장해서 동적으로 객체 생성하기 때문

<br>

#### 3-2. 템플릿 – 제네릭 프로그래밍

**템플릿 – `매개변수 다형성`**

**템플릿 클래스** – `template <typename 변수이름>` 을 class 선언전에 추가, type자리엔 전부 T

**템플릿 함수** - `template <typename 변수이름>` 을 함수 선언전에 추가, type자리엔 전부 T

**자바와 차이점**

* 정의 표기법이 좀 다르고, 
* 실행 때 자바와 다르게 클래스, 함수 둘다 `예로 <int>`가 뒤에 들어감
  * `sum<int>(1,2);` 와 `Box<string> b(“hello”);`

<br><br>

## 9. 상속?

**상속 – 자식 클래스가 부모 클래스를 포함하는 집합 느낌(부모 메소드, 변수 + 자신꺼 사용하니까)**

<br>

### 1-1. Java 상속

**extends** 사용, **단일 상속**만 지원(python, C++ 은 여러개 지원!)

**super** – 부모 클래스 참조

**오버라이딩(메소드 재정의)** - 부모 클래스의 메소드를 자식 클래스가 재정의 + **서명 동일**

**오버로딩(중복정의)** - 한 클래스 내에 같은 이름이 여러 개의 메소드 + **서로 다른 서명**

* **메소드 서명(signature)** - 메소드의 매개변수 이름, 개수, 순서, 타입

<br>

#### 1-2. 다형 참조

**다형 참조** – 참조변수는 선언된 클래스의 객체뿐만 아니라 자손 클래스의 객체도 참조 가능

* **동적 바인딩(실행시간에 바인딩)** - 호출될 메소드는 참조 변수의 타입이 아닌 실행시간에 참조된 객체 타입에 결정

* **다형 참조로 동적 바인딩** 한 것은 해당 함수가 서로 있으니까 현재 참조하는 객체에 맞는 함수를 실행해준 것
  * 예시로 `emp = manager; emp.pay();` 은 오버라이딩한 manager꺼 pay()를 호출하게 됨

**참고로 이렇게 암묵적 확장만 가능하지 축소는 정보손실 때매 애초에 불허**

<br>

#### 1-2. 타입 캐스팅

**타입 캐스팅** – 부모클래스가 해당 함수 없을 때 사용**(반드시 동적 바인딩과 구분!!!)**

* 자바에서 자동 축소 아예 불허인데 **INT형만 가능**(범위 이내 가능. 예외적 상황임).
* 캐스팅(범위 이상 가능). 즉, 캐스팅은 강제로 변환!(double->int같은것). 정보손실도 상관없다는 것. 다만!!
* **클래스에선 상속에 다형참조 여야 가능**
  * 예시로 `Employee e = new Manager(); e.getbonus();`   
    getbonus() 메소드가 Manager꺼다? 그럼 부모엔 함수 없어서 사용불가.  
    이럴 때 아예 타입을 바꿔야 한다는 것!(타입 캐스팅). `(Manager) e.getbonus();` 가 올바르다.
* **타입 캐스팅이 오류인 예?** 
  * `Employee a = new Employee(); Manager b = (Manager) a;`  
    다형 참조가 아니기 때문에 캐스팅 불가.

**즉, 다형참조 후에 캐스팅해야 캐스팅 가능, 다형참조 아니면 캐스팅 불가**

<br>

#### 1-3. 추상 클래스

**추상 클래스** – 덜 구현된 클래스. 따라서 실체화될 수 없다(객체 생성X)

자식클래스가 부모 클래스의 해당 추상메소드를 구현하지 않으면 자신도 추상 클래스가됨(강제 오버라이딩 시키는구조라 판단)

* `abstract class 클래스이름 { abstract 리턴타입 메소드이름(매개변수선언); // 본체가 없다 }`
  * 추상 메소드는 final, static으로 선언X
  * 추상 메소드는 코드처럼 본체가 없다

<br>

추상클래스가 Worker였고, pay()메소드가 추상메소드였다면? 

* 자식 클래스인 Employee와 Parttimer또한 메소드 오버라이딩 했을 것이다. 
* 그럼 `Worker work = new Employee() 나 Parttimer()` 로 work가 원하는 pay()메소드 사용가능

* **추상 클래스를 쓰면 이렇게 공통된 하나의 Worker로 표현이 가능. 이것이 주로 추상을 사용하는 이유!**

<br>

### 2-1. C++ 상속

**명칭 구분**

* C++ : 데이터 멤버, 멤버함수

* Java : 인스턴스 변수, 메소드

<br>

**C++의 가상 함수** – virtual로 선언된 함수로 자식클래스에서 재정의 가능한 함수(Java 메소드는 virtual!!)

* 가상 함수 호출 – 객체 타입에 따라 동적 바인딩

**C++의 순수 가상 함수** – 자식클래스에서 정의되는 함수(Java의 추상 메소드). 본체가 정의 안된 함수로 암기

* 가상 함수가 아니라면 정적 바인딩을 한다.(컴파일시간. 타입선언)
  * 정적 바인딩 장점은 실행 효율. 그래서 C++은 자바보다 기본적으로 빠름.

<br>

유효범위 해결 연산자 – Student::sleep() 혹은 Worker::sleep()

* 다중상속의 죽음의 다이아몬드 문제를 해결

<br>

### 3-1. Python 상속

C++의 virtual선언 같은 것이 필요없고, 자바처럼 바로 재정의(오버라이딩)가능

다중상속의 죽음의 다이아몬드 문제없음

* 다중상속의 메소드를 메소드 탐색 순서대로 확인하기 때문

<br>

## 10. 참고

### C/C++
일단 0으로 초기화하는 방법은  
int array[10] = {0,}; 

그럼 다른 값으로 초기화 하려면?  
int array[10] = {5,};   
절대 안된다! 기본적으로 배열은 0으로 초기화 되기 때문에 조심하자.

<br>

**값, 참조 전달**

* C는 원칙적으로 값 전달만 가능. 하지만 `포인터 타입`을 통해 참조 전달 효과 가능
* C++도 값 전달이 기본인데,  `void ack(int &x, int &y); ack(a,a)` 처럼 &로서 참조 전달이 가능

<br>

### 자바
Object란 최상위 클래스이다. 모든 클래스가 Object클래스의 자식클래스이다.

자바는 모든게 클래스로 이루어져 있다.(자바스크립트가 함수로 이루어지는것 처럼)

다음으로, Object로 반환된 타입을 int형으로 바꾸려면? Integer을 사용해야 한다.

* **int가 아닌 Integer인 이유는?? => Object는 클래스 타입이므로 똑같은 클래스타입인 Integer로 형변환을 해야 한다! (부모-자식 관계)**
  * 형 변환의 기본타입들 : int, float, double, boolean...등
  * 사용자 정의 타입!!(클래스) : Double, Integer, String, Object...등

* 그러나 int age와 Integer age는 둘다가능. 차이는?? => **Integer는 null가능, int는 null불가능**

<br>

**자동 형변환**

**자동으로 형 변환하는 묵시적 형 변환**

* **확장 변환(상향 변환)** : Java에서 자동 형변환은 대부분 확장 변환(예: double y=99; // 99.0)
  * 그러나 반대의 경우는 정보 손실이 일어날일이 없음. 확장 변환(y=x)
* **축소 변환** : 확장 변환의 반대
  * 큰타입이 작은타입으로 바뀌려는건 정보 손실. 축소 변환(x=y)

* **대입 변환** : `대입문`도 확장 변환인 경우에만 자동 수행(축소 변환은 X)
  * 그런데 예외적으로 int 상수에 대해서만 **자동 축소 변환가능**

* 예시
  * byte b = 123; // 축소 변환
  * short s = 456; // 축소 변환
  * int i = s; // 확장 변환 (값을 몰라도 타입은 아니까 바로 확장 변환)
  * byte b2 = 456; // 오류 (byte 범위 밖)
  * short s2 = i; // 오류 (타입은 알아도 현재 값은 모름)
  * 컴파일할 때 변수의 TypeO, 값X(모름)
* **C는 확장, 축소 둘다 허용**
* **자바는 확장, 손실없는 축소 까지 허용**

<br>

**참고로 캐스팅의 경우?**

* C, 자바 둘다 문제없음. 즉, 명시적이지 자동 묵시적 형변환이 아님

<br>

**Java – public, private, package, protected**

<br>

### 파이썬
파이썬은 괄호로 하지않고 ':' 이걸로 코드 분류!  
들여쓰기 정말 중요. 안된다싶으면 들여쓰기 없애서 해보는것도 에러해결의 방법

* 왜냐하면 탭을 사용했거나 스페이스바를 사용한 들여쓰기는 차이가 있기 때문!

<br>

**Python – 밑줄x(public), __로 시작(private), _로 시작(protected)**
